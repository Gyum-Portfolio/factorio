[
    {
        "index": 1,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "429833cae6fe3c3b31a2412eae346daea76028ba",
        "before": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.messaging.handler.invocation;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.core.MethodIntrospector;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.lang.Nullable;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.MessageHandler;\nimport org.springframework.messaging.MessageHandlingException;\nimport org.springframework.messaging.MessagingException;\nimport org.springframework.messaging.handler.DestinationPatternsMessageCondition;\nimport org.springframework.messaging.handler.HandlerMethod;\nimport org.springframework.messaging.handler.MessagingAdviceBean;\nimport org.springframework.messaging.support.MessageBuilder;\nimport org.springframework.messaging.support.MessageHeaderAccessor;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.StringUtils;\n\n/**\n * Abstract base class for HandlerMethod-based message handling. Provides most of\n * the logic required to discover handler methods at startup, find a matching handler\n * method at runtime for a given message and invoke it.\n *\n * <p>Also supports discovering and invoking exception handling methods to process\n * exceptions raised during message handling.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n * @param <T> the type of the Object that contains information mapping a\n * {@link org.springframework.messaging.handler.HandlerMethod} to incoming messages\n */\npublic abstract class AbstractMethodMessageHandler<T>\n\t\timplements MessageHandler, ApplicationContextAware, InitializingBean {\n\n\t/**\n\t * Bean name prefix for target beans behind scoped proxies. Used to exclude those\n\t * targets from handler method detection, in favor of the corresponding proxies.\n\t * <p>We're not checking the autowire-candidate status here, which is how the\n\t * proxy target filtering problem is being handled at the autowiring level,\n\t * since autowire-candidate may have been turned to {@code false} for other\n\t * reasons, while still expecting the bean to be eligible for handler methods.\n\t * <p>Originally defined in {@link org.springframework.aop.scope.ScopedProxyUtils}\n\t * but duplicated here to avoid a hard dependency on the spring-aop module.\n\t */\n\tprivate static final String SCOPED_TARGET_NAME_PREFIX = \"scopedTarget.\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate Log handlerMethodLogger;\n\n\n\tprivate final List<String> destinationPrefixes = new ArrayList<>();\n\n\tprivate final List<HandlerMethodArgumentResolver> customArgumentResolvers = new ArrayList<>(4);\n\n\tprivate final List<HandlerMethodReturnValueHandler> customReturnValueHandlers = new ArrayList<>(4);\n\n\tprivate final HandlerMethodArgumentResolverComposite argumentResolvers =\n\t\t\tnew HandlerMethodArgumentResolverComposite();\n\n\tprivate final HandlerMethodReturnValueHandlerComposite returnValueHandlers =\n\t\t\tnew HandlerMethodReturnValueHandlerComposite();\n\n\t@Nullable\n\tprivate ApplicationContext applicationContext;\n\n\tprivate final Map<T, HandlerMethod> handlerMethods = new LinkedHashMap<>(64);\n\n\tprivate final MultiValueMap<String, T> destinationLookup = new LinkedMultiValueMap<>(48);\n\n\tprivate final Map<Class<?>, AbstractExceptionHandlerMethodResolver> exceptionHandlerCache =\n\t\t\tnew ConcurrentHashMap<>(64);\n\n\tprivate final Map<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> exceptionHandlerAdviceCache =\n\t\t\tnew LinkedHashMap<>(64);\n\n\n\t/**\n\t * When this property is configured only messages to destinations matching\n\t * one of the configured prefixes are eligible for handling. When there is a\n\t * match the prefix is removed and only the remaining part of the destination\n\t * is used for method-mapping purposes.\n\t * <p>By default, no prefixes are configured in which case all messages are\n\t * eligible for handling.\n\t */\n\tpublic void setDestinationPrefixes(@Nullable Collection<String> prefixes) {\n\t\tthis.destinationPrefixes.clear();\n\t\tif (prefixes != null) {\n\t\t\tfor (String prefix : prefixes) {\n\t\t\t\tprefix = prefix.trim();\n\t\t\t\tthis.destinationPrefixes.add(prefix);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured destination prefixes, if any.\n\t */\n\tpublic Collection<String> getDestinationPrefixes() {\n\t\treturn this.destinationPrefixes;\n\t}\n\n\t/**\n\t * Sets the list of custom {@code HandlerMethodArgumentResolver}s that will be used\n\t * after resolvers for supported argument type.\n\t */\n\tpublic void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> customArgumentResolvers) {\n\t\tthis.customArgumentResolvers.clear();\n\t\tif (customArgumentResolvers != null) {\n\t\t\tthis.customArgumentResolvers.addAll(customArgumentResolvers);\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured custom argument resolvers, if any.\n\t */\n\tpublic List<HandlerMethodArgumentResolver> getCustomArgumentResolvers() {\n\t\treturn this.customArgumentResolvers;\n\t}\n\n\t/**\n\t * Set the list of custom {@code HandlerMethodReturnValueHandler}s that will be used\n\t * after return value handlers for known types.\n\t */\n\tpublic void setCustomReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> customReturnValueHandlers) {\n\t\tthis.customReturnValueHandlers.clear();\n\t\tif (customReturnValueHandlers != null) {\n\t\t\tthis.customReturnValueHandlers.addAll(customReturnValueHandlers);\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured custom return value handlers, if any.\n\t */\n\tpublic List<HandlerMethodReturnValueHandler> getCustomReturnValueHandlers() {\n\t\treturn this.customReturnValueHandlers;\n\t}\n\n\t/**\n\t * Configure the complete list of supported argument types, effectively overriding\n\t * the ones configured by default. This is an advanced option; for most use cases\n\t * it should be sufficient to use {@link #setCustomArgumentResolvers}.\n\t */\n\tpublic void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t\tif (argumentResolvers == null) {\n\t\t\tthis.argumentResolvers.clear();\n\t\t\treturn;\n\t\t}\n\t\tthis.argumentResolvers.addResolvers(argumentResolvers);\n\t}\n\n\t/**\n\t * Return the complete list of argument resolvers.\n\t */\n\tpublic List<HandlerMethodArgumentResolver> getArgumentResolvers() {\n\t\treturn this.argumentResolvers.getResolvers();\n\t}\n\n\t/**\n\t * Configure the complete list of supported return value types, effectively overriding\n\t * the ones configured by default. This is an advanced option; for most use cases\n\t * it should be sufficient to use {@link #setCustomReturnValueHandlers}.\n\t */\n\tpublic void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t\tif (returnValueHandlers == null) {\n\t\t\tthis.returnValueHandlers.clear();\n\t\t\treturn;\n\t\t}\n\t\tthis.returnValueHandlers.addHandlers(returnValueHandlers);\n\t}\n\n\t/**\n\t * Return the complete list of return value handlers.\n\t */\n\tpublic List<HandlerMethodReturnValueHandler> getReturnValueHandlers() {\n\t\treturn this.returnValueHandlers.getReturnValueHandlers();\n\t}\n\n\t@Override\n\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Nullable\n\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tif (this.argumentResolvers.getResolvers().isEmpty()) {\n\t\t\tthis.argumentResolvers.addResolvers(initArgumentResolvers());\n\t\t}\n\n\t\tif (this.returnValueHandlers.getReturnValueHandlers().isEmpty()) {\n\t\t\tthis.returnValueHandlers.addHandlers(initReturnValueHandlers());\n\t\t}\n\t\tLog returnValueLogger = getReturnValueHandlerLogger();\n\t\tif (returnValueLogger != null) {\n\t\t\tthis.returnValueHandlers.setLogger(returnValueLogger);\n\t\t}\n\n\t\tthis.handlerMethodLogger = getHandlerMethodLogger();\n\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (String beanName : context.getBeanNamesForType(Object.class)) {\n\t\t\tif (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n\t\t\t\tClass<?> beanType = null;\n\t\t\t\ttry {\n\t\t\t\t\tbeanType = context.getType(beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// An unresolvable bean type, probably from a lazy bean - let's ignore it.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Could not resolve target class for bean with name '\" + beanName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (beanType != null && isHandler(beanType)) {\n\t\t\t\t\tdetectHandlerMethods(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the list of argument resolvers to use. Invoked only if the resolvers\n\t * have not already been set via {@link #setArgumentResolvers}.\n\t * <p>Subclasses should also take into account custom argument types configured via\n\t * {@link #setCustomArgumentResolvers}.\n\t */\n\tprotected abstract List<? extends HandlerMethodArgumentResolver> initArgumentResolvers();\n\n\t/**\n\t * Return the list of return value handlers to use. Invoked only if the return\n\t * value handlers have not already been set via {@link #setReturnValueHandlers}.\n\t * <p>Subclasses should also take into account custom return value types configured\n\t * via {@link #setCustomReturnValueHandlers}.\n\t */\n\tprotected abstract List<? extends HandlerMethodReturnValueHandler> initReturnValueHandlers();\n\n\n\t/**\n\t * Whether the given bean type should be introspected for messaging handling methods.\n\t */\n\tprotected abstract boolean isHandler(Class<?> beanType);\n\n\t/**\n\t * Detect if the given handler has any methods that can handle messages and if\n\t * so register it with the extracted mapping information.\n\t * @param handler the handler to check, either an instance of a Spring bean name\n\t */\n\tprotected final void detectHandlerMethods(final Object handler) {\n\t\tClass<?> handlerType;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerType = context.getType(beanName);\n\t\t}\n\t\telse {\n\t\t\thandlerType = handler.getClass();\n\t\t}\n\n\t\tif (handlerType != null) {\n\t\t\tfinal Class<?> userType = ClassUtils.getUserClass(handlerType);\n\t\t\tMap<Method, T> methods = MethodIntrospector.selectMethods(userType,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<T>) method -> getMappingForMethod(method, userType));\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(formatMappings(userType, methods));\n\t\t\t}\n\t\t\tmethods.forEach((key, value) -> registerHandlerMethod(handler, key, value));\n\t\t}\n\t}\n\n\tprivate String formatMappings(Class<?> userType, Map<Method, T> methods) {\n\t\tString packageName = ClassUtils.getPackageName(userType);\n\t\tString formattedType = (StringUtils.hasText(packageName) ?\n\t\t\t\tArrays.stream(packageName.split(\"\\\\.\"))\n\t\t\t\t\t\t.map(packageSegment -> packageSegment.substring(0, 1))\n\t\t\t\t\t\t.collect(Collectors.joining(\".\", \"\", \".\" + userType.getSimpleName())) :\n\t\t\t\tuserType.getSimpleName());\n\t\tFunction<Method, String> methodFormatter = method -> Arrays.stream(method.getParameterTypes())\n\t\t\t\t.map(Class::getSimpleName)\n\t\t\t\t.collect(Collectors.joining(\",\", \"(\", \")\"));\n\t\treturn methods.entrySet().stream()\n\t\t\t\t.map(e -> {\n\t\t\t\t\tMethod method = e.getKey();\n\t\t\t\t\treturn e.getValue() + \": \" + method.getName() + methodFormatter.apply(method);\n\t\t\t\t})\n\t\t\t\t.collect(Collectors.joining(\"\\n\\t\", \"\\n\\t\" + formattedType + \":\" + \"\\n\\t\", \"\"));\n\t}\n\n\t/**\n\t * Provide the mapping for a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */\n\t@Nullable\n\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);\n\n\t/**\n\t * Register a handler method and its unique mapping.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */\n\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupDestinations(mapping)) {\n\t\t\tthis.destinationLookup.add(pattern, mapping);\n\t\t}\n\t}\n\n\t/**\n\t * Create a HandlerMethod instance from an Object handler that is either a handler\n\t * instance or a String-based bean name.\n\t */\n\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tHandlerMethod handlerMethod;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerMethod = new HandlerMethod(beanName, context.getAutowireCapableBeanFactory(), method);\n\t\t}\n\t\telse {\n\t\t\thandlerMethod = new HandlerMethod(handler, method);\n\t\t}\n\t\treturn handlerMethod;\n\t}\n\n\t/**\n\t * Return destinations contained in the mapping that are not patterns and are\n\t * therefore suitable for direct lookups.\n\t */\n\tprotected abstract Set<String> getDirectLookupDestinations(T mapping);\n\n\t/**\n\t * Return a logger to set on {@link HandlerMethodReturnValueHandlerComposite}.\n\t * @since 5.1\n\t */\n\t@Nullable\n\tprotected Log getReturnValueHandlerLogger() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return a logger to set on {@link InvocableHandlerMethod}.\n\t * @since 5.1\n\t */\n\t@Nullable\n\tprotected Log getHandlerMethodLogger() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (for example, to support \"global\" {@code @MessageExceptionHandler}).\n\t * @since 4.2\n\t */\n\tprotected void registerExceptionHandlerAdvice(\n\t\t\tMessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver) {\n\n\t\tthis.exceptionHandlerAdviceCache.put(bean, resolver);\n\t}\n\n\t/**\n\t * Return a map with all handler methods and their mappings.\n\t */\n\tpublic Map<T, HandlerMethod> getHandlerMethods() {\n\t\treturn Collections.unmodifiableMap(this.handlerMethods);\n\t}\n\n\n\t@Override\n\tpublic void handleMessage(Message<?> message) throws MessagingException {\n\t\tString destination = getDestination(message);\n\t\tif (destination == null) {\n\t\t\treturn;\n\t\t}\n\t\tString lookupDestination = getLookupDestination(destination);\n\t\tif (lookupDestination == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessageHeaderAccessor headerAccessor = MessageHeaderAccessor.getMutableAccessor(message);\n\t\theaderAccessor.setHeader(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER, lookupDestination);\n\t\theaderAccessor.setLeaveMutable(true);\n\t\tmessage = MessageBuilder.createMessage(message.getPayload(), headerAccessor.getMessageHeaders());\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" +\n\t\t\t\t\theaderAccessor.getShortLogMessage(message.getPayload()) +\n\t\t\t\t\t\", lookupDestination='\" + lookupDestination + \"'\");\n\t\t}\n\n\t\thandleMessageInternal(message, lookupDestination);\n\t\theaderAccessor.setImmutable();\n\t}\n\n\t@Nullable\n\tprotected abstract String getDestination(Message<?> message);\n\n\t/**\n\t * Check whether the given destination (of an incoming message) matches to\n\t * one of the configured destination prefixes and if so return the remaining\n\t * portion of the destination after the matched prefix.\n\t * <p>If there are no matching prefixes, return {@code null}.\n\t * <p>If there are no destination prefixes, return the destination as is.\n\t */\n\t@SuppressWarnings(\"ForLoopReplaceableByForEach\")\n\t@Nullable\n\tprotected String getLookupDestination(@Nullable String destination) {\n\t\tif (destination == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (CollectionUtils.isEmpty(this.destinationPrefixes)) {\n\t\t\treturn destination;\n\t\t}\n\t\tfor (String prefix : this.destinationPrefixes) {\n\t\t\tif (destination.startsWith(prefix)) {\n\t\t\t\treturn destination.substring(prefix.length());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void handleMessageInternal(Message<?> message, String lookupDestination) {\n\t\tList<Match> matches = new ArrayList<>();\n\n\t\tList<T> mappingsByUrl = this.destinationLookup.get(lookupDestination);\n\t\tif (mappingsByUrl != null) {\n\t\t\taddMatchesToCollection(mappingsByUrl, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\t// No direct hits, go through all mappings\n\t\t\tSet<T> allMappings = this.handlerMethods.keySet();\n\t\t\taddMatchesToCollection(allMappings, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\thandleNoMatch(this.handlerMethods.keySet(), lookupDestination, message);\n\t\t\treturn;\n\t\t}\n\n\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(message));\n\t\tmatches.sort(comparator);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Found \" + matches.size() + \" handler methods: \" + matches);\n\t\t}\n\n\t\tMatch bestMatch = matches.get(0);\n\t\tif (matches.size() > 1) {\n\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\tMethod m1 = bestMatch.handlerMethod.getMethod();\n\t\t\t\tMethod m2 = secondBestMatch.handlerMethod.getMethod();\n\t\t\t\tthrow new IllegalStateException(\"Ambiguous handler methods mapped for destination '\" +\n\t\t\t\t\t\tlookupDestination + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t}\n\t\t}\n\n\t\thandleMatch(bestMatch.mapping, bestMatch.handlerMethod, lookupDestination, message);\n\t}\n\n\t@SuppressWarnings(\"NullAway\")\n\tprivate void addMatchesToCollection(Collection<T> mappingsToCheck, Message<?> message, List<Match> matches) {\n\t\tfor (T mapping : mappingsToCheck) {\n\t\t\tT match = getMatchingMapping(mapping, message);\n\t\t\tif (match != null) {\n\t\t\t\tmatches.add(new Match(match, this.handlerMethods.get(mapping)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */\n\t@Nullable\n\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);\n\n\tprotected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {\n\t\tlogger.debug(\"No matching message handler methods.\");\n\t}\n\n\t/**\n\t * Return a comparator for sorting matching mappings.\n\t * The returned comparator should sort 'better' matches higher.\n\t * @param message the current Message\n\t * @return the comparator, never {@code null}\n\t */\n\tprotected abstract Comparator<T> getMappingComparator(Message<?> message);\n\n\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + handlerMethod.getShortLogMessage());\n\t\t}\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\tInvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);\n\t\tif (this.handlerMethodLogger != null) {\n\t\t\tinvocable.setLogger(this.handlerMethodLogger);\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\ttry {\n\t\t\tObject returnValue = invocable.invoke(message);\n\t\t\tMethodParameter returnType = handlerMethod.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (returnValue != null && this.returnValueHandlers.isAsyncReturnValue(returnValue, returnType)) {\n\t\t\t\tCompletableFuture<?> future = this.returnValueHandlers.toCompletableFuture(returnValue, returnType);\n\t\t\t\tif (future != null) {\n\t\t\t\t\tfuture.whenComplete(new ReturnValueListenableFutureCallback(invocable, message));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tprocessHandlerMethodException(handlerMethod, ex, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tException handlingException =\n\t\t\t\t\tnew MessageHandlingException(message, \"Unexpected handler method invocation error\", ex);\n\t\t\tprocessHandlerMethodException(handlerMethod, handlingException, message);\n\t\t}\n\t}\n\n\tprotected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message) {\n\t\tInvocableHandlerMethod invocable = getExceptionHandlerMethod(handlerMethod, exception);\n\t\tif (invocable == null) {\n\t\t\tlogger.error(\"Unhandled exception from message handler method\", exception);\n\t\t\treturn;\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + invocable.getShortLogMessage());\n\t\t}\n\t\ttry {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tObject returnValue = (cause != null ?\n\t\t\t\t\tinvocable.invoke(message, exception, cause, handlerMethod) :\n\t\t\t\t\tinvocable.invoke(message, exception, handlerMethod));\n\t\t\tMethodParameter returnType = invocable.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t}\n\t\tcatch (Throwable ex2) {\n\t\t\tlogger.error(\"Error while processing handler method exception\", ex2);\n\t\t}\n\t}\n\n\t/**\n\t * Find an {@code @MessageExceptionHandler} method for the given exception.\n\t * The default implementation searches methods in the class hierarchy of the\n\t * HandlerMethod first and if not found, it continues searching for additional\n\t * {@code @MessageExceptionHandler} methods among the configured\n\t * {@linkplain org.springframework.messaging.handler.MessagingAdviceBean\n\t * MessagingAdviceBean}, if any.\n\t * @param handlerMethod the method where the exception was raised\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null}\n\t * @since 4.2\n\t */\n\t@Nullable\n\tprotected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" + exception.getClass().getSimpleName());\n\t\t}\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tAbstractExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(beanType);\n\t\tif (resolver == null) {\n\t\t\tresolver = createExceptionHandlerMethodResolverFor(beanType);\n\t\t\tthis.exceptionHandlerCache.put(beanType, resolver);\n\t\t}\n\t\tMethod method = resolver.resolveMethod(exception);\n\t\tif (method != null) {\n\t\t\treturn new InvocableHandlerMethod(handlerMethod.getBean(), method);\n\t\t}\n\t\tfor (Map.Entry<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tMessagingAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(beanType)) {\n\t\t\t\tresolver = entry.getValue();\n\t\t\t\tmethod = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new InvocableHandlerMethod(advice.resolveBean(), method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected abstract AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(\n\t\t\tClass<?> beanType);\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[prefixes=\" + getDestinationPrefixes() + \"]\";\n\t}\n\n\n\t/**\n\t * A thin wrapper around a matched HandlerMethod and its matched mapping for\n\t * the purpose of comparing the best match with a comparator in the context\n\t * of a message.\n\t */\n\tprivate class Match {\n\n\t\tprivate final T mapping;\n\n\t\tprivate final HandlerMethod handlerMethod;\n\n\t\tpublic Match(T mapping, HandlerMethod handlerMethod) {\n\t\t\tthis.mapping = mapping;\n\t\t\tthis.handlerMethod = handlerMethod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.mapping.toString();\n\t\t}\n\t}\n\n\n\tprivate class MatchComparator implements Comparator<Match> {\n\n\t\tprivate final Comparator<T> comparator;\n\n\t\tpublic MatchComparator(Comparator<T> comparator) {\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}\n\t}\n\n\n\tprivate class ReturnValueListenableFutureCallback implements BiConsumer<Object, Throwable> {\n\n\t\tprivate final InvocableHandlerMethod handlerMethod;\n\n\t\tprivate final Message<?> message;\n\n\t\tpublic ReturnValueListenableFutureCallback(InvocableHandlerMethod handlerMethod, Message<?> message) {\n\t\t\tthis.handlerMethod = handlerMethod;\n\t\t\tthis.message = message;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(@Nullable Object result, @Nullable Throwable ex) {\n\t\t\tif (result != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMethodParameter returnType = this.handlerMethod.getAsyncReturnValueType(result);\n\t\t\t\t\treturnValueHandlers.handleReturnValue(result, returnType, this.message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\thandleFailure(throwable);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ex != null) {\n\t\t\t\thandleFailure(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void handleFailure(Throwable throwable) {\n\t\t\tException cause = (throwable instanceof Exception exception ? exception :\n\t\t\t\t\tnew IllegalStateException(throwable));\n\t\t\tprocessHandlerMethodException(this.handlerMethod, cause, this.message);\n\t\t}\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.messaging.handler.invocation;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.core.MethodIntrospector;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.lang.Nullable;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.MessageHandler;\nimport org.springframework.messaging.MessageHandlingException;\nimport org.springframework.messaging.MessagingException;\nimport org.springframework.messaging.handler.DestinationPatternsMessageCondition;\nimport org.springframework.messaging.handler.HandlerMethod;\nimport org.springframework.messaging.handler.MessagingAdviceBean;\nimport org.springframework.messaging.support.MessageBuilder;\nimport org.springframework.messaging.support.MessageHeaderAccessor;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.StringUtils;\n\n/**\n * Abstract base class for HandlerMethod-based message handling. Provides most of\n * the logic required to discover handler methods at startup, find a matching handler\n * method at runtime for a given message and invoke it.\n *\n * <p>Also supports discovering and invoking exception handling methods to process\n * exceptions raised during message handling.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n * @param <T> the type of the Object that contains information mapping a\n * {@link org.springframework.messaging.handler.HandlerMethod} to incoming messages\n */\npublic abstract class AbstractMethodMessageHandler<T>\n\t\timplements MessageHandler, ApplicationContextAware, InitializingBean {\n\n\t/**\n\t * Bean name prefix for target beans behind scoped proxies. Used to exclude those\n\t * targets from handler method detection, in favor of the corresponding proxies.\n\t * <p>We're not checking the autowire-candidate status here, which is how the\n\t * proxy target filtering problem is being handled at the autowiring level,\n\t * since autowire-candidate may have been turned to {@code false} for other\n\t * reasons, while still expecting the bean to be eligible for handler methods.\n\t * <p>Originally defined in {@link org.springframework.aop.scope.ScopedProxyUtils}\n\t * but duplicated here to avoid a hard dependency on the spring-aop module.\n\t */\n\tprivate static final String SCOPED_TARGET_NAME_PREFIX = \"scopedTarget.\";\n\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t@Nullable\n\tprivate Log handlerMethodLogger;\n\n\n\tprivate final List<String> destinationPrefixes = new ArrayList<>();\n\n\tprivate final List<HandlerMethodArgumentResolver> customArgumentResolvers = new ArrayList<>(4);\n\n\tprivate final List<HandlerMethodReturnValueHandler> customReturnValueHandlers = new ArrayList<>(4);\n\n\tprivate final HandlerMethodArgumentResolverComposite argumentResolvers =\n\t\t\tnew HandlerMethodArgumentResolverComposite();\n\n\tprivate final HandlerMethodReturnValueHandlerComposite returnValueHandlers =\n\t\t\tnew HandlerMethodReturnValueHandlerComposite();\n\n\t@Nullable\n\tprivate ApplicationContext applicationContext;\n\n\tprivate final Map<T, HandlerMethod> handlerMethods = new LinkedHashMap<>(64);\n\n\tprivate final MultiValueMap<String, T> destinationLookup = new LinkedMultiValueMap<>(48);\n\n\tprivate final Map<Class<?>, AbstractExceptionHandlerMethodResolver> exceptionHandlerCache =\n\t\t\tnew ConcurrentHashMap<>(64);\n\n\tprivate final Map<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> exceptionHandlerAdviceCache =\n\t\t\tnew LinkedHashMap<>(64);\n\n\n\t/**\n\t * When this property is configured only messages to destinations matching\n\t * one of the configured prefixes are eligible for handling. When there is a\n\t * match the prefix is removed and only the remaining part of the destination\n\t * is used for method-mapping purposes.\n\t * <p>By default, no prefixes are configured in which case all messages are\n\t * eligible for handling.\n\t */\n\tpublic void setDestinationPrefixes(@Nullable Collection<String> prefixes) {\n\t\tthis.destinationPrefixes.clear();\n\t\tif (prefixes != null) {\n\t\t\tfor (String prefix : prefixes) {\n\t\t\t\tprefix = prefix.trim();\n\t\t\t\tthis.destinationPrefixes.add(prefix);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured destination prefixes, if any.\n\t */\n\tpublic Collection<String> getDestinationPrefixes() {\n\t\treturn this.destinationPrefixes;\n\t}\n\n\t/**\n\t * Sets the list of custom {@code HandlerMethodArgumentResolver}s that will be used\n\t * after resolvers for supported argument type.\n\t */\n\tpublic void setCustomArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> customArgumentResolvers) {\n\t\tthis.customArgumentResolvers.clear();\n\t\tif (customArgumentResolvers != null) {\n\t\t\tthis.customArgumentResolvers.addAll(customArgumentResolvers);\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured custom argument resolvers, if any.\n\t */\n\tpublic List<HandlerMethodArgumentResolver> getCustomArgumentResolvers() {\n\t\treturn this.customArgumentResolvers;\n\t}\n\n\t/**\n\t * Set the list of custom {@code HandlerMethodReturnValueHandler}s that will be used\n\t * after return value handlers for known types.\n\t */\n\tpublic void setCustomReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> customReturnValueHandlers) {\n\t\tthis.customReturnValueHandlers.clear();\n\t\tif (customReturnValueHandlers != null) {\n\t\t\tthis.customReturnValueHandlers.addAll(customReturnValueHandlers);\n\t\t}\n\t}\n\n\t/**\n\t * Return the configured custom return value handlers, if any.\n\t */\n\tpublic List<HandlerMethodReturnValueHandler> getCustomReturnValueHandlers() {\n\t\treturn this.customReturnValueHandlers;\n\t}\n\n\t/**\n\t * Configure the complete list of supported argument types, effectively overriding\n\t * the ones configured by default. This is an advanced option; for most use cases\n\t * it should be sufficient to use {@link #setCustomArgumentResolvers}.\n\t */\n\tpublic void setArgumentResolvers(@Nullable List<HandlerMethodArgumentResolver> argumentResolvers) {\n\t\tif (argumentResolvers == null) {\n\t\t\tthis.argumentResolvers.clear();\n\t\t\treturn;\n\t\t}\n\t\tthis.argumentResolvers.addResolvers(argumentResolvers);\n\t}\n\n\t/**\n\t * Return the complete list of argument resolvers.\n\t */\n\tpublic List<HandlerMethodArgumentResolver> getArgumentResolvers() {\n\t\treturn this.argumentResolvers.getResolvers();\n\t}\n\n\t/**\n\t * Configure the complete list of supported return value types, effectively overriding\n\t * the ones configured by default. This is an advanced option; for most use cases\n\t * it should be sufficient to use {@link #setCustomReturnValueHandlers}.\n\t */\n\tpublic void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n\t\tif (returnValueHandlers == null) {\n\t\t\tthis.returnValueHandlers.clear();\n\t\t\treturn;\n\t\t}\n\t\tthis.returnValueHandlers.addHandlers(returnValueHandlers);\n\t}\n\n\t/**\n\t * Return the complete list of return value handlers.\n\t */\n\tpublic List<HandlerMethodReturnValueHandler> getReturnValueHandlers() {\n\t\treturn this.returnValueHandlers.getReturnValueHandlers();\n\t}\n\n\t@Override\n\tpublic void setApplicationContext(@Nullable ApplicationContext applicationContext) {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Nullable\n\tpublic ApplicationContext getApplicationContext() {\n\t\treturn this.applicationContext;\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tif (this.argumentResolvers.getResolvers().isEmpty()) {\n\t\t\tthis.argumentResolvers.addResolvers(initArgumentResolvers());\n\t\t}\n\n\t\tif (this.returnValueHandlers.getReturnValueHandlers().isEmpty()) {\n\t\t\tthis.returnValueHandlers.addHandlers(initReturnValueHandlers());\n\t\t}\n\t\tLog returnValueLogger = getReturnValueHandlerLogger();\n\t\tif (returnValueLogger != null) {\n\t\t\tthis.returnValueHandlers.setLogger(returnValueLogger);\n\t\t}\n\n\t\tthis.handlerMethodLogger = getHandlerMethodLogger();\n\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (String beanName : context.getBeanNamesForType(Object.class)) {\n\t\t\tif (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n\t\t\t\tClass<?> beanType = null;\n\t\t\t\ttry {\n\t\t\t\t\tbeanType = context.getType(beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t// An unresolvable bean type, probably from a lazy bean - let's ignore it.\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Could not resolve target class for bean with name '\" + beanName + \"'\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (beanType != null && isHandler(beanType)) {\n\t\t\t\t\tdetectHandlerMethods(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the list of argument resolvers to use. Invoked only if the resolvers\n\t * have not already been set via {@link #setArgumentResolvers}.\n\t * <p>Subclasses should also take into account custom argument types configured via\n\t * {@link #setCustomArgumentResolvers}.\n\t */\n\tprotected abstract List<? extends HandlerMethodArgumentResolver> initArgumentResolvers();\n\n\t/**\n\t * Return the list of return value handlers to use. Invoked only if the return\n\t * value handlers have not already been set via {@link #setReturnValueHandlers}.\n\t * <p>Subclasses should also take into account custom return value types configured\n\t * via {@link #setCustomReturnValueHandlers}.\n\t */\n\tprotected abstract List<? extends HandlerMethodReturnValueHandler> initReturnValueHandlers();\n\n\n\t/**\n\t * Whether the given bean type should be introspected for messaging handling methods.\n\t */\n\tprotected abstract boolean isHandler(Class<?> beanType);\n\n\t/**\n\t * Detect if the given handler has any methods that can handle messages and if\n\t * so register it with the extracted mapping information.\n\t * @param handler the handler to check, either an instance of a Spring bean name\n\t */\n\tprotected final void detectHandlerMethods(final Object handler) {\n\t\tClass<?> handlerType;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerType = context.getType(beanName);\n\t\t}\n\t\telse {\n\t\t\thandlerType = handler.getClass();\n\t\t}\n\n\t\tif (handlerType != null) {\n\t\t\tfinal Class<?> userType = ClassUtils.getUserClass(handlerType);\n\t\t\tMap<Method, T> methods = MethodIntrospector.selectMethods(userType,\n\t\t\t\t\t(MethodIntrospector.MetadataLookup<T>) method -> getMappingForMethod(method, userType));\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(formatMappings(userType, methods));\n\t\t\t}\n\t\t\tmethods.forEach((key, value) -> registerHandlerMethod(handler, key, value));\n\t\t}\n\t}\n\n\tprivate String formatMappings(Class<?> userType, Map<Method, T> methods) {\n\t\tString packageName = ClassUtils.getPackageName(userType);\n\t\tString formattedType = (StringUtils.hasText(packageName) ?\n\t\t\t\tArrays.stream(packageName.split(\"\\\\.\"))\n\t\t\t\t\t\t.map(packageSegment -> packageSegment.substring(0, 1))\n\t\t\t\t\t\t.collect(Collectors.joining(\".\", \"\", \".\" + userType.getSimpleName())) :\n\t\t\t\tuserType.getSimpleName());\n\t\tFunction<Method, String> methodFormatter = method -> Arrays.stream(method.getParameterTypes())\n\t\t\t\t.map(Class::getSimpleName)\n\t\t\t\t.collect(Collectors.joining(\",\", \"(\", \")\"));\n\t\treturn methods.entrySet().stream()\n\t\t\t\t.map(e -> {\n\t\t\t\t\tMethod method = e.getKey();\n\t\t\t\t\treturn e.getValue() + \": \" + method.getName() + methodFormatter.apply(method);\n\t\t\t\t})\n\t\t\t\t.collect(Collectors.joining(\"\\n\\t\", \"\\n\\t\" + formattedType + \":\" + \"\\n\\t\", \"\"));\n\t}\n\n\t/**\n\t * Provide the mapping for a handler method.\n\t * @param method the method to provide a mapping for\n\t * @param handlerType the handler type, possibly a subtype of the method's declaring class\n\t * @return the mapping, or {@code null} if the method is not mapped\n\t */\n\t@Nullable\n\tprotected abstract T getMappingForMethod(Method method, Class<?> handlerType);\n\n\t/**\n\t * Register a handler method and its unique mapping.\n\t * @param handler the bean name of the handler or the handler instance\n\t * @param method the method to register\n\t * @param mapping the mapping conditions associated with the handler method\n\t * @throws IllegalStateException if another method was already registered\n\t * under the same mapping\n\t */\n\tprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n\t\tAssert.notNull(mapping, \"Mapping must not be null\");\n\t\tHandlerMethod newHandlerMethod = createHandlerMethod(handler, method);\n\t\tHandlerMethod oldHandlerMethod = this.handlerMethods.get(mapping);\n\n\t\tif (oldHandlerMethod != null && !oldHandlerMethod.equals(newHandlerMethod)) {\n\t\t\tthrow new IllegalStateException(\"Ambiguous mapping found. Cannot map '\" + newHandlerMethod.getBean() +\n\t\t\t\t\t\"' bean method \\n\" + newHandlerMethod + \"\\nto \" + mapping + \": There is already '\" +\n\t\t\t\t\toldHandlerMethod.getBean() + \"' bean method\\n\" + oldHandlerMethod + \" mapped.\");\n\t\t}\n\n\t\tthis.handlerMethods.put(mapping, newHandlerMethod);\n\n\t\tfor (String pattern : getDirectLookupDestinations(mapping)) {\n\t\t\tthis.destinationLookup.add(pattern, mapping);\n\t\t}\n\t}\n\n\t/**\n\t * Create a HandlerMethod instance from an Object handler that is either a handler\n\t * instance or a String-based bean name.\n\t */\n\tprotected HandlerMethod createHandlerMethod(Object handler, Method method) {\n\t\tHandlerMethod handlerMethod;\n\t\tif (handler instanceof String beanName) {\n\t\t\tApplicationContext context = getApplicationContext();\n\t\t\tAssert.state(context != null, \"ApplicationContext is required for resolving handler bean names\");\n\t\t\thandlerMethod = new HandlerMethod(beanName, context.getAutowireCapableBeanFactory(), method);\n\t\t}\n\t\telse {\n\t\t\thandlerMethod = new HandlerMethod(handler, method);\n\t\t}\n\t\treturn handlerMethod;\n\t}\n\n\t/**\n\t * Return destinations contained in the mapping that are not patterns and are\n\t * therefore suitable for direct lookups.\n\t */\n\tprotected abstract Set<String> getDirectLookupDestinations(T mapping);\n\n\t/**\n\t * Return a logger to set on {@link HandlerMethodReturnValueHandlerComposite}.\n\t * @since 5.1\n\t */\n\t@Nullable\n\tprotected Log getReturnValueHandlerLogger() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return a logger to set on {@link InvocableHandlerMethod}.\n\t * @since 5.1\n\t */\n\t@Nullable\n\tprotected Log getHandlerMethodLogger() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Subclasses can invoke this method to populate the MessagingAdviceBean cache\n\t * (for example, to support \"global\" {@code @MessageExceptionHandler}).\n\t * @since 4.2\n\t */\n\tprotected void registerExceptionHandlerAdvice(\n\t\t\tMessagingAdviceBean bean, AbstractExceptionHandlerMethodResolver resolver) {\n\n\t\tthis.exceptionHandlerAdviceCache.put(bean, resolver);\n\t}\n\n\t/**\n\t * Return a map with all handler methods and their mappings.\n\t */\n\tpublic Map<T, HandlerMethod> getHandlerMethods() {\n\t\treturn Collections.unmodifiableMap(this.handlerMethods);\n\t}\n\n\n\t@Override\n\tpublic void handleMessage(Message<?> message) throws MessagingException {\n\t\tString destination = getDestination(message);\n\t\tif (destination == null) {\n\t\t\treturn;\n\t\t}\n\t\tString lookupDestination = getLookupDestination(destination);\n\t\tif (lookupDestination == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tMessageHeaderAccessor headerAccessor = MessageHeaderAccessor.getMutableAccessor(message);\n\t\theaderAccessor.setHeader(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER, lookupDestination);\n\t\theaderAccessor.setLeaveMutable(true);\n\t\tmessage = MessageBuilder.createMessage(message.getPayload(), headerAccessor.getMessageHeaders());\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" +\n\t\t\t\t\theaderAccessor.getShortLogMessage(message.getPayload()) +\n\t\t\t\t\t\", lookupDestination='\" + lookupDestination + \"'\");\n\t\t}\n\n\t\thandleMessageInternal(message, lookupDestination);\n\t\theaderAccessor.setImmutable();\n\t}\n\n\t@Nullable\n\tprotected abstract String getDestination(Message<?> message);\n\n\t/**\n\t * Check whether the given destination (of an incoming message) matches to\n\t * one of the configured destination prefixes and if so return the remaining\n\t * portion of the destination after the matched prefix.\n\t * <p>If there are no matching prefixes, return {@code null}.\n\t * <p>If there are no destination prefixes, return the destination as is.\n\t */\n\t@SuppressWarnings(\"ForLoopReplaceableByForEach\")\n\t@Nullable\n\tprotected String getLookupDestination(@Nullable String destination) {\n\t\tif (destination == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (CollectionUtils.isEmpty(this.destinationPrefixes)) {\n\t\t\treturn destination;\n\t\t}\n\t\tfor (String prefix : this.destinationPrefixes) {\n\t\t\tif (destination.startsWith(prefix)) {\n\t\t\t\treturn destination.substring(prefix.length());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void handleMessageInternal(Message<?> message, String lookupDestination) {\n\t\tList<Match> matches = new ArrayList<>();\n\n\t\tList<T> mappingsByUrl = this.destinationLookup.get(lookupDestination);\n\t\tif (mappingsByUrl != null) {\n\t\t\taddMatchesToCollection(mappingsByUrl, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\t// No direct hits, go through all mappings\n\t\t\tSet<T> allMappings = this.handlerMethods.keySet();\n\t\t\taddMatchesToCollection(allMappings, message, matches);\n\t\t}\n\t\tif (matches.isEmpty()) {\n\t\t\thandleNoMatch(this.handlerMethods.keySet(), lookupDestination, message);\n\t\t\treturn;\n\t\t}\n\n\t\tComparator<Match> comparator = new MatchComparator(getMappingComparator(message));\n\t\tmatches.sort(comparator);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Found \" + matches.size() + \" handler methods: \" + matches);\n\t\t}\n\n\t\tMatch bestMatch = matches.get(0);\n\t\tif (matches.size() > 1) {\n\t\t\tMatch secondBestMatch = matches.get(1);\n\t\t\tif (comparator.compare(bestMatch, secondBestMatch) == 0) {\n\t\t\t\tMethod m1 = bestMatch.handlerMethod.getMethod();\n\t\t\t\tMethod m2 = secondBestMatch.handlerMethod.getMethod();\n\t\t\t\tthrow new IllegalStateException(\"Ambiguous handler methods mapped for destination '\" +\n\t\t\t\t\t\tlookupDestination + \"': {\" + m1 + \", \" + m2 + \"}\");\n\t\t\t}\n\t\t}\n\n\t\thandleMatch(bestMatch.mapping, bestMatch.handlerMethod, lookupDestination, message);\n\t}\n\n\t@SuppressWarnings(\"NullAway\")\n\tprivate void addMatchesToCollection(Collection<T> mappingsToCheck, Message<?> message, List<Match> matches) {\n\t\tfor (T mapping : mappingsToCheck) {\n\t\t\tT match = getMatchingMapping(mapping, message);\n\t\t\tif (match != null) {\n\t\t\t\tmatches.add(new Match(match, this.handlerMethods.get(mapping)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check if a mapping matches the current message and return a possibly\n\t * new mapping with conditions relevant to the current request.\n\t * @param mapping the mapping to get a match for\n\t * @param message the message being handled\n\t * @return the match or {@code null} if there is no match\n\t */\n\t@Nullable\n\tprotected abstract T getMatchingMapping(T mapping, Message<?> message);\n\n\tprotected void handleNoMatch(Set<T> ts, String lookupDestination, Message<?> message) {\n\t\tlogger.debug(\"No matching message handler methods.\");\n\t}\n\n\t/**\n\t * Return a comparator for sorting matching mappings.\n\t * The returned comparator should sort 'better' matches higher.\n\t * @param message the current Message\n\t * @return the comparator, never {@code null}\n\t */\n\tprotected abstract Comparator<T> getMappingComparator(Message<?> message);\n\n\tprotected void handleMatch(T mapping, HandlerMethod handlerMethod, String lookupDestination, Message<?> message) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + handlerMethod.getShortLogMessage());\n\t\t}\n\t\thandlerMethod = handlerMethod.createWithResolvedBean();\n\t\tInvocableHandlerMethod invocable = new InvocableHandlerMethod(handlerMethod);\n\t\tif (this.handlerMethodLogger != null) {\n\t\t\tinvocable.setLogger(this.handlerMethodLogger);\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\ttry {\n\t\t\tObject returnValue = invocable.invoke(message);\n\t\t\tMethodParameter returnType = handlerMethod.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (returnValue != null && this.returnValueHandlers.isAsyncReturnValue(returnValue, returnType)) {\n\t\t\t\tCompletableFuture<?> future = this.returnValueHandlers.toCompletableFuture(returnValue, returnType);\n\t\t\t\tif (future != null) {\n\t\t\t\t\tfuture.whenComplete(new ReturnValueCallback(invocable, message));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tprocessHandlerMethodException(handlerMethod, ex, message);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tException handlingException =\n\t\t\t\t\tnew MessageHandlingException(message, \"Unexpected handler method invocation error\", ex);\n\t\t\tprocessHandlerMethodException(handlerMethod, handlingException, message);\n\t\t}\n\t}\n\n\tprotected void processHandlerMethodException(HandlerMethod handlerMethod, Exception exception, Message<?> message) {\n\t\tInvocableHandlerMethod invocable = getExceptionHandlerMethod(handlerMethod, exception);\n\t\tif (invocable == null) {\n\t\t\tlogger.error(\"Unhandled exception from message handler method\", exception);\n\t\t\treturn;\n\t\t}\n\t\tinvocable.setMessageMethodArgumentResolvers(this.argumentResolvers);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Invoking \" + invocable.getShortLogMessage());\n\t\t}\n\t\ttry {\n\t\t\tThrowable cause = exception.getCause();\n\t\t\tObject returnValue = (cause != null ?\n\t\t\t\t\tinvocable.invoke(message, exception, cause, handlerMethod) :\n\t\t\t\t\tinvocable.invoke(message, exception, handlerMethod));\n\t\t\tMethodParameter returnType = invocable.getReturnType();\n\t\t\tif (void.class == returnType.getParameterType()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, returnType, message);\n\t\t}\n\t\tcatch (Throwable ex2) {\n\t\t\tlogger.error(\"Error while processing handler method exception\", ex2);\n\t\t}\n\t}\n\n\t/**\n\t * Find an {@code @MessageExceptionHandler} method for the given exception.\n\t * The default implementation searches methods in the class hierarchy of the\n\t * HandlerMethod first and if not found, it continues searching for additional\n\t * {@code @MessageExceptionHandler} methods among the configured\n\t * {@linkplain org.springframework.messaging.handler.MessagingAdviceBean\n\t * MessagingAdviceBean}, if any.\n\t * @param handlerMethod the method where the exception was raised\n\t * @param exception the raised exception\n\t * @return a method to handle the exception, or {@code null}\n\t * @since 4.2\n\t */\n\t@Nullable\n\tprotected InvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Searching methods to handle \" + exception.getClass().getSimpleName());\n\t\t}\n\t\tClass<?> beanType = handlerMethod.getBeanType();\n\t\tAbstractExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(beanType);\n\t\tif (resolver == null) {\n\t\t\tresolver = createExceptionHandlerMethodResolverFor(beanType);\n\t\t\tthis.exceptionHandlerCache.put(beanType, resolver);\n\t\t}\n\t\tMethod method = resolver.resolveMethod(exception);\n\t\tif (method != null) {\n\t\t\treturn new InvocableHandlerMethod(handlerMethod.getBean(), method);\n\t\t}\n\t\tfor (Map.Entry<MessagingAdviceBean, AbstractExceptionHandlerMethodResolver> entry : this.exceptionHandlerAdviceCache.entrySet()) {\n\t\t\tMessagingAdviceBean advice = entry.getKey();\n\t\t\tif (advice.isApplicableToBeanType(beanType)) {\n\t\t\t\tresolver = entry.getValue();\n\t\t\t\tmethod = resolver.resolveMethod(exception);\n\t\t\t\tif (method != null) {\n\t\t\t\t\treturn new InvocableHandlerMethod(advice.resolveBean(), method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected abstract AbstractExceptionHandlerMethodResolver createExceptionHandlerMethodResolverFor(\n\t\t\tClass<?> beanType);\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + \"[prefixes=\" + getDestinationPrefixes() + \"]\";\n\t}\n\n\n\t/**\n\t * A thin wrapper around a matched HandlerMethod and its matched mapping for\n\t * the purpose of comparing the best match with a comparator in the context\n\t * of a message.\n\t */\n\tprivate class Match {\n\n\t\tprivate final T mapping;\n\n\t\tprivate final HandlerMethod handlerMethod;\n\n\t\tpublic Match(T mapping, HandlerMethod handlerMethod) {\n\t\t\tthis.mapping = mapping;\n\t\t\tthis.handlerMethod = handlerMethod;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.mapping.toString();\n\t\t}\n\t}\n\n\n\tprivate class MatchComparator implements Comparator<Match> {\n\n\t\tprivate final Comparator<T> comparator;\n\n\t\tpublic MatchComparator(Comparator<T> comparator) {\n\t\t\tthis.comparator = comparator;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(Match match1, Match match2) {\n\t\t\treturn this.comparator.compare(match1.mapping, match2.mapping);\n\t\t}\n\t}\n\n\n\tprivate class ReturnValueCallback implements BiConsumer<Object, Throwable> {\n\n\t\tprivate final InvocableHandlerMethod handlerMethod;\n\n\t\tprivate final Message<?> message;\n\n\t\tpublic ReturnValueCallback(InvocableHandlerMethod handlerMethod, Message<?> message) {\n\t\t\tthis.handlerMethod = handlerMethod;\n\t\t\tthis.message = message;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(@Nullable Object result, @Nullable Throwable ex) {\n\t\t\tif (result != null) {\n\t\t\t\ttry {\n\t\t\t\t\tMethodParameter returnType = this.handlerMethod.getAsyncReturnValueType(result);\n\t\t\t\t\treturnValueHandlers.handleReturnValue(result, returnType, this.message);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable throwable) {\n\t\t\t\t\thandleFailure(throwable);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ex != null) {\n\t\t\t\thandleFailure(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void handleFailure(Throwable throwable) {\n\t\t\tException cause = (throwable instanceof Exception exception ? exception :\n\t\t\t\t\tnew IllegalStateException(throwable));\n\t\t\tprocessHandlerMethodException(this.handlerMethod, cause, this.message);\n\t\t}\n\t}\n\n}\n"
    },
    {
        "index": 2,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "41d9f21ab97b8cda9c3b740fc10b677c4d27fb50",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.beans.factory.support;\n\nimport java.io.IOException;\nimport java.io.NotSerializableException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.ref.Reference;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport jakarta.inject.Provider;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.TypeConverter;\nimport org.springframework.beans.factory.BeanCreationException;\nimport org.springframework.beans.factory.BeanCurrentlyInCreationException;\nimport org.springframework.beans.factory.BeanDefinitionStoreException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.BeanNotOfRequiredTypeException;\nimport org.springframework.beans.factory.CannotLoadBeanClassException;\nimport org.springframework.beans.factory.InjectionPoint;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.ObjectFactory;\nimport org.springframework.beans.factory.ObjectProvider;\nimport org.springframework.beans.factory.SmartFactoryBean;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.config.AutowireCapableBeanFactory;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.config.NamedBeanHolder;\nimport org.springframework.core.NamedThreadLocal;\nimport org.springframework.core.OrderComparator;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.annotation.MergedAnnotation;\nimport org.springframework.core.annotation.MergedAnnotations;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.log.LogMessage;\nimport org.springframework.core.metrics.StartupStep;\nimport org.springframework.lang.Contract;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.CompositeIterator;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * Spring's default implementation of the {@link ConfigurableListableBeanFactory}\n * and {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory\n * based on bean definition metadata, extensible through post-processors.\n *\n * <p>Typical usage is registering all bean definitions first (possibly read\n * from a bean definition file), before accessing beans. Bean lookup by name\n * is therefore an inexpensive operation in a local bean definition table,\n * operating on pre-resolved bean definition metadata objects.\n *\n * <p>Note that readers for specific bean definition formats are typically\n * implemented separately rather than as bean factory subclasses: see for example\n * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.\n *\n * <p>For an alternative implementation of the\n * {@link org.springframework.beans.factory.ListableBeanFactory} interface,\n * have a look at {@link StaticListableBeanFactory}, which manages existing\n * bean instances rather than creating new ones based on bean definitions.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Costin Leau\n * @author Chris Beams\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @author Sebastien Deleuze\n * @since 16 April 2001\n * @see #registerBeanDefinition\n * @see #addBeanPostProcessor\n * @see #getBean\n * @see #resolveDependency\n */\n@SuppressWarnings(\"serial\")\npublic class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n\t\timplements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n\n\t@Nullable\n\tprivate static Class<?> jakartaInjectProviderClass;\n\n\tstatic {\n\t\ttry {\n\t\t\tjakartaInjectProviderClass =\n\t\t\t\t\tClassUtils.forName(\"jakarta.inject.Provider\", DefaultListableBeanFactory.class.getClassLoader());\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-330 API not available - Provider interface simply not supported then.\n\t\t\tjakartaInjectProviderClass = null;\n\t\t}\n\t}\n\n\n\t/** Map from serialized id to factory instance. */\n\tprivate static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories =\n\t\t\tnew ConcurrentHashMap<>(8);\n\n\t/** Optional id for this factory, for serialization purposes. */\n\t@Nullable\n\tprivate String serializationId;\n\n\t/** Whether to allow re-registration of a different definition with the same name. */\n\t@Nullable\n\tprivate Boolean allowBeanDefinitionOverriding;\n\n\t/** Whether to allow eager class loading even for lazy-init beans. */\n\tprivate boolean allowEagerClassLoading = true;\n\n\t@Nullable\n\tprivate Executor bootstrapExecutor;\n\n\t/** Optional OrderComparator for dependency Lists and arrays. */\n\t@Nullable\n\tprivate Comparator<Object> dependencyComparator;\n\n\t/** Resolver to use for checking if a bean definition is an autowire candidate. */\n\tprivate AutowireCandidateResolver autowireCandidateResolver = SimpleAutowireCandidateResolver.INSTANCE;\n\n\t/** Map from dependency type to corresponding autowired value. */\n\tprivate final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);\n\n\t/** Map of bean definition objects, keyed by bean name. */\n\tprivate final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);\n\n\t/** Map from bean name to merged BeanDefinitionHolder. */\n\tprivate final Map<String, BeanDefinitionHolder> mergedBeanDefinitionHolders = new ConcurrentHashMap<>(256);\n\n\t// Set of bean definition names with a primary marker. */\n\tprivate final Set<String> primaryBeanNames = ConcurrentHashMap.newKeySet(16);\n\n\t/** Map of singleton and non-singleton bean names, keyed by dependency type. */\n\tprivate final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);\n\n\t/** Map of singleton-only bean names, keyed by dependency type. */\n\tprivate final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);\n\n\t/** List of bean definition names, in registration order. */\n\tprivate volatile List<String> beanDefinitionNames = new ArrayList<>(256);\n\n\t/** List of names of manually registered singletons, in registration order. */\n\tprivate volatile Set<String> manualSingletonNames = new LinkedHashSet<>(16);\n\n\t/** Cached array of bean definition names in case of frozen configuration. */\n\t@Nullable\n\tprivate volatile String[] frozenBeanDefinitionNames;\n\n\t/** Whether bean definition metadata may be cached for all beans. */\n\tprivate volatile boolean configurationFrozen;\n\n\tprivate volatile boolean preInstantiationPhase;\n\n\tprivate final NamedThreadLocal<PreInstantiation> preInstantiationThread =\n\t\t\tnew NamedThreadLocal<>(\"Pre-instantiation thread marker\");\n\n\n\t/**\n\t * Create a new DefaultListableBeanFactory.\n\t */\n\tpublic DefaultListableBeanFactory() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Create a new DefaultListableBeanFactory with the given parent.\n\t * @param parentBeanFactory the parent BeanFactory\n\t */\n\tpublic DefaultListableBeanFactory(@Nullable BeanFactory parentBeanFactory) {\n\t\tsuper(parentBeanFactory);\n\t}\n\n\n\t/**\n\t * Specify an id for serialization purposes, allowing this BeanFactory to be\n\t * deserialized from this id back into the BeanFactory object, if needed.\n\t */\n\tpublic void setSerializationId(@Nullable String serializationId) {\n\t\tif (serializationId != null) {\n\t\t\tserializableFactories.put(serializationId, new WeakReference<>(this));\n\t\t}\n\t\telse if (this.serializationId != null) {\n\t\t\tserializableFactories.remove(this.serializationId);\n\t\t}\n\t\tthis.serializationId = serializationId;\n\t}\n\n\t/**\n\t * Return an id for serialization purposes, if specified, allowing this BeanFactory\n\t * to be deserialized from this id back into the BeanFactory object, if needed.\n\t * @since 4.1.2\n\t */\n\t@Nullable\n\tpublic String getSerializationId() {\n\t\treturn this.serializationId;\n\t}\n\n\t/**\n\t * Set whether it should be allowed to override bean definitions by registering\n\t * a different definition with the same name, automatically replacing the former.\n\t * If not, an exception will be thrown. This also applies to overriding aliases.\n\t * <p>Default is \"true\".\n\t * @see #registerBeanDefinition\n\t */\n\tpublic void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {\n\t\tthis.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;\n\t}\n\n\t/**\n\t * Return whether it should be allowed to override bean definitions by registering\n\t * a different definition with the same name, automatically replacing the former.\n\t * @since 4.1.2\n\t */\n\tpublic boolean isAllowBeanDefinitionOverriding() {\n\t\treturn !Boolean.FALSE.equals(this.allowBeanDefinitionOverriding);\n\t}\n\n\t/**\n\t * Set whether the factory is allowed to eagerly load bean classes\n\t * even for bean definitions that are marked as \"lazy-init\".\n\t * <p>Default is \"true\". Turn this flag off to suppress class loading\n\t * for lazy-init beans unless such a bean is explicitly requested.\n\t * In particular, by-type lookups will then simply ignore bean definitions\n\t * without resolved class name, instead of loading the bean classes on\n\t * demand just to perform a type check.\n\t * @see AbstractBeanDefinition#setLazyInit\n\t */\n\tpublic void setAllowEagerClassLoading(boolean allowEagerClassLoading) {\n\t\tthis.allowEagerClassLoading = allowEagerClassLoading;\n\t}\n\n\t/**\n\t * Return whether the factory is allowed to eagerly load bean classes\n\t * even for bean definitions that are marked as \"lazy-init\".\n\t * @since 4.1.2\n\t */\n\tpublic boolean isAllowEagerClassLoading() {\n\t\treturn this.allowEagerClassLoading;\n\t}\n\n\t@Override\n\tpublic void setBootstrapExecutor(@Nullable Executor bootstrapExecutor) {\n\t\tthis.bootstrapExecutor = bootstrapExecutor;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Executor getBootstrapExecutor() {\n\t\treturn this.bootstrapExecutor;\n\t}\n\n\t/**\n\t * Set a {@link java.util.Comparator} for dependency Lists and arrays.\n\t * @since 4.0\n\t * @see org.springframework.core.OrderComparator\n\t * @see org.springframework.core.annotation.AnnotationAwareOrderComparator\n\t */\n\tpublic void setDependencyComparator(@Nullable Comparator<Object> dependencyComparator) {\n\t\tthis.dependencyComparator = dependencyComparator;\n\t}\n\n\t/**\n\t * Return the dependency comparator for this BeanFactory (may be {@code null}).\n\t * @since 4.0\n\t */\n\t@Nullable\n\tpublic Comparator<Object> getDependencyComparator() {\n\t\treturn this.dependencyComparator;\n\t}\n\n\t/**\n\t * Set a custom autowire candidate resolver for this BeanFactory to use\n\t * when deciding whether a bean definition should be considered as a\n\t * candidate for autowiring.\n\t */\n\tpublic void setAutowireCandidateResolver(AutowireCandidateResolver autowireCandidateResolver) {\n\t\tAssert.notNull(autowireCandidateResolver, \"AutowireCandidateResolver must not be null\");\n\t\tif (autowireCandidateResolver instanceof BeanFactoryAware beanFactoryAware) {\n\t\t\tbeanFactoryAware.setBeanFactory(this);\n\t\t}\n\t\tthis.autowireCandidateResolver = autowireCandidateResolver;\n\t}\n\n\t/**\n\t * Return the autowire candidate resolver for this BeanFactory (never {@code null}).\n\t */\n\tpublic AutowireCandidateResolver getAutowireCandidateResolver() {\n\t\treturn this.autowireCandidateResolver;\n\t}\n\n\n\t@Override\n\tpublic void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {\n\t\tsuper.copyConfigurationFrom(otherFactory);\n\t\tif (otherFactory instanceof DefaultListableBeanFactory otherListableFactory) {\n\t\t\tthis.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;\n\t\t\tthis.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;\n\t\t\tthis.bootstrapExecutor = otherListableFactory.bootstrapExecutor;\n\t\t\tthis.dependencyComparator = otherListableFactory.dependencyComparator;\n\t\t\t// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware\n\t\t\tsetAutowireCandidateResolver(otherListableFactory.getAutowireCandidateResolver().cloneIfNecessary());\n\t\t\t// Make resolvable dependencies (for example, ResourceLoader) available here as well\n\t\t\tthis.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of remaining BeanFactory methods\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n\t\treturn getBean(requiredType, (Object[]) null);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tObject resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);\n\t\tif (resolved == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t}\n\t\treturn (T) resolved;\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\treturn getBeanProvider(ResolvableType.forRawClass(requiredType), true);\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {\n\t\treturn getBeanProvider(requiredType, true);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ListableBeanFactory interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic boolean containsBeanDefinition(String beanName) {\n\t\tAssert.notNull(beanName, \"Bean name must not be null\");\n\t\treturn this.beanDefinitionMap.containsKey(beanName);\n\t}\n\n\t@Override\n\tpublic int getBeanDefinitionCount() {\n\t\treturn this.beanDefinitionMap.size();\n\t}\n\n\t@Override\n\tpublic String[] getBeanDefinitionNames() {\n\t\tString[] frozenNames = this.frozenBeanDefinitionNames;\n\t\tif (frozenNames != null) {\n\t\t\treturn frozenNames.clone();\n\t\t}\n\t\telse {\n\t\t\treturn StringUtils.toStringArray(this.beanDefinitionNames);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType, boolean allowEagerInit) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\treturn getBeanProvider(ResolvableType.forRawClass(requiredType), allowEagerInit);\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn new BeanObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, null, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, args, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, false);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifAvailable(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfAvailable();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, true);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifUnique(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfUnique();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForTypedStream(requiredType, allowEagerInit))\n\t\t\t\t\t\t.map(name -> (T) getBean(name))\n\t\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\tString[] beanNames = getBeanNamesForTypedStream(requiredType, allowEagerInit);\n\t\t\t\tif (beanNames.length == 0) {\n\t\t\t\t\treturn Stream.empty();\n\t\t\t\t}\n\t\t\t\tMap<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\t\tfor (String beanName : beanNames) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, (T) beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStream<T> stream = matchingBeans.values().stream();\n\t\t\t\treturn stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Nullable\n\tprivate <T> T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {\n\t\tNamedBeanHolder<T> namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);\n\t\tif (namedBean != null) {\n\t\t\treturn namedBean.getBeanInstance();\n\t\t}\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory dlbf) {\n\t\t\treturn dlbf.resolveBean(requiredType, args, nonUniqueAsNull);\n\t\t}\n\t\telse if (parent != null) {\n\t\t\tObjectProvider<T> parentProvider = parent.getBeanProvider(requiredType);\n\t\t\tif (args != null) {\n\t\t\t\treturn parentProvider.getObject(args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate String[] getBeanNamesForTypedStream(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this, requiredType, true, allowEagerInit);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(ResolvableType type) {\n\t\treturn getBeanNamesForType(type, true, true);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tClass<?> resolved = type.resolve();\n\t\tif (resolved != null && !type.hasGenerics()) {\n\t\t\treturn getBeanNamesForType(resolved, includeNonSingletons, allowEagerInit);\n\t\t}\n\t\telse {\n\t\t\treturn doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable Class<?> type) {\n\t\treturn getBeanNamesForType(type, true, true);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tif (!isConfigurationFrozen() || type == null || !allowEagerInit) {\n\t\t\treturn doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);\n\t\t}\n\t\tMap<Class<?>, String[]> cache =\n\t\t\t\t(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);\n\t\tString[] resolvedBeanNames = cache.get(type);\n\t\tif (resolvedBeanNames != null) {\n\t\t\treturn resolvedBeanNames;\n\t\t}\n\t\tresolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);\n\t\tif (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {\n\t\t\tcache.put(type, resolvedBeanNames);\n\t\t}\n\t\treturn resolvedBeanNames;\n\t}\n\n\tprivate String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tList<String> result = new ArrayList<>();\n\n\t\t// Check all bean definitions.\n\t\tfor (String beanName : this.beanDefinitionNames) {\n\t\t\t// Only consider bean as eligible if the bean name is not defined as alias for some other bean.\n\t\t\tif (!isAlias(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\t\t// Only check bean definition if it is complete.\n\t\t\t\t\tif (!mbd.isAbstract() && (allowEagerInit ||\n\t\t\t\t\t\t\t(mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &&\n\t\t\t\t\t\t\t\t\t!requiresEagerInitForType(mbd.getFactoryBeanName()))) {\n\t\t\t\t\t\tboolean isFactoryBean = isFactoryBean(beanName, mbd);\n\t\t\t\t\t\tBeanDefinitionHolder dbd = mbd.getDecoratedDefinition();\n\t\t\t\t\t\tboolean matchFound = false;\n\t\t\t\t\t\tboolean allowFactoryBeanInit = (allowEagerInit || containsSingleton(beanName));\n\t\t\t\t\t\tboolean isNonLazyDecorated = (dbd != null && !mbd.isLazyInit());\n\t\t\t\t\t\tif (!isFactoryBean) {\n\t\t\t\t\t\t\tif (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {\n\t\t\t\t\t\t\t\tmatchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (includeNonSingletons || isNonLazyDecorated ||\n\t\t\t\t\t\t\t\t\t(allowFactoryBeanInit && isSingleton(beanName, mbd, dbd))) {\n\t\t\t\t\t\t\t\tmatchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!matchFound) {\n\t\t\t\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean instance itself next.\n\t\t\t\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n\t\t\t\t\t\t\t\tif (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {\n\t\t\t\t\t\t\t\t\tmatchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (matchFound) {\n\t\t\t\t\t\t\tresult.add(beanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (CannotLoadBeanClassException | BeanDefinitionStoreException ex) {\n\t\t\t\t\tif (allowEagerInit) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\t// Probably a placeholder: let's ignore it for type matching purposes.\n\t\t\t\t\tLogMessage message = (ex instanceof CannotLoadBeanClassException ?\n\t\t\t\t\t\t\tLogMessage.format(\"Ignoring bean class loading failure for bean '%s'\", beanName) :\n\t\t\t\t\t\t\tLogMessage.format(\"Ignoring unresolvable metadata in bean definition '%s'\", beanName));\n\t\t\t\t\tlogger.trace(message, ex);\n\t\t\t\t\t// Register exception, in case the bean was accidentally unresolvable.\n\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t// Bean definition got removed while we were iterating -> ignore.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check manually registered singletons too.\n\t\tfor (String beanName : this.manualSingletonNames) {\n\t\t\ttry {\n\t\t\t\t// In case of FactoryBean, match object created by FactoryBean.\n\t\t\t\tif (isFactoryBean(beanName)) {\n\t\t\t\t\tif ((includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type)) {\n\t\t\t\t\t\tresult.add(beanName);\n\t\t\t\t\t\t// Match found for this bean: do not match FactoryBean itself anymore.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean itself next.\n\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n\t\t\t\t}\n\t\t\t\t// Match raw bean instance (might be raw FactoryBean).\n\t\t\t\tif (isTypeMatch(beanName, type)) {\n\t\t\t\t\tresult.add(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Shouldn't happen - probably a result of circular reference resolution...\n\t\t\t\tlogger.trace(LogMessage.format(\n\t\t\t\t\t\t\"Failed to check manually registered singleton with name '%s'\", beanName), ex);\n\t\t\t}\n\t\t}\n\n\t\treturn StringUtils.toStringArray(result);\n\t}\n\n\tprivate boolean isSingleton(String beanName, RootBeanDefinition mbd, @Nullable BeanDefinitionHolder dbd) {\n\t\treturn (dbd != null ? mbd.isSingleton() : isSingleton(beanName));\n\t}\n\n\t/**\n\t * Check whether the specified bean would need to be eagerly initialized\n\t * in order to determine its type.\n\t * @param factoryBeanName a factory-bean reference that the bean definition\n\t * defines a factory method for\n\t * @return whether eager initialization is necessary\n\t */\n\tprivate boolean requiresEagerInitForType(@Nullable String factoryBeanName) {\n\t\treturn (factoryBeanName != null && isFactoryBean(factoryBeanName) && !containsSingleton(factoryBeanName));\n\t}\n\n\t@Override\n\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {\n\t\treturn getBeansOfType(type, true, true);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> Map<String, T> getBeansOfType(\n\t\t\t@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {\n\n\t\tString[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tMap<String, T> result = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\tfor (String beanName : beanNames) {\n\t\t\ttry {\n\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\tresult.put(beanName, (T) beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\tString exBeanName = bce.getBeanName();\n\t\t\t\t\tif (exBeanName != null && isCurrentlyInCreation(exBeanName)) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignoring match to currently created bean '\" + exBeanName + \"': \" +\n\t\t\t\t\t\t\t\t\tex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t\t\t// Ignore: indicates a circular reference when autowiring constructors.\n\t\t\t\t\t\t// We want to find matches other than the currently created bean itself.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {\n\t\tList<String> result = new ArrayList<>();\n\t\tfor (String beanName : this.beanDefinitionNames) {\n\t\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n\t\t\tif (bd != null && !bd.isAbstract() && findAnnotationOnBean(beanName, annotationType) != null) {\n\t\t\t\tresult.add(beanName);\n\t\t\t}\n\t\t}\n\t\tfor (String beanName : this.manualSingletonNames) {\n\t\t\tif (!result.contains(beanName) && findAnnotationOnBean(beanName, annotationType) != null) {\n\t\t\t\tresult.add(beanName);\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(result);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) {\n\t\tString[] beanNames = getBeanNamesForAnnotation(annotationType);\n\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\tfor (String beanName : beanNames) {\n\t\t\tObject beanInstance = getBean(beanName);\n\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn findAnnotationOnBean(beanName, annotationType, true);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\tMergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\tif (annotation.isPresent()) {\n\t\t\t\treturn annotation.synthesize();\n\t\t\t}\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, for example, in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\t\tMergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\tMergedAnnotations.from(factoryMethod, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tSet<A> annotations = new LinkedHashSet<>();\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotations.from(beanType, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, for example, in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotations.from(beanClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotations.from(factoryMethod, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t}\n\t\t}\n\t\treturn annotations;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ConfigurableListableBeanFactory interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {\n\t\tAssert.notNull(dependencyType, \"Dependency type must not be null\");\n\t\tif (autowiredValue != null) {\n\t\t\tif (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {\n\t\t\t\tthrow new IllegalArgumentException(\"Value [\" + autowiredValue +\n\t\t\t\t\t\t\"] does not implement specified dependency type [\" + dependencyType.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());\n\t}\n\n\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */\n\tprotected boolean isAutowireCandidate(\n\t\t\tString beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(bdName)) {\n\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);\n\t\t}\n\t\telse if (containsSingleton(beanName)) {\n\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);\n\t\t}\n\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory dlbf) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn dlbf.isAutowireCandidate(beanName, descriptor, resolver);\n\t\t}\n\t\telse if (parent instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\t// If no DefaultListableBeanFactory, can't pass the resolver along.\n\t\t\treturn clbf.isAutowireCandidate(beanName, descriptor);\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param mbd the merged bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */\n\tprotected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver) {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tresolveBeanClass(mbd, bdName);\n\t\tif (mbd.isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {\n\t\t\tnew ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);\n\t\t}\n\t\tBeanDefinitionHolder holder = (beanName.equals(bdName) ?\n\t\t\t\tthis.mergedBeanDefinitionHolders.computeIfAbsent(beanName,\n\t\t\t\t\t\tkey -> new BeanDefinitionHolder(mbd, beanName, getAliases(bdName))) :\n\t\t\t\tnew BeanDefinitionHolder(mbd, beanName, getAliases(bdName)));\n\t\treturn resolver.isAutowireCandidate(holder, descriptor);\n\t}\n\n\t@Override\n\tpublic BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n\t\tif (bd == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n\t\t\t}\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n\t\t}\n\t\treturn bd;\n\t}\n\n\t@Override\n\tpublic Iterator<String> getBeanNamesIterator() {\n\t\tCompositeIterator<String> iterator = new CompositeIterator<>();\n\t\titerator.add(this.beanDefinitionNames.iterator());\n\t\titerator.add(this.manualSingletonNames.iterator());\n\t\treturn iterator;\n\t}\n\n\t@Override\n\tprotected void clearMergedBeanDefinition(String beanName) {\n\t\tsuper.clearMergedBeanDefinition(beanName);\n\t\tthis.mergedBeanDefinitionHolders.remove(beanName);\n\t}\n\n\t@Override\n\tpublic void clearMetadataCache() {\n\t\tsuper.clearMetadataCache();\n\t\tthis.mergedBeanDefinitionHolders.clear();\n\t\tclearByTypeCache();\n\t}\n\n\t@Override\n\tpublic void freezeConfiguration() {\n\t\tclearMetadataCache();\n\t\tthis.configurationFrozen = true;\n\t\tthis.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);\n\t}\n\n\t@Override\n\tpublic boolean isConfigurationFrozen() {\n\t\treturn this.configurationFrozen;\n\t}\n\n\t/**\n\t * Considers all beans as eligible for metadata caching\n\t * if the factory's configuration has been marked as frozen.\n\t * @see #freezeConfiguration()\n\t */\n\t@Override\n\tprotected boolean isBeanEligibleForMetadataCaching(String beanName) {\n\t\treturn (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)\n\t\t\tthrows Exception {\n\n\t\tif (supplier instanceof InstanceSupplier<?> instanceSupplier) {\n\t\t\treturn instanceSupplier.get(RegisteredBean.of(this, beanName, mbd));\n\t\t}\n\t\treturn super.obtainInstanceFromSupplier(supplier, beanName, mbd);\n\t}\n\n\t@Override\n\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {\n\t\tsuper.checkMergedBeanDefinition(mbd, beanName, args);\n\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for background \" +\n\t\t\t\t\t\t\"initialization but requested in mainline thread - declare ObjectProvider \" +\n\t\t\t\t\t\t\"or lazy injection point in dependent mainline beans\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Bean intended to be initialized in main bootstrap thread\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for mainline initialization \" +\n\t\t\t\t\t\t\"but requested in background thread - enforce early instantiation in mainline thread \" +\n\t\t\t\t\t\t\"through depends-on '\" + beanName + \"' declaration for dependent background beans\");\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Boolean isCurrentThreadAllowedToHoldSingletonLock() {\n\t\treturn (this.preInstantiationPhase ? this.preInstantiationThread.get() != PreInstantiation.BACKGROUND : null);\n\t}\n\n\t@Override\n\tpublic void preInstantiateSingletons() throws BeansException {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Pre-instantiating singletons in \" + this);\n\t\t}\n\n\t\t// Iterate over a copy to allow for init methods which in turn register new bean definitions.\n\t\t// While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n\t\tList<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n\t\t// Trigger initialization of all non-lazy singleton beans...\n\t\tList<CompletableFuture<?>> futures = new ArrayList<>();\n\n\t\tthis.preInstantiationPhase = true;\n\t\tthis.preInstantiationThread.set(PreInstantiation.MAIN);\n\t\ttry {\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tif (!mbd.isAbstract() && mbd.isSingleton()) {\n\t\t\t\t\tCompletableFuture<?> future = preInstantiateSingleton(beanName, mbd);\n\t\t\t\t\tif (future != null) {\n\t\t\t\t\t\tfutures.add(future);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tthis.preInstantiationThread.remove();\n\t\t\tthis.preInstantiationPhase = false;\n\t\t}\n\n\t\tif (!futures.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tCompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0])).join();\n\t\t\t}\n\t\t\tcatch (CompletionException ex) {\n\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());\n\t\t\t}\n\t\t}\n\n\t\t// Trigger post-initialization callback for all applicable beans...\n\t\tfor (String beanName : beanNames) {\n\t\t\tObject singletonInstance = getSingleton(beanName, false);\n\t\t\tif (singletonInstance instanceof SmartInitializingSingleton smartSingleton) {\n\t\t\t\tStartupStep smartInitialize = getApplicationStartup().start(\"spring.beans.smart-initialize\")\n\t\t\t\t\t\t.tag(\"beanName\", beanName);\n\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\tsmartInitialize.end();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate CompletableFuture<?> preInstantiateSingleton(String beanName, RootBeanDefinition mbd) {\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tExecutor executor = getBootstrapExecutor();\n\t\t\tif (executor != null) {\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCompletableFuture<?> future = CompletableFuture.runAsync(\n\t\t\t\t\t\t() -> instantiateSingletonInBackgroundThread(beanName), executor);\n\t\t\t\taddSingletonFactory(beanName, () -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfuture.join();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (CompletionException ex) {\n\t\t\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());\n\t\t\t\t\t}\n\t\t\t\t\treturn future;  // not to be exposed, just to lead to ClassCastException in case of mismatch\n\t\t\t\t});\n\t\t\t\treturn (!mbd.isLazyInit() ? future : null);\n\t\t\t}\n\t\t\telse if (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Bean '\" + beanName + \"' marked for background initialization \" +\n\t\t\t\t\t\t\"without bootstrap executor configured - falling back to mainline initialization\");\n\t\t\t}\n\t\t}\n\t\tif (!mbd.isLazyInit()) {\n\t\t\tinstantiateSingleton(beanName);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void instantiateSingletonInBackgroundThread(String beanName) {\n\t\tthis.preInstantiationThread.set(PreInstantiation.BACKGROUND);\n\t\ttry {\n\t\t\tinstantiateSingleton(beanName);\n\t\t}\n\t\tcatch (RuntimeException | Error ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to instantiate singleton bean '\" + beanName + \"' in background thread\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tthis.preInstantiationThread.remove();\n\t\t}\n\t}\n\n\tprivate void instantiateSingleton(String beanName) {\n\t\tif (isFactoryBean(beanName)) {\n\t\t\tObject bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\tif (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) {\n\t\t\t\tgetBean(beanName);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tgetBean(beanName);\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of BeanDefinitionRegistry interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n\t\tif (beanDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\ttry {\n\t\t\t\tabd.validate();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n\t\tif (existingDefinition != null) {\n\t\t\tif (!isBeanDefinitionOverridable(beanName)) {\n\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogBeanDefinitionOverriding(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tif (isAlias(beanName)) {\n\t\t\t\tString aliasedName = canonicalName(beanName);\n\t\t\t\tif (!isBeanDefinitionOverridable(aliasedName)) {\n\t\t\t\t\tif (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionOverrideException(\n\t\t\t\t\t\t\t\tbeanName, beanDefinition, getBeanDefinition(aliasedName));\n\t\t\t\t\t}\n\t\t\t\t\telse {  // alias pointing to non-existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Cannot register bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\t\"' since there is already an alias for bean '\" + aliasedName + \"' bound.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tremoveAlias(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasBeanCreationStarted()) {\n\t\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n\t\t\t\t\tupdatedDefinitions.addAll(this.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Still in startup registration phase\n\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\tthis.beanDefinitionNames.add(beanName);\n\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t}\n\t\t\tthis.frozenBeanDefinitionNames = null;\n\t\t}\n\n\t\tif (existingDefinition != null || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t\telse if (isConfigurationFrozen()) {\n\t\t\tclearByTypeCache();\n\t\t}\n\n\t\t// Cache a primary marker for the given bean.\n\t\tif (beanDefinition.isPrimary()) {\n\t\t\tthis.primaryBeanNames.add(beanName);\n\t\t}\n\t}\n\n\tprivate void logBeanDefinitionOverriding(String beanName, BeanDefinition beanDefinition,\n\t\t\tBeanDefinition existingDefinition) {\n\n\t\tboolean explicitBeanOverride = (this.allowBeanDefinitionOverriding != null);\n\t\tif (existingDefinition.getRole() < beanDefinition.getRole()) {\n\t\t\t// for example, was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Overriding user-defined bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with a framework-generated bean definition: replacing [\" +\n\t\t\t\t\t\texistingDefinition + \"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t}\n\t\telse if (!beanDefinition.equals(existingDefinition)) {\n\t\t\tif (explicitBeanOverride && logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with a different definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with a different definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (explicitBeanOverride && logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tAssert.hasText(beanName, \"'beanName' must not be empty\");\n\n\t\tBeanDefinition bd = this.beanDefinitionMap.remove(beanName);\n\t\tif (bd == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n\t\t\t}\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n\t\t}\n\n\t\tif (hasBeanCreationStarted()) {\n\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames);\n\t\t\t\tupdatedDefinitions.remove(beanName);\n\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Still in startup registration phase\n\t\t\tthis.beanDefinitionNames.remove(beanName);\n\t\t}\n\t\tthis.frozenBeanDefinitionNames = null;\n\n\t\tresetBeanDefinition(beanName);\n\t}\n\n\t/**\n\t * Reset all bean definition caches for the given bean,\n\t * including the caches of beans that are derived from it.\n\t * <p>Called after an existing bean definition has been replaced or removed,\n\t * triggering {@link #clearMergedBeanDefinition}, {@link #destroySingleton}\n\t * and {@link MergedBeanDefinitionPostProcessor#resetBeanDefinition} on the\n\t * given bean and on all bean definitions that have the given bean as parent.\n\t * @param beanName the name of the bean to reset\n\t * @see #registerBeanDefinition\n\t * @see #removeBeanDefinition\n\t */\n\tprotected void resetBeanDefinition(String beanName) {\n\t\t// Remove the merged bean definition for the given bean, if already created.\n\t\tclearMergedBeanDefinition(beanName);\n\n\t\t// Remove corresponding bean from singleton cache, if any. Shouldn't usually\n\t\t// be necessary, rather just meant for overriding a context's default beans\n\t\t// (for example, the default StaticMessageSource in a StaticApplicationContext).\n\t\tdestroySingleton(beanName);\n\n\t\t// Remove a cached primary marker for the given bean.\n\t\tthis.primaryBeanNames.remove(beanName);\n\n\t\t// Notify all post-processors that the specified bean definition has been reset.\n\t\tfor (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {\n\t\t\tprocessor.resetBeanDefinition(beanName);\n\t\t}\n\n\t\t// Reset all bean definitions that have the given bean as parent (recursively).\n\t\tfor (String bdName : this.beanDefinitionNames) {\n\t\t\tif (!beanName.equals(bdName)) {\n\t\t\t\tBeanDefinition bd = this.beanDefinitionMap.get(bdName);\n\t\t\t\t// Ensure bd is non-null due to potential concurrent modification of beanDefinitionMap.\n\t\t\t\tif (bd != null && beanName.equals(bd.getParentName())) {\n\t\t\t\t\tresetBeanDefinition(bdName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This implementation returns {@code true} if bean definition overriding\n\t * is generally allowed.\n\t * @see #setAllowBeanDefinitionOverriding\n\t */\n\t@Override\n\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn isAllowBeanDefinitionOverriding();\n\t}\n\n\t/**\n\t * Only allows alias overriding if bean definition overriding is allowed.\n\t * @see #setAllowBeanDefinitionOverriding\n\t */\n\t@Override\n\tprotected boolean allowAliasOverriding() {\n\t\treturn isAllowBeanDefinitionOverriding();\n\t}\n\n\t/**\n\t * Also checks for an alias overriding a bean definition of the same name.\n\t */\n\t@Override\n\tprotected void checkForAliasCircle(String name, String alias) {\n\t\tsuper.checkForAliasCircle(name, alias);\n\t\tif (!isBeanDefinitionOverridable(alias) && containsBeanDefinition(alias)) {\n\t\t\tthrow new IllegalStateException(\"Cannot register alias '\" + alias +\n\t\t\t\t\t\"' for name '\" + name + \"': Alias would override bean definition '\" + alias + \"'\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {\n\t\tsuper.registerSingleton(beanName, singletonObject);\n\t\tupdateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));\n\t\tclearByTypeCache();\n\t}\n\n\t@Override\n\tpublic void destroySingletons() {\n\t\tsuper.destroySingletons();\n\t\tupdateManualSingletonNames(Set::clear, set -> !set.isEmpty());\n\t\tclearByTypeCache();\n\t}\n\n\t@Override\n\tpublic void destroySingleton(String beanName) {\n\t\tsuper.destroySingleton(beanName);\n\t\tremoveManualSingletonName(beanName);\n\t\tclearByTypeCache();\n\t}\n\n\tprivate void removeManualSingletonName(String beanName) {\n\t\tupdateManualSingletonNames(set -> set.remove(beanName), set -> set.contains(beanName));\n\t}\n\n\t/**\n\t * Update the factory's internal set of manual singleton names.\n\t * @param action the modification action\n\t * @param condition a precondition for the modification action\n\t * (if this condition does not apply, the action can be skipped)\n\t */\n\tprivate void updateManualSingletonNames(Consumer<Set<String>> action, Predicate<Set<String>> condition) {\n\t\tif (hasBeanCreationStarted()) {\n\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\tif (condition.test(this.manualSingletonNames)) {\n\t\t\t\t\tSet<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);\n\t\t\t\t\taction.accept(updatedSingletons);\n\t\t\t\t\tthis.manualSingletonNames = updatedSingletons;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Still in startup registration phase\n\t\t\tif (condition.test(this.manualSingletonNames)) {\n\t\t\t\taction.accept(this.manualSingletonNames);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove any assumptions about by-type mappings.\n\t */\n\tprivate void clearByTypeCache() {\n\t\tthis.allBeanNamesByType.clear();\n\t\tthis.singletonBeanNamesByType.clear();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Dependency resolution functionality\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic <T> NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType) throws BeansException {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tNamedBeanHolder<T> namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), null, false);\n\t\tif (namedBean != null) {\n\t\t\treturn namedBean;\n\t\t}\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof AutowireCapableBeanFactory acbf) {\n\t\t\treturn acbf.resolveNamedBean(requiredType);\n\t\t}\n\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate <T> NamedBeanHolder<T> resolveNamedBean(\n\t\t\tResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {\n\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tString[] candidateNames = getBeanNamesForType(requiredType);\n\n\t\tif (candidateNames.length > 1) {\n\t\t\tList<String> autowireCandidates = new ArrayList<>(candidateNames.length);\n\t\t\tfor (String beanName : candidateNames) {\n\t\t\t\tif (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {\n\t\t\t\t\tautowireCandidates.add(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!autowireCandidates.isEmpty()) {\n\t\t\t\tcandidateNames = StringUtils.toStringArray(autowireCandidates);\n\t\t\t}\n\t\t}\n\n\t\tif (candidateNames.length == 1) {\n\t\t\treturn resolveNamedBean(candidateNames[0], requiredType, args);\n\t\t}\n\t\telse if (candidateNames.length > 1) {\n\t\t\tMap<String, Object> candidates = CollectionUtils.newLinkedHashMap(candidateNames.length);\n\t\t\tfor (String beanName : candidateNames) {\n\t\t\t\tif (containsSingleton(beanName) && args == null) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tcandidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcandidates.put(beanName, getType(beanName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tString candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());\n\t\t\tif (candidateName == null) {\n\t\t\t\tcandidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());\n\t\t\t}\n\t\t\tif (candidateName != null) {\n\t\t\t\tObject beanInstance = candidates.get(candidateName);\n\t\t\t\tif (beanInstance == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (beanInstance instanceof Class) {\n\t\t\t\t\treturn resolveNamedBean(candidateName, requiredType, args);\n\t\t\t\t}\n\t\t\t\treturn new NamedBeanHolder<>(candidateName, (T) beanInstance);\n\t\t\t}\n\t\t\tif (!nonUniqueAsNull) {\n\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate <T> NamedBeanHolder<T> resolveNamedBean(\n\t\t\tString beanName, ResolvableType requiredType, @Nullable Object[] args) throws BeansException {\n\n\t\tObject bean = getBean(beanName, null, args);\n\t\tif (bean instanceof NullBean) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new NamedBeanHolder<>(beanName, adaptBeanInstance(beanName, bean, requiredType.toClass()));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\t\tif (Optional.class == descriptor.getDependencyType()) {\n\t\t\treturn createOptionalDependency(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (ObjectFactory.class == descriptor.getDependencyType() ||\n\t\t\t\tObjectProvider.class == descriptor.getDependencyType()) {\n\t\t\treturn new DependencyObjectProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (jakartaInjectProviderClass == descriptor.getDependencyType()) {\n\t\t\treturn new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (descriptor.supportsLazyResolution()) {\n\t\t\tObject result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(\n\t\t\t\t\tdescriptor, requestingBeanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);\n\t}\n\n\t@Nullable\n\t@SuppressWarnings(\"NullAway\")\n\tpublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\t// Step 1: pre-resolved shortcut for single bean match, for example, from @Autowired\n\t\t\tObject shortcut = descriptor.resolveShortcut(this);\n\t\t\tif (shortcut != null) {\n\t\t\t\treturn shortcut;\n\t\t\t}\n\n\t\t\tClass<?> type = descriptor.getDependencyType();\n\n\t\t\t// Step 2: pre-defined value or expression, for example, from @Value\n\t\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof String strValue) {\n\t\t\t\t\tString resolvedValue = resolveEmbeddedValue(strValue);\n\t\t\t\t\tBeanDefinition bd = (beanName != null && containsBean(beanName) ?\n\t\t\t\t\t\t\tgetMergedBeanDefinition(beanName) : null);\n\t\t\t\t\tvalue = evaluateBeanDefinitionString(resolvedValue, bd);\n\t\t\t\t}\n\t\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\t\ttry {\n\t\t\t\t\treturn converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t\t// A custom TypeConverter which does not support TypeDescriptor resolution...\n\t\t\t\t\treturn (descriptor.getField() != null ?\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getField()) :\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getMethodParameter()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Step 3: shortcut for declared dependency name or qualifier-suggested name matching target bean name\n\t\t\tif (descriptor.usesStandardBeanLookup()) {\n\t\t\t\tString dependencyName = descriptor.getDependencyName();\n\t\t\t\tif (dependencyName == null || !containsBean(dependencyName)) {\n\t\t\t\t\tString suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);\n\t\t\t\t\tdependencyName = (suggestedName != null && containsBean(suggestedName) ? suggestedName : null);\n\t\t\t\t}\n\t\t\t\tif (dependencyName != null) {\n\t\t\t\t\tdependencyName = canonicalName(dependencyName);  // dependency name can be alias of target name\n\t\t\t\t\tif (isTypeMatch(dependencyName, type) && isAutowireCandidate(dependencyName, descriptor) &&\n\t\t\t\t\t\t\t!isFallback(dependencyName) && !hasPrimaryConflict(dependencyName, type) &&\n\t\t\t\t\t\t\t!isSelfReference(beanName, dependencyName)) {\n\t\t\t\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\t\t\t\tautowiredBeanNames.add(dependencyName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObject dependencyBean = getBean(dependencyName);\n\t\t\t\t\t\treturn resolveInstance(dependencyBean, descriptor, type, dependencyName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Step 4a: multiple beans as stream / array / standard collection / plain map\n\t\t\tObject multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\tif (multipleBeans != null) {\n\t\t\t\treturn multipleBeans;\n\t\t\t}\n\t\t\t// Step 4b: direct bean matches, possibly direct beans of type Collection / Map\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\t// Step 4c (fallback): custom Collection / Map declarations for collecting multiple beans\n\t\t\t\tmultipleBeans = resolveMultipleBeansFallback(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\t\tif (multipleBeans != null) {\n\t\t\t\t\treturn multipleBeans;\n\t\t\t\t}\n\t\t\t\t// Raise exception if nothing found for required injection point\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tString autowiredBeanName;\n\t\t\tObject instanceCandidate;\n\n\t\t\t// Step 5: determine single candidate\n\t\t\tif (matchingBeans.size() > 1) {\n\t\t\t\tautowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);\n\t\t\t\tif (autowiredBeanName == null) {\n\t\t\t\t\tif (isRequired(descriptor) || !indicatesArrayCollectionOrMap(type)) {\n\t\t\t\t\t\t// Raise exception if no clear match found for required injection point\n\t\t\t\t\t\treturn descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// In case of an optional Collection/Map, silently ignore a non-unique case:\n\t\t\t\t\t\t// possibly it was meant to be an empty collection of multiple regular beans\n\t\t\t\t\t\t// (before 4.3 in particular when we didn't even look for collection beans).\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinstanceCandidate = matchingBeans.get(autowiredBeanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have exactly one match.\n\t\t\t\tMap.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n\t\t\t\tautowiredBeanName = entry.getKey();\n\t\t\t\tinstanceCandidate = entry.getValue();\n\t\t\t}\n\n\t\t\t// Step 6: validate single result\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.add(autowiredBeanName);\n\t\t\t}\n\t\t\tif (instanceCandidate instanceof Class) {\n\t\t\t\tinstanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);\n\t\t\t}\n\t\t\treturn resolveInstance(instanceCandidate, descriptor, type, autowiredBeanName);\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object resolveInstance(Object candidate, DependencyDescriptor descriptor, Class<?> type, String name) {\n\t\tObject result = candidate;\n\t\tif (result instanceof NullBean) {\n\t\t\t// Raise exception if null encountered for required injection point\n\t\t\tif (isRequired(descriptor)) {\n\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t}\n\t\t\tresult = null;\n\t\t}\n\t\tif (!ClassUtils.isAssignableValue(type, result)) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, type, candidate.getClass());\n\t\t}\n\t\treturn result;\n\n\t}\n\n\t@Nullable\n\tprivate Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tClass<?> type = descriptor.getDependencyType();\n\n\t\tif (descriptor instanceof StreamDependencyDescriptor streamDependencyDescriptor) {\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\tStream<Object> stream = matchingBeans.keySet().stream()\n\t\t\t\t\t.map(name -> descriptor.resolveCandidate(name, type, this))\n\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t\tif (streamDependencyDescriptor.isOrdered()) {\n\t\t\t\tstream = stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t\treturn stream;\n\t\t}\n\t\telse if (type.isArray()) {\n\t\t\tClass<?> componentType = type.componentType();\n\t\t\tResolvableType resolvableType = descriptor.getResolvableType();\n\t\t\tClass<?> resolvedArrayType = resolvableType.resolve(type);\n\t\t\tif (resolvedArrayType != type) {\n\t\t\t\tcomponentType = resolvableType.getComponentType().resolve();\n\t\t\t}\n\t\t\tif (componentType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType,\n\t\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\tObject result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);\n\t\t\tif (result instanceof Object[] array && array.length > 1) {\n\t\t\t\tComparator<Object> comparator = adaptDependencyComparator(matchingBeans);\n\t\t\t\tif (comparator != null) {\n\t\t\t\t\tArrays.sort(array, comparator);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse if (Collection.class == type || Set.class == type || List.class == type) {\n\t\t\treturn resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\telse if (Map.class == type) {\n\t\t\treturn resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Nullable\n\tprivate Object resolveMultipleBeansFallback(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tClass<?> type = descriptor.getDependencyType();\n\n\t\tif (Collection.class.isAssignableFrom(type) && type.isInterface()) {\n\t\t\treturn resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\telse if (Map.class.isAssignableFrom(type) && type.isInterface()) {\n\t\t\treturn resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate Object resolveMultipleBeanCollection(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tClass<?> elementType = descriptor.getResolvableType().asCollection().resolveGeneric();\n\t\tif (elementType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType,\n\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\tif (matchingBeans.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (autowiredBeanNames != null) {\n\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t}\n\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\tObject result = converter.convertIfNecessary(matchingBeans.values(), descriptor.getDependencyType());\n\t\tif (result instanceof List<?> list && list.size() > 1) {\n\t\t\tComparator<Object> comparator = adaptDependencyComparator(matchingBeans);\n\t\t\tif (comparator != null) {\n\t\t\t\tlist.sort(comparator);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Nullable\n\tprivate Object resolveMultipleBeanMap(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tResolvableType mapType = descriptor.getResolvableType().asMap();\n\t\tClass<?> keyType = mapType.resolveGeneric(0);\n\t\tif (String.class != keyType) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> valueType = mapType.resolveGeneric(1);\n\t\tif (valueType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType,\n\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\tif (matchingBeans.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (autowiredBeanNames != null) {\n\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t}\n\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\treturn converter.convertIfNecessary(matchingBeans, descriptor.getDependencyType());\n\t}\n\n\tprivate boolean indicatesArrayCollectionOrMap(Class<?> type) {\n\t\treturn (type.isArray() || (type.isInterface() &&\n\t\t\t\t(Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type))));\n\t}\n\n\tprivate boolean isRequired(DependencyDescriptor descriptor) {\n\t\treturn getAutowireCandidateResolver().isRequired(descriptor);\n\t}\n\n\t@Nullable\n\tprivate Comparator<Object> adaptDependencyComparator(Map<String, ?> matchingBeans) {\n\t\tComparator<Object> comparator = getDependencyComparator();\n\t\tif (comparator instanceof OrderComparator orderComparator) {\n\t\t\treturn orderComparator.withSourceProvider(\n\t\t\t\t\tcreateFactoryAwareOrderSourceProvider(matchingBeans));\n\t\t}\n\t\telse {\n\t\t\treturn comparator;\n\t\t}\n\t}\n\n\tprivate Comparator<Object> adaptOrderComparator(Map<String, ?> matchingBeans) {\n\t\tComparator<Object> dependencyComparator = getDependencyComparator();\n\t\tOrderComparator comparator = (dependencyComparator instanceof OrderComparator orderComparator ?\n\t\t\t\torderComparator : OrderComparator.INSTANCE);\n\t\treturn comparator.withSourceProvider(createFactoryAwareOrderSourceProvider(matchingBeans));\n\t}\n\n\tprivate OrderComparator.OrderSourceProvider createFactoryAwareOrderSourceProvider(Map<String, ?> beans) {\n\t\tIdentityHashMap<Object, String> instancesToBeanNames = new IdentityHashMap<>();\n\t\tbeans.forEach((beanName, instance) -> instancesToBeanNames.put(instance, beanName));\n\t\treturn new FactoryAwareOrderSourceProvider(instancesToBeanNames);\n\t}\n\n\t/**\n\t * Find bean instances that match the required type.\n\t * Called during autowiring for the specified bean.\n\t * @param beanName the name of the bean that is about to be wired\n\t * @param requiredType the actual type of bean to look for\n\t * (may be an array component type or collection element type)\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @return a Map of candidate names and candidate instances that match\n\t * the required type (never {@code null})\n\t * @throws BeansException in case of errors\n\t * @see #autowireByType\n\t * @see #autowireConstructor\n\t */\n\tprotected Map<String, Object> findAutowireCandidates(\n\t\t\t@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {\n\n\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tthis, requiredType, true, descriptor.isEager());\n\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length);\n\t\tfor (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {\n\t\t\tClass<?> autowiringType = classObjectEntry.getKey();\n\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n\t\t\t\tObject autowiringValue = classObjectEntry.getValue();\n\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (String candidate : candidateNames) {\n\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {\n\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t}\n\t\t}\n\t\tif (result.isEmpty()) {\n\t\t\tboolean multiple = indicatesArrayCollectionOrMap(requiredType);\n\t\t\t// Consider fallback matches if the first pass failed to find anything...\n\t\t\tDependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();\n\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&\n\t\t\t\t\t\t(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {\n\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.isEmpty() && !multiple) {\n\t\t\t\t// Consider self references as a final pass...\n\t\t\t\t// but in the case of a dependency collection, not the very same bean itself.\n\t\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\t\tif (isSelfReference(beanName, candidate) &&\n\t\t\t\t\t\t\t(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&\n\t\t\t\t\t\t\tisAutowireCandidate(candidate, fallbackDescriptor)) {\n\t\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Add an entry to the candidate map: a bean instance if available or just the resolved\n\t * type, preventing early bean initialization ahead of primary candidate selection.\n\t */\n\tprivate void addCandidateEntry(Map<String, Object> candidates, String candidateName,\n\t\t\tDependencyDescriptor descriptor, Class<?> requiredType) {\n\n\t\tif (descriptor instanceof MultiElementDescriptor) {\n\t\t\tObject beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);\n\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\tcandidates.put(candidateName, beanInstance);\n\t\t\t}\n\t\t}\n\t\telse if (containsSingleton(candidateName) || (descriptor instanceof StreamDependencyDescriptor streamDescriptor &&\n\t\t\t\tstreamDescriptor.isOrdered())) {\n\t\t\tObject beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);\n\t\t\tcandidates.put(candidateName, (beanInstance instanceof NullBean ? null : beanInstance));\n\t\t}\n\t\telse {\n\t\t\tcandidates.put(candidateName, getType(candidateName));\n\t\t}\n\t}\n\n\t/**\n\t * Determine the autowire candidate in the given set of beans.\n\t * <p>Looks for {@code @Primary} and {@code @Priority} (in that order).\n\t * @param candidates a Map of candidate names and candidate instances\n\t * that match the required type, as returned by {@link #findAutowireCandidates}\n\t * @param descriptor the target dependency to match against\n\t * @return the name of the autowire candidate, or {@code null} if none found\n\t */\n\t@Nullable\n\tprotected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {\n\t\tClass<?> requiredType = descriptor.getDependencyType();\n\t\t// Step 1: check primary candidate\n\t\tString primaryCandidate = determinePrimaryCandidate(candidates, requiredType);\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\t\t// Step 2a: match bean name against declared dependency name\n\t\tString dependencyName = descriptor.getDependencyName();\n\t\tif (dependencyName != null) {\n\t\t\tfor (String beanName : candidates.keySet()) {\n\t\t\t\tif (matchesBeanName(beanName, dependencyName)) {\n\t\t\t\t\treturn beanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Step 2b: match bean name against qualifier-suggested name\n\t\tString suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);\n\t\tif (suggestedName != null) {\n\t\t\tfor (String beanName : candidates.keySet()) {\n\t\t\t\tif (matchesBeanName(beanName, suggestedName)) {\n\t\t\t\t\treturn beanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Step 3: check highest priority candidate\n\t\tString priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);\n\t\tif (priorityCandidate != null) {\n\t\t\treturn priorityCandidate;\n\t\t}\n\t\t// Step 4: pick directly registered dependency\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) {\n\t\t\t\treturn candidateName;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of beans.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see #isPrimary(String, Object)\n\t */\n\t@Nullable\n\tprotected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (isPrimary(candidateBeanName, beanInstance)) {\n\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\tboolean candidateLocal = containsBeanDefinition(candidateBeanName);\n\t\t\t\t\tboolean primaryLocal = containsBeanDefinition(primaryBeanName);\n\t\t\t\t\tif (candidateLocal == primaryLocal) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidates.keySet());\n\t\t\t\t\t}\n\t\t\t\t\telse if (candidateLocal) {\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidates.keySet()) {\n\t\t\t\tif (!isFallback(candidateBeanName)) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Determine the candidate with the highest priority in the given set of beans.\n\t * <p>Based on {@code @jakarta.annotation.Priority}. As defined by the related\n\t * {@link org.springframework.core.Ordered} interface, the lowest value has\n\t * the highest priority.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the candidate with the highest priority,\n\t * or {@code null} if none found\n\t * @throws NoUniqueBeanDefinitionException if multiple beans are detected with\n\t * the same highest priority value\n\t * @see #getPriority(Object)\n\t */\n\t@Nullable\n\tprotected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString highestPriorityBeanName = null;\n\t\tInteger highestPriority = null;\n\t\tboolean highestPriorityConflictDetected = false;\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null) {\n\t\t\t\tInteger candidatePriority = getPriority(beanInstance);\n\t\t\t\tif (candidatePriority != null) {\n\t\t\t\t\tif (highestPriority != null) {\n\t\t\t\t\t\tif (candidatePriority.equals(highestPriority)) {\n\t\t\t\t\t\t\thighestPriorityConflictDetected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (candidatePriority < highestPriority) {\n\t\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t\t\thighestPriorityConflictDetected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (highestPriorityConflictDetected) {\n\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\"Multiple beans found with the same highest priority (\" + highestPriority +\n\t\t\t\t\t\") among candidates: \" + candidates.keySet());\n\n\t\t}\n\t\treturn highestPriorityBeanName;\n\t}\n\n\t/**\n\t * Return whether the bean definition for the given bean name has been\n\t * marked as a primary bean.\n\t * @param beanName the name of the bean\n\t * @param beanInstance the corresponding bean instance (can be {@code null})\n\t * @return whether the given bean qualifies as primary\n\t */\n\tprotected boolean isPrimary(String beanName, Object beanInstance) {\n\t\tString transformedBeanName = transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(transformedBeanName)) {\n\t\t\treturn getMergedLocalBeanDefinition(transformedBeanName).isPrimary();\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.isPrimary(transformedBeanName, beanInstance));\n\t}\n\n\t/**\n\t * Return whether the bean definition for the given bean name has been\n\t * marked as a fallback bean.\n\t * @param beanName the name of the bean\n\t * @since 6.2\n\t */\n\tprivate boolean isFallback(String beanName) {\n\t\tString transformedBeanName = transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(transformedBeanName)) {\n\t\t\treturn getMergedLocalBeanDefinition(transformedBeanName).isFallback();\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.isFallback(transformedBeanName));\n\t}\n\n\t/**\n\t * Return the priority assigned for the given bean instance by\n\t * the {@code jakarta.annotation.Priority} annotation.\n\t * <p>The default implementation delegates to the specified\n\t * {@link #setDependencyComparator dependency comparator}, checking its\n\t * {@link OrderComparator#getPriority method} if it is an extension of\n\t * Spring's common {@link OrderComparator} - typically, an\n\t * {@link org.springframework.core.annotation.AnnotationAwareOrderComparator}.\n\t * If no such comparator is present, this implementation returns {@code null}.\n\t * @param beanInstance the bean instance to check (can be {@code null})\n\t * @return the priority assigned to that bean or {@code null} if none is set\n\t */\n\t@Nullable\n\tprotected Integer getPriority(Object beanInstance) {\n\t\tComparator<Object> comparator = getDependencyComparator();\n\t\tif (comparator instanceof OrderComparator orderComparator) {\n\t\t\treturn orderComparator.getPriority(beanInstance);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine whether the given candidate name matches the bean name or the aliases\n\t * stored in this bean definition.\n\t */\n\tprotected boolean matchesBeanName(String beanName, @Nullable String candidateName) {\n\t\treturn (candidateName != null &&\n\t\t\t\t(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));\n\t}\n\n\t/**\n\t * Determine whether the given beanName/candidateName pair indicates a self reference,\n\t * i.e. whether the candidate points back to the original bean or to a factory method\n\t * on the original bean.\n\t */\n\t@Contract(\"null, _ -> false;_, null -> false;\")\n\tprivate boolean isSelfReference(@Nullable String beanName, @Nullable String candidateName) {\n\t\treturn (beanName != null && candidateName != null &&\n\t\t\t\t(beanName.equals(candidateName) || (containsBeanDefinition(candidateName) &&\n\t\t\t\t\t\tbeanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName()))));\n\t}\n\n\t/**\n\t * Determine whether there is a primary bean registered for the given dependency type,\n\t * not matching the given bean name.\n\t */\n\tprivate boolean hasPrimaryConflict(String beanName, Class<?> dependencyType) {\n\t\tfor (String candidate : this.primaryBeanNames) {\n\t\t\tif (isTypeMatch(candidate, dependencyType) && !candidate.equals(beanName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.hasPrimaryConflict(beanName, dependencyType));\n\t}\n\n\t/**\n\t * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException\n\t * for an unresolvable dependency.\n\t */\n\tprivate void raiseNoMatchingBeanFound(\n\t\t\tClass<?> type, ResolvableType resolvableType, DependencyDescriptor descriptor) throws BeansException {\n\n\t\tcheckBeanNotOfRequiredType(type, descriptor);\n\n\t\tthrow new NoSuchBeanDefinitionException(resolvableType,\n\t\t\t\t\"expected at least 1 bean which qualifies as autowire candidate. \" +\n\t\t\t\t\"Dependency annotations: \" + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));\n\t}\n\n\t/**\n\t * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,\n\t * i.e. if the target type of the bean would match but an exposed proxy doesn't.\n\t */\n\tprivate void checkBeanNotOfRequiredType(Class<?> type, DependencyDescriptor descriptor) {\n\t\tfor (String beanName : this.beanDefinitionNames) {\n\t\t\ttry {\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tClass<?> targetType = mbd.getTargetType();\n\t\t\t\tif (targetType != null && type.isAssignableFrom(targetType) &&\n\t\t\t\t\t\tisAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) {\n\t\t\t\t\t// Probably a proxy interfering with target type match -> throw meaningful exception.\n\t\t\t\t\tObject beanInstance = getSingleton(beanName, false);\n\t\t\t\t\tClass<?> beanType = (beanInstance != null && beanInstance.getClass() != NullBean.class ?\n\t\t\t\t\t\t\tbeanInstance.getClass() : predictBeanType(beanName, mbd));\n\t\t\t\t\tif (beanType != null && !type.isAssignableFrom(beanType)) {\n\t\t\t\t\t\tthrow new BeanNotOfRequiredTypeException(beanName, type, beanType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Bean definition got removed while we were iterating -> ignore.\n\t\t\t}\n\t\t}\n\n\t\tif (getParentBeanFactory() instanceof DefaultListableBeanFactory parent) {\n\t\t\tparent.checkBeanNotOfRequiredType(type, descriptor);\n\t\t}\n\t}\n\n\t/**\n\t * Create an {@link Optional} wrapper for the specified dependency.\n\t */\n\tprivate Optional<?> createOptionalDependency(\n\t\t\tDependencyDescriptor descriptor, @Nullable String beanName, final Object... args) {\n\n\t\tDependencyDescriptor descriptorToUse = new NestedDependencyDescriptor(descriptor) {\n\t\t\t@Override\n\t\t\tpublic boolean isRequired() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {\n\t\t\t\treturn (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :\n\t\t\t\t\t\tsuper.resolveCandidate(beanName, requiredType, beanFactory));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn ObjectUtils.isEmpty(args);\n\t\t\t}\n\t\t};\n\t\tObject result = doResolveDependency(descriptorToUse, beanName, null, null);\n\t\treturn (result instanceof Optional<?> optional ? optional : Optional.ofNullable(result));\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(ObjectUtils.identityToString(this));\n\t\tsb.append(\": defining beans [\");\n\t\tsb.append(StringUtils.collectionToCommaDelimitedString(this.beanDefinitionNames));\n\t\tsb.append(\"]; \");\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent == null) {\n\t\t\tsb.append(\"root of factory hierarchy\");\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"parent: \").append(ObjectUtils.identityToString(parent));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\t@Serial\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\tthrow new NotSerializableException(\"DefaultListableBeanFactory itself is not deserializable - \" +\n\t\t\t\t\"just a SerializedBeanFactoryReference is\");\n\t}\n\n\t@Serial\n\tprotected Object writeReplace() throws ObjectStreamException {\n\t\tif (this.serializationId != null) {\n\t\t\treturn new SerializedBeanFactoryReference(this.serializationId);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotSerializableException(\"DefaultListableBeanFactory has no serialization id\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Minimal id reference to the factory.\n\t * Resolved to the actual factory instance on deserialization.\n\t */\n\tprivate static class SerializedBeanFactoryReference implements Serializable {\n\n\t\tprivate final String id;\n\n\t\tpublic SerializedBeanFactoryReference(String id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tprivate Object readResolve() {\n\t\t\tReference<?> ref = serializableFactories.get(this.id);\n\t\t\tif (ref != null) {\n\t\t\t\tObject result = ref.get();\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Lenient fallback: dummy factory in case of original factory not found...\n\t\t\tDefaultListableBeanFactory dummyFactory = new DefaultListableBeanFactory();\n\t\t\tdummyFactory.serializationId = this.id;\n\t\t\treturn dummyFactory;\n\t\t}\n\t}\n\n\n\t/**\n\t * A dependency descriptor marker for nested elements.\n\t */\n\tprivate static class NestedDependencyDescriptor extends DependencyDescriptor {\n\n\t\tpublic NestedDependencyDescriptor(DependencyDescriptor original) {\n\t\t\tsuper(original);\n\t\t\tincreaseNestingLevel();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\t/**\n\t * A dependency descriptor for a multi-element declaration with nested elements.\n\t */\n\tprivate static class MultiElementDescriptor extends NestedDependencyDescriptor {\n\n\t\tpublic MultiElementDescriptor(DependencyDescriptor original) {\n\t\t\tsuper(original);\n\t\t}\n\t}\n\n\n\t/**\n\t * A dependency descriptor marker for stream access to multiple elements.\n\t */\n\tprivate static class StreamDependencyDescriptor extends DependencyDescriptor {\n\n\t\tprivate final boolean ordered;\n\n\t\tpublic StreamDependencyDescriptor(DependencyDescriptor original, boolean ordered) {\n\t\t\tsuper(original);\n\t\t\tthis.ordered = ordered;\n\t\t}\n\n\t\tpublic boolean isOrdered() {\n\t\t\treturn this.ordered;\n\t\t}\n\t}\n\n\n\tprivate interface BeanObjectProvider<T> extends ObjectProvider<T>, Serializable {\n\t}\n\n\n\t/**\n\t * Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency.\n\t */\n\tprivate class DependencyObjectProvider implements BeanObjectProvider<Object> {\n\n\t\tprivate final DependencyDescriptor descriptor;\n\n\t\tprivate final boolean optional;\n\n\t\t@Nullable\n\t\tprivate final String beanName;\n\n\t\tpublic DependencyObjectProvider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\tthis.descriptor = new NestedDependencyDescriptor(descriptor);\n\t\t\tthis.optional = (this.descriptor.getDependencyType() == Optional.class);\n\t\t\tthis.beanName = beanName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() throws BeansException {\n\t\t\tif (this.optional) {\n\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject result = doResolveDependency(this.descriptor, this.beanName, null, null);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject(final Object... args) throws BeansException {\n\t\t\tif (this.optional) {\n\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName, args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {\n\t\t\t\t\t\treturn beanFactory.getBean(beanName, args);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tObject result = doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getIfAvailable() throws BeansException {\n\t\t\ttry {\n\t\t\t\tif (this.optional) {\n\t\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tDependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean isRequired() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void ifAvailable(Consumer<Object> dependencyConsumer) throws BeansException {\n\t\t\tObject dependency = getIfAvailable();\n\t\t\tif (dependency != null) {\n\t\t\t\ttry {\n\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getIfUnique() throws BeansException {\n\t\t\tDependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isRequired() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\t@Nullable\n\t\t\t\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tif (this.optional) {\n\t\t\t\t\treturn createOptionalDependency(descriptorToUse, this.beanName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void ifUnique(Consumer<Object> dependencyConsumer) throws BeansException {\n\t\t\tObject dependency = getIfUnique();\n\t\t\tif (dependency != null) {\n\t\t\t\ttry {\n\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Nullable\n\t\tprotected Object getValue() throws BeansException {\n\t\t\tif (this.optional) {\n\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn doResolveDependency(this.descriptor, this.beanName, null, null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<Object> stream() {\n\t\t\treturn resolveStream(false);\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<Object> orderedStream() {\n\t\t\treturn resolveStream(true);\n\t\t}\n\n\t\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\t\tprivate Stream<Object> resolveStream(boolean ordered) {\n\t\t\tDependencyDescriptor descriptorToUse = new StreamDependencyDescriptor(this.descriptor, ordered);\n\t\t\tObject result = doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\treturn (result instanceof Stream stream ? stream : Stream.of(result));\n\t\t}\n\t}\n\n\n\t/**\n\t * Separate inner class for avoiding a hard dependency on the {@code jakarta.inject} API.\n\t * Actual {@code jakarta.inject.Provider} implementation is nested here in order to make it\n\t * invisible for Graal's introspection of DefaultListableBeanFactory's nested classes.\n\t */\n\tprivate class Jsr330Factory implements Serializable {\n\n\t\tpublic Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\treturn new Jsr330Provider(descriptor, beanName);\n\t\t}\n\n\t\tprivate class Jsr330Provider extends DependencyObjectProvider implements Provider<Object> {\n\n\t\t\tpublic Jsr330Provider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\t\tsuper(descriptor, beanName);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Object get() throws BeansException {\n\t\t\t\treturn getValue();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * An {@link org.springframework.core.OrderComparator.OrderSourceProvider} implementation\n\t * that is aware of the bean metadata of the instances to sort.\n\t * <p>Lookup for the method factory of an instance to sort, if any, and let the\n\t * comparator retrieve the {@link org.springframework.core.annotation.Order}\n\t * value defined on it.\n\t * <p>As of 6.1.2, this class takes the {@link AbstractBeanDefinition#ORDER_ATTRIBUTE}\n\t * attribute into account.\n\t */\n\tprivate class FactoryAwareOrderSourceProvider implements OrderComparator.OrderSourceProvider {\n\n\t\tprivate final Map<Object, String> instancesToBeanNames;\n\n\t\tpublic FactoryAwareOrderSourceProvider(Map<Object, String> instancesToBeanNames) {\n\t\t\tthis.instancesToBeanNames = instancesToBeanNames;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getOrderSource(Object obj) {\n\t\t\tString beanName = this.instancesToBeanNames.get(obj);\n\t\t\tif (beanName == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tRootBeanDefinition beanDefinition = (RootBeanDefinition) getMergedBeanDefinition(beanName);\n\t\t\t\tList<Object> sources = new ArrayList<>(3);\n\t\t\t\tObject orderAttribute = beanDefinition.getAttribute(AbstractBeanDefinition.ORDER_ATTRIBUTE);\n\t\t\t\tif (orderAttribute != null) {\n\t\t\t\t\tif (orderAttribute instanceof Integer order) {\n\t\t\t\t\t\tsources.add((Ordered) () -> order);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Invalid value type for attribute '\" +\n\t\t\t\t\t\t\t\tAbstractBeanDefinition.ORDER_ATTRIBUTE + \"': \" + orderAttribute.getClass().getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMethod factoryMethod = beanDefinition.getResolvedFactoryMethod();\n\t\t\t\tif (factoryMethod != null) {\n\t\t\t\t\tsources.add(factoryMethod);\n\t\t\t\t}\n\t\t\t\tClass<?> targetType = beanDefinition.getTargetType();\n\t\t\t\tif (targetType != null && targetType != obj.getClass()) {\n\t\t\t\t\tsources.add(targetType);\n\t\t\t\t}\n\t\t\t\treturn sources.toArray();\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate enum PreInstantiation {\n\n\t\tMAIN, BACKGROUND\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.beans.factory.support;\n\nimport java.io.IOException;\nimport java.io.NotSerializableException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamException;\nimport java.io.Serial;\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.ref.Reference;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport jakarta.inject.Provider;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.TypeConverter;\nimport org.springframework.beans.factory.BeanCreationException;\nimport org.springframework.beans.factory.BeanCurrentlyInCreationException;\nimport org.springframework.beans.factory.BeanDefinitionStoreException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.BeanNotOfRequiredTypeException;\nimport org.springframework.beans.factory.CannotLoadBeanClassException;\nimport org.springframework.beans.factory.InjectionPoint;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.ObjectFactory;\nimport org.springframework.beans.factory.ObjectProvider;\nimport org.springframework.beans.factory.SmartFactoryBean;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.config.AutowireCapableBeanFactory;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.config.NamedBeanHolder;\nimport org.springframework.core.NamedThreadLocal;\nimport org.springframework.core.OrderComparator;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.annotation.MergedAnnotation;\nimport org.springframework.core.annotation.MergedAnnotations;\nimport org.springframework.core.annotation.MergedAnnotations.SearchStrategy;\nimport org.springframework.core.log.LogMessage;\nimport org.springframework.core.metrics.StartupStep;\nimport org.springframework.lang.Contract;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.CompositeIterator;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * Spring's default implementation of the {@link ConfigurableListableBeanFactory}\n * and {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory\n * based on bean definition metadata, extensible through post-processors.\n *\n * <p>Typical usage is registering all bean definitions first (possibly read\n * from a bean definition file), before accessing beans. Bean lookup by name\n * is therefore an inexpensive operation in a local bean definition table,\n * operating on pre-resolved bean definition metadata objects.\n *\n * <p>Note that readers for specific bean definition formats are typically\n * implemented separately rather than as bean factory subclasses: see for example\n * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.\n *\n * <p>For an alternative implementation of the\n * {@link org.springframework.beans.factory.ListableBeanFactory} interface,\n * have a look at {@link StaticListableBeanFactory}, which manages existing\n * bean instances rather than creating new ones based on bean definitions.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Costin Leau\n * @author Chris Beams\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @author Sebastien Deleuze\n * @since 16 April 2001\n * @see #registerBeanDefinition\n * @see #addBeanPostProcessor\n * @see #getBean\n * @see #resolveDependency\n */\n@SuppressWarnings(\"serial\")\npublic class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory\n\t\timplements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {\n\n\t@Nullable\n\tprivate static Class<?> jakartaInjectProviderClass;\n\n\tstatic {\n\t\ttry {\n\t\t\tjakartaInjectProviderClass =\n\t\t\t\t\tClassUtils.forName(\"jakarta.inject.Provider\", DefaultListableBeanFactory.class.getClassLoader());\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-330 API not available - Provider interface simply not supported then.\n\t\t\tjakartaInjectProviderClass = null;\n\t\t}\n\t}\n\n\n\t/** Map from serialized id to factory instance. */\n\tprivate static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories =\n\t\t\tnew ConcurrentHashMap<>(8);\n\n\t/** Optional id for this factory, for serialization purposes. */\n\t@Nullable\n\tprivate String serializationId;\n\n\t/** Whether to allow re-registration of a different definition with the same name. */\n\t@Nullable\n\tprivate Boolean allowBeanDefinitionOverriding;\n\n\t/** Whether to allow eager class loading even for lazy-init beans. */\n\tprivate boolean allowEagerClassLoading = true;\n\n\t@Nullable\n\tprivate Executor bootstrapExecutor;\n\n\t/** Optional OrderComparator for dependency Lists and arrays. */\n\t@Nullable\n\tprivate Comparator<Object> dependencyComparator;\n\n\t/** Resolver to use for checking if a bean definition is an autowire candidate. */\n\tprivate AutowireCandidateResolver autowireCandidateResolver = SimpleAutowireCandidateResolver.INSTANCE;\n\n\t/** Map from dependency type to corresponding autowired value. */\n\tprivate final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);\n\n\t/** Map of bean definition objects, keyed by bean name. */\n\tprivate final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);\n\n\t/** Map from bean name to merged BeanDefinitionHolder. */\n\tprivate final Map<String, BeanDefinitionHolder> mergedBeanDefinitionHolders = new ConcurrentHashMap<>(256);\n\n\t// Set of bean definition names with a primary marker. */\n\tprivate final Set<String> primaryBeanNames = ConcurrentHashMap.newKeySet(16);\n\n\t/** Map of singleton and non-singleton bean names, keyed by dependency type. */\n\tprivate final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<>(64);\n\n\t/** Map of singleton-only bean names, keyed by dependency type. */\n\tprivate final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<>(64);\n\n\t/** List of bean definition names, in registration order. */\n\tprivate volatile List<String> beanDefinitionNames = new ArrayList<>(256);\n\n\t/** List of names of manually registered singletons, in registration order. */\n\tprivate volatile Set<String> manualSingletonNames = new LinkedHashSet<>(16);\n\n\t/** Cached array of bean definition names in case of frozen configuration. */\n\t@Nullable\n\tprivate volatile String[] frozenBeanDefinitionNames;\n\n\t/** Whether bean definition metadata may be cached for all beans. */\n\tprivate volatile boolean configurationFrozen;\n\n\tprivate volatile boolean preInstantiationPhase;\n\n\tprivate final NamedThreadLocal<PreInstantiation> preInstantiationThread =\n\t\t\tnew NamedThreadLocal<>(\"Pre-instantiation thread marker\");\n\n\n\t/**\n\t * Create a new DefaultListableBeanFactory.\n\t */\n\tpublic DefaultListableBeanFactory() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Create a new DefaultListableBeanFactory with the given parent.\n\t * @param parentBeanFactory the parent BeanFactory\n\t */\n\tpublic DefaultListableBeanFactory(@Nullable BeanFactory parentBeanFactory) {\n\t\tsuper(parentBeanFactory);\n\t}\n\n\n\t/**\n\t * Specify an id for serialization purposes, allowing this BeanFactory to be\n\t * deserialized from this id back into the BeanFactory object, if needed.\n\t */\n\tpublic void setSerializationId(@Nullable String serializationId) {\n\t\tif (serializationId != null) {\n\t\t\tserializableFactories.put(serializationId, new WeakReference<>(this));\n\t\t}\n\t\telse if (this.serializationId != null) {\n\t\t\tserializableFactories.remove(this.serializationId);\n\t\t}\n\t\tthis.serializationId = serializationId;\n\t}\n\n\t/**\n\t * Return an id for serialization purposes, if specified, allowing this BeanFactory\n\t * to be deserialized from this id back into the BeanFactory object, if needed.\n\t * @since 4.1.2\n\t */\n\t@Nullable\n\tpublic String getSerializationId() {\n\t\treturn this.serializationId;\n\t}\n\n\t/**\n\t * Set whether it should be allowed to override bean definitions by registering\n\t * a different definition with the same name, automatically replacing the former.\n\t * If not, an exception will be thrown. This also applies to overriding aliases.\n\t * <p>Default is \"true\".\n\t * @see #registerBeanDefinition\n\t */\n\tpublic void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {\n\t\tthis.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;\n\t}\n\n\t/**\n\t * Return whether it should be allowed to override bean definitions by registering\n\t * a different definition with the same name, automatically replacing the former.\n\t * @since 4.1.2\n\t */\n\tpublic boolean isAllowBeanDefinitionOverriding() {\n\t\treturn !Boolean.FALSE.equals(this.allowBeanDefinitionOverriding);\n\t}\n\n\t/**\n\t * Set whether the factory is allowed to eagerly load bean classes\n\t * even for bean definitions that are marked as \"lazy-init\".\n\t * <p>Default is \"true\". Turn this flag off to suppress class loading\n\t * for lazy-init beans unless such a bean is explicitly requested.\n\t * In particular, by-type lookups will then simply ignore bean definitions\n\t * without resolved class name, instead of loading the bean classes on\n\t * demand just to perform a type check.\n\t * @see AbstractBeanDefinition#setLazyInit\n\t */\n\tpublic void setAllowEagerClassLoading(boolean allowEagerClassLoading) {\n\t\tthis.allowEagerClassLoading = allowEagerClassLoading;\n\t}\n\n\t/**\n\t * Return whether the factory is allowed to eagerly load bean classes\n\t * even for bean definitions that are marked as \"lazy-init\".\n\t * @since 4.1.2\n\t */\n\tpublic boolean isAllowEagerClassLoading() {\n\t\treturn this.allowEagerClassLoading;\n\t}\n\n\t@Override\n\tpublic void setBootstrapExecutor(@Nullable Executor bootstrapExecutor) {\n\t\tthis.bootstrapExecutor = bootstrapExecutor;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Executor getBootstrapExecutor() {\n\t\treturn this.bootstrapExecutor;\n\t}\n\n\t/**\n\t * Set a {@link java.util.Comparator} for dependency Lists and arrays.\n\t * @since 4.0\n\t * @see org.springframework.core.OrderComparator\n\t * @see org.springframework.core.annotation.AnnotationAwareOrderComparator\n\t */\n\tpublic void setDependencyComparator(@Nullable Comparator<Object> dependencyComparator) {\n\t\tthis.dependencyComparator = dependencyComparator;\n\t}\n\n\t/**\n\t * Return the dependency comparator for this BeanFactory (may be {@code null}).\n\t * @since 4.0\n\t */\n\t@Nullable\n\tpublic Comparator<Object> getDependencyComparator() {\n\t\treturn this.dependencyComparator;\n\t}\n\n\t/**\n\t * Set a custom autowire candidate resolver for this BeanFactory to use\n\t * when deciding whether a bean definition should be considered as a\n\t * candidate for autowiring.\n\t */\n\tpublic void setAutowireCandidateResolver(AutowireCandidateResolver autowireCandidateResolver) {\n\t\tAssert.notNull(autowireCandidateResolver, \"AutowireCandidateResolver must not be null\");\n\t\tif (autowireCandidateResolver instanceof BeanFactoryAware beanFactoryAware) {\n\t\t\tbeanFactoryAware.setBeanFactory(this);\n\t\t}\n\t\tthis.autowireCandidateResolver = autowireCandidateResolver;\n\t}\n\n\t/**\n\t * Return the autowire candidate resolver for this BeanFactory (never {@code null}).\n\t */\n\tpublic AutowireCandidateResolver getAutowireCandidateResolver() {\n\t\treturn this.autowireCandidateResolver;\n\t}\n\n\n\t@Override\n\tpublic void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {\n\t\tsuper.copyConfigurationFrom(otherFactory);\n\t\tif (otherFactory instanceof DefaultListableBeanFactory otherListableFactory) {\n\t\t\tthis.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;\n\t\t\tthis.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;\n\t\t\tthis.bootstrapExecutor = otherListableFactory.bootstrapExecutor;\n\t\t\tthis.dependencyComparator = otherListableFactory.dependencyComparator;\n\t\t\t// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware\n\t\t\tsetAutowireCandidateResolver(otherListableFactory.getAutowireCandidateResolver().cloneIfNecessary());\n\t\t\t// Make resolvable dependencies (for example, ResourceLoader) available here as well\n\t\t\tthis.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of remaining BeanFactory methods\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType) throws BeansException {\n\t\treturn getBean(requiredType, (Object[]) null);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tObject resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);\n\t\tif (resolved == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t}\n\t\treturn (T) resolved;\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\treturn getBeanProvider(ResolvableType.forRawClass(requiredType), true);\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {\n\t\treturn getBeanProvider(requiredType, true);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ListableBeanFactory interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic boolean containsBeanDefinition(String beanName) {\n\t\tAssert.notNull(beanName, \"Bean name must not be null\");\n\t\treturn this.beanDefinitionMap.containsKey(beanName);\n\t}\n\n\t@Override\n\tpublic int getBeanDefinitionCount() {\n\t\treturn this.beanDefinitionMap.size();\n\t}\n\n\t@Override\n\tpublic String[] getBeanDefinitionNames() {\n\t\tString[] frozenNames = this.frozenBeanDefinitionNames;\n\t\tif (frozenNames != null) {\n\t\t\treturn frozenNames.clone();\n\t\t}\n\t\telse {\n\t\t\treturn StringUtils.toStringArray(this.beanDefinitionNames);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType, boolean allowEagerInit) {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\treturn getBeanProvider(ResolvableType.forRawClass(requiredType), allowEagerInit);\n\t}\n\n\t@Override\n\tpublic <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn new BeanObjectProvider<>() {\n\t\t\t@Override\n\t\t\tpublic T getObject() throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, null, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic T getObject(Object... args) throws BeansException {\n\t\t\t\tT resolved = resolveBean(requiredType, args, false);\n\t\t\t\tif (resolved == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t\t\t\t}\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfAvailable() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, false);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifAvailable(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfAvailable();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic T getIfUnique() throws BeansException {\n\t\t\t\ttry {\n\t\t\t\t\treturn resolveBean(requiredType, null, true);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void ifUnique(Consumer<T> dependencyConsumer) throws BeansException {\n\t\t\t\tT dependency = getIfUnique();\n\t\t\t\tif (dependency != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> stream() {\n\t\t\t\treturn Arrays.stream(getBeanNamesForTypedStream(requiredType, allowEagerInit))\n\t\t\t\t\t\t.map(name -> (T) getBean(name))\n\t\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic Stream<T> orderedStream() {\n\t\t\t\tString[] beanNames = getBeanNamesForTypedStream(requiredType, allowEagerInit);\n\t\t\t\tif (beanNames.length == 0) {\n\t\t\t\t\treturn Stream.empty();\n\t\t\t\t}\n\t\t\t\tMap<String, T> matchingBeans = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\t\t\tfor (String beanName : beanNames) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\t\tmatchingBeans.put(beanName, (T) beanInstance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStream<T> stream = matchingBeans.values().stream();\n\t\t\t\treturn stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t};\n\t}\n\n\t@Nullable\n\tprivate <T> T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {\n\t\tNamedBeanHolder<T> namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);\n\t\tif (namedBean != null) {\n\t\t\treturn namedBean.getBeanInstance();\n\t\t}\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory dlbf) {\n\t\t\treturn dlbf.resolveBean(requiredType, args, nonUniqueAsNull);\n\t\t}\n\t\telse if (parent != null) {\n\t\t\tObjectProvider<T> parentProvider = parent.getBeanProvider(requiredType);\n\t\t\tif (args != null) {\n\t\t\t\treturn parentProvider.getObject(args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate String[] getBeanNamesForTypedStream(ResolvableType requiredType, boolean allowEagerInit) {\n\t\treturn BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this, requiredType, true, allowEagerInit);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(ResolvableType type) {\n\t\treturn getBeanNamesForType(type, true, true);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tClass<?> resolved = type.resolve();\n\t\tif (resolved != null && !type.hasGenerics()) {\n\t\t\treturn getBeanNamesForType(resolved, includeNonSingletons, allowEagerInit);\n\t\t}\n\t\telse {\n\t\t\treturn doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable Class<?> type) {\n\t\treturn getBeanNamesForType(type, true, true);\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tif (!isConfigurationFrozen() || type == null || !allowEagerInit) {\n\t\t\treturn doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);\n\t\t}\n\t\tMap<Class<?>, String[]> cache =\n\t\t\t\t(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);\n\t\tString[] resolvedBeanNames = cache.get(type);\n\t\tif (resolvedBeanNames != null) {\n\t\t\treturn resolvedBeanNames;\n\t\t}\n\t\tresolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);\n\t\tif (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {\n\t\t\tcache.put(type, resolvedBeanNames);\n\t\t}\n\t\treturn resolvedBeanNames;\n\t}\n\n\tprivate String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) {\n\t\tList<String> result = new ArrayList<>();\n\n\t\t// Check all bean definitions.\n\t\tfor (String beanName : this.beanDefinitionNames) {\n\t\t\t// Only consider bean as eligible if the bean name is not defined as alias for some other bean.\n\t\t\tif (!isAlias(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\t\t// Only check bean definition if it is complete.\n\t\t\t\t\tif (!mbd.isAbstract() && (allowEagerInit ||\n\t\t\t\t\t\t\t(mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &&\n\t\t\t\t\t\t\t\t\t!requiresEagerInitForType(mbd.getFactoryBeanName()))) {\n\t\t\t\t\t\tboolean isFactoryBean = isFactoryBean(beanName, mbd);\n\t\t\t\t\t\tBeanDefinitionHolder dbd = mbd.getDecoratedDefinition();\n\t\t\t\t\t\tboolean matchFound = false;\n\t\t\t\t\t\tboolean allowFactoryBeanInit = (allowEagerInit || containsSingleton(beanName));\n\t\t\t\t\t\tboolean isNonLazyDecorated = (dbd != null && !mbd.isLazyInit());\n\t\t\t\t\t\tif (!isFactoryBean) {\n\t\t\t\t\t\t\tif (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {\n\t\t\t\t\t\t\t\tmatchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (includeNonSingletons || isNonLazyDecorated ||\n\t\t\t\t\t\t\t\t\t(allowFactoryBeanInit && isSingleton(beanName, mbd, dbd))) {\n\t\t\t\t\t\t\t\tmatchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!matchFound) {\n\t\t\t\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean instance itself next.\n\t\t\t\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n\t\t\t\t\t\t\t\tif (includeNonSingletons || isSingleton(beanName, mbd, dbd)) {\n\t\t\t\t\t\t\t\t\tmatchFound = isTypeMatch(beanName, type, allowFactoryBeanInit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (matchFound) {\n\t\t\t\t\t\t\tresult.add(beanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (CannotLoadBeanClassException | BeanDefinitionStoreException ex) {\n\t\t\t\t\tif (allowEagerInit) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\t// Probably a placeholder: let's ignore it for type matching purposes.\n\t\t\t\t\tLogMessage message = (ex instanceof CannotLoadBeanClassException ?\n\t\t\t\t\t\t\tLogMessage.format(\"Ignoring bean class loading failure for bean '%s'\", beanName) :\n\t\t\t\t\t\t\tLogMessage.format(\"Ignoring unresolvable metadata in bean definition '%s'\", beanName));\n\t\t\t\t\tlogger.trace(message, ex);\n\t\t\t\t\t// Register exception, in case the bean was accidentally unresolvable.\n\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t// Bean definition got removed while we were iterating -> ignore.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check manually registered singletons too.\n\t\tfor (String beanName : this.manualSingletonNames) {\n\t\t\ttry {\n\t\t\t\t// In case of FactoryBean, match object created by FactoryBean.\n\t\t\t\tif (isFactoryBean(beanName)) {\n\t\t\t\t\tif ((includeNonSingletons || isSingleton(beanName)) && isTypeMatch(beanName, type)) {\n\t\t\t\t\t\tresult.add(beanName);\n\t\t\t\t\t\t// Match found for this bean: do not match FactoryBean itself anymore.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// In case of FactoryBean, try to match FactoryBean itself next.\n\t\t\t\t\tbeanName = FACTORY_BEAN_PREFIX + beanName;\n\t\t\t\t}\n\t\t\t\t// Match raw bean instance (might be raw FactoryBean).\n\t\t\t\tif (isTypeMatch(beanName, type)) {\n\t\t\t\t\tresult.add(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Shouldn't happen - probably a result of circular reference resolution...\n\t\t\t\tlogger.trace(LogMessage.format(\n\t\t\t\t\t\t\"Failed to check manually registered singleton with name '%s'\", beanName), ex);\n\t\t\t}\n\t\t}\n\n\t\treturn StringUtils.toStringArray(result);\n\t}\n\n\tprivate boolean isSingleton(String beanName, RootBeanDefinition mbd, @Nullable BeanDefinitionHolder dbd) {\n\t\treturn (dbd != null ? mbd.isSingleton() : isSingleton(beanName));\n\t}\n\n\t/**\n\t * Check whether the specified bean would need to be eagerly initialized\n\t * in order to determine its type.\n\t * @param factoryBeanName a factory-bean reference that the bean definition\n\t * defines a factory method for\n\t * @return whether eager initialization is necessary\n\t */\n\tprivate boolean requiresEagerInitForType(@Nullable String factoryBeanName) {\n\t\treturn (factoryBeanName != null && isFactoryBean(factoryBeanName) && !containsSingleton(factoryBeanName));\n\t}\n\n\t@Override\n\tpublic <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {\n\t\treturn getBeansOfType(type, true, true);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> Map<String, T> getBeansOfType(\n\t\t\t@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {\n\n\t\tString[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n\t\tMap<String, T> result = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\tfor (String beanName : beanNames) {\n\t\t\ttry {\n\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\t\tresult.put(beanName, (T) beanInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\tThrowable rootCause = ex.getMostSpecificCause();\n\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {\n\t\t\t\t\tString exBeanName = bce.getBeanName();\n\t\t\t\t\tif (exBeanName != null && isCurrentlyInCreation(exBeanName)) {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Ignoring match to currently created bean '\" + exBeanName + \"': \" +\n\t\t\t\t\t\t\t\t\tex.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonSuppressedException(ex);\n\t\t\t\t\t\t// Ignore: indicates a circular reference when autowiring constructors.\n\t\t\t\t\t\t// We want to find matches other than the currently created bean itself.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {\n\t\tList<String> result = new ArrayList<>();\n\t\tfor (String beanName : this.beanDefinitionNames) {\n\t\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n\t\t\tif (bd != null && !bd.isAbstract() && findAnnotationOnBean(beanName, annotationType) != null) {\n\t\t\t\tresult.add(beanName);\n\t\t\t}\n\t\t}\n\t\tfor (String beanName : this.manualSingletonNames) {\n\t\t\tif (!result.contains(beanName) && findAnnotationOnBean(beanName, annotationType) != null) {\n\t\t\t\tresult.add(beanName);\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(result);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) {\n\t\tString[] beanNames = getBeanNamesForAnnotation(annotationType);\n\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(beanNames.length);\n\t\tfor (String beanName : beanNames) {\n\t\t\tObject beanInstance = getBean(beanName);\n\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\tresult.put(beanName, beanInstance);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn findAnnotationOnBean(beanName, annotationType, true);\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic <A extends Annotation> A findAnnotationOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\tMergedAnnotations.from(beanType, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\tif (annotation.isPresent()) {\n\t\t\t\treturn annotation.synthesize();\n\t\t\t}\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, for example, in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\t\tMergedAnnotations.from(beanClass, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotation<A> annotation =\n\t\t\t\t\t\tMergedAnnotations.from(factoryMethod, SearchStrategy.TYPE_HIERARCHY).get(annotationType);\n\t\t\t\tif (annotation.isPresent()) {\n\t\t\t\t\treturn annotation.synthesize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> Set<A> findAllAnnotationsOnBean(\n\t\t\tString beanName, Class<A> annotationType, boolean allowFactoryBeanInit)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tSet<A> annotations = new LinkedHashSet<>();\n\t\tClass<?> beanType = getType(beanName, allowFactoryBeanInit);\n\t\tif (beanType != null) {\n\t\t\tMergedAnnotations.from(beanType, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t}\n\t\tif (containsBeanDefinition(beanName)) {\n\t\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\t\t// Check raw bean class, for example, in case of a proxy.\n\t\t\tif (bd.hasBeanClass() && bd.getFactoryMethodName() == null) {\n\t\t\t\tClass<?> beanClass = bd.getBeanClass();\n\t\t\t\tif (beanClass != beanType) {\n\t\t\t\t\tMergedAnnotations.from(beanClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check annotations declared on factory method, if any.\n\t\t\tMethod factoryMethod = bd.getResolvedFactoryMethod();\n\t\t\tif (factoryMethod != null) {\n\t\t\t\tMergedAnnotations.from(factoryMethod, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)\n\t\t\t\t\t\t.stream(annotationType)\n\t\t\t\t\t\t.filter(MergedAnnotation::isPresent)\n\t\t\t\t\t\t.forEach(mergedAnnotation -> annotations.add(mergedAnnotation.synthesize()));\n\t\t\t}\n\t\t}\n\t\treturn annotations;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of ConfigurableListableBeanFactory interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {\n\t\tAssert.notNull(dependencyType, \"Dependency type must not be null\");\n\t\tif (autowiredValue != null) {\n\t\t\tif (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {\n\t\t\t\tthrow new IllegalArgumentException(\"Value [\" + autowiredValue +\n\t\t\t\t\t\t\"] does not implement specified dependency type [\" + dependencyType.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.resolvableDependencies.put(dependencyType, autowiredValue);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\treturn isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());\n\t}\n\n\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */\n\tprotected boolean isAutowireCandidate(\n\t\t\tString beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)\n\t\t\tthrows NoSuchBeanDefinitionException {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(bdName)) {\n\t\t\treturn isAutowireCandidate(beanName, getMergedLocalBeanDefinition(bdName), descriptor, resolver);\n\t\t}\n\t\telse if (containsSingleton(beanName)) {\n\t\t\treturn isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);\n\t\t}\n\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof DefaultListableBeanFactory dlbf) {\n\t\t\t// No bean definition found in this factory -> delegate to parent.\n\t\t\treturn dlbf.isAutowireCandidate(beanName, descriptor, resolver);\n\t\t}\n\t\telse if (parent instanceof ConfigurableListableBeanFactory clbf) {\n\t\t\t// If no DefaultListableBeanFactory, can't pass the resolver along.\n\t\t\treturn clbf.isAutowireCandidate(beanName, descriptor);\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the specified bean definition qualifies as an autowire candidate,\n\t * to be injected into other beans which declare a dependency of matching type.\n\t * @param beanName the name of the bean definition to check\n\t * @param mbd the merged bean definition to check\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm\n\t * @return whether the bean should be considered as autowire candidate\n\t */\n\tprotected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,\n\t\t\tDependencyDescriptor descriptor, AutowireCandidateResolver resolver) {\n\n\t\tString bdName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\tresolveBeanClass(mbd, bdName);\n\t\tif (mbd.isFactoryMethodUnique && mbd.factoryMethodToIntrospect == null) {\n\t\t\tnew ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);\n\t\t}\n\t\tBeanDefinitionHolder holder = (beanName.equals(bdName) ?\n\t\t\t\tthis.mergedBeanDefinitionHolders.computeIfAbsent(beanName,\n\t\t\t\t\t\tkey -> new BeanDefinitionHolder(mbd, beanName, getAliases(bdName))) :\n\t\t\t\tnew BeanDefinitionHolder(mbd, beanName, getAliases(bdName)));\n\t\treturn resolver.isAutowireCandidate(holder, descriptor);\n\t}\n\n\t@Override\n\tpublic BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n\t\tif (bd == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n\t\t\t}\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n\t\t}\n\t\treturn bd;\n\t}\n\n\t@Override\n\tpublic Iterator<String> getBeanNamesIterator() {\n\t\tCompositeIterator<String> iterator = new CompositeIterator<>();\n\t\titerator.add(this.beanDefinitionNames.iterator());\n\t\titerator.add(this.manualSingletonNames.iterator());\n\t\treturn iterator;\n\t}\n\n\t@Override\n\tprotected void clearMergedBeanDefinition(String beanName) {\n\t\tsuper.clearMergedBeanDefinition(beanName);\n\t\tthis.mergedBeanDefinitionHolders.remove(beanName);\n\t}\n\n\t@Override\n\tpublic void clearMetadataCache() {\n\t\tsuper.clearMetadataCache();\n\t\tthis.mergedBeanDefinitionHolders.clear();\n\t\tclearByTypeCache();\n\t}\n\n\t@Override\n\tpublic void freezeConfiguration() {\n\t\tclearMetadataCache();\n\t\tthis.configurationFrozen = true;\n\t\tthis.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);\n\t}\n\n\t@Override\n\tpublic boolean isConfigurationFrozen() {\n\t\treturn this.configurationFrozen;\n\t}\n\n\t/**\n\t * Considers all beans as eligible for metadata caching\n\t * if the factory's configuration has been marked as frozen.\n\t * @see #freezeConfiguration()\n\t */\n\t@Override\n\tprotected boolean isBeanEligibleForMetadataCaching(String beanName) {\n\t\treturn (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)\n\t\t\tthrows Exception {\n\n\t\tif (supplier instanceof InstanceSupplier<?> instanceSupplier) {\n\t\t\treturn instanceSupplier.get(RegisteredBean.of(this, beanName, mbd));\n\t\t}\n\t\treturn super.obtainInstanceFromSupplier(supplier, beanName, mbd);\n\t}\n\n\t@Override\n\tprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args) {\n\t\tsuper.checkMergedBeanDefinition(mbd, beanName, args);\n\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.MAIN && getBootstrapExecutor() != null) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for background \" +\n\t\t\t\t\t\t\"initialization but requested in mainline thread - declare ObjectProvider \" +\n\t\t\t\t\t\t\"or lazy injection point in dependent mainline beans\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Bean intended to be initialized in main bootstrap thread\n\t\t\tif (this.preInstantiationThread.get() == PreInstantiation.BACKGROUND) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName, \"Bean marked for mainline initialization \" +\n\t\t\t\t\t\t\"but requested in background thread - enforce early instantiation in mainline thread \" +\n\t\t\t\t\t\t\"through depends-on '\" + beanName + \"' declaration for dependent background beans\");\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Boolean isCurrentThreadAllowedToHoldSingletonLock() {\n\t\treturn (this.preInstantiationPhase ? this.preInstantiationThread.get() != PreInstantiation.BACKGROUND : null);\n\t}\n\n\t@Override\n\tpublic void preInstantiateSingletons() throws BeansException {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Pre-instantiating singletons in \" + this);\n\t\t}\n\n\t\t// Iterate over a copy to allow for init methods which in turn register new bean definitions.\n\t\t// While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n\t\tList<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n\n\t\t// Trigger initialization of all non-lazy singleton beans...\n\t\tList<CompletableFuture<?>> futures = new ArrayList<>();\n\n\t\tthis.preInstantiationPhase = true;\n\t\tthis.preInstantiationThread.set(PreInstantiation.MAIN);\n\t\ttry {\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tif (!mbd.isAbstract() && mbd.isSingleton()) {\n\t\t\t\t\tCompletableFuture<?> future = preInstantiateSingleton(beanName, mbd);\n\t\t\t\t\tif (future != null) {\n\t\t\t\t\t\tfutures.add(future);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tthis.preInstantiationThread.remove();\n\t\t\tthis.preInstantiationPhase = false;\n\t\t}\n\n\t\tif (!futures.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tCompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0])).join();\n\t\t\t}\n\t\t\tcatch (CompletionException ex) {\n\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());\n\t\t\t}\n\t\t}\n\n\t\t// Trigger post-initialization callback for all applicable beans...\n\t\tfor (String beanName : beanNames) {\n\t\t\tObject singletonInstance = getSingleton(beanName, false);\n\t\t\tif (singletonInstance instanceof SmartInitializingSingleton smartSingleton) {\n\t\t\t\tStartupStep smartInitialize = getApplicationStartup().start(\"spring.beans.smart-initialize\")\n\t\t\t\t\t\t.tag(\"beanName\", beanName);\n\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\tsmartInitialize.end();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate CompletableFuture<?> preInstantiateSingleton(String beanName, RootBeanDefinition mbd) {\n\t\tif (mbd.isBackgroundInit()) {\n\t\t\tExecutor executor = getBootstrapExecutor();\n\t\t\tif (executor != null) {\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCompletableFuture<?> future = CompletableFuture.runAsync(\n\t\t\t\t\t\t() -> instantiateSingletonInBackgroundThread(beanName), executor);\n\t\t\t\taddSingletonFactory(beanName, () -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfuture.join();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (CompletionException ex) {\n\t\t\t\t\t\tReflectionUtils.rethrowRuntimeException(ex.getCause());\n\t\t\t\t\t}\n\t\t\t\t\treturn future;  // not to be exposed, just to lead to ClassCastException in case of mismatch\n\t\t\t\t});\n\t\t\t\treturn (!mbd.isLazyInit() ? future : null);\n\t\t\t}\n\t\t\telse if (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Bean '\" + beanName + \"' marked for background initialization \" +\n\t\t\t\t\t\t\"without bootstrap executor configured - falling back to mainline initialization\");\n\t\t\t}\n\t\t}\n\t\tif (!mbd.isLazyInit()) {\n\t\t\tinstantiateSingleton(beanName);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void instantiateSingletonInBackgroundThread(String beanName) {\n\t\tthis.preInstantiationThread.set(PreInstantiation.BACKGROUND);\n\t\ttry {\n\t\t\tinstantiateSingleton(beanName);\n\t\t}\n\t\tcatch (RuntimeException | Error ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Failed to instantiate singleton bean '\" + beanName + \"' in background thread\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t\tfinally {\n\t\t\tthis.preInstantiationThread.remove();\n\t\t}\n\t}\n\n\tprivate void instantiateSingleton(String beanName) {\n\t\tif (isFactoryBean(beanName)) {\n\t\t\tObject bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\tif (bean instanceof SmartFactoryBean<?> smartFactoryBean && smartFactoryBean.isEagerInit()) {\n\t\t\t\tgetBean(beanName);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tgetBean(beanName);\n\t\t}\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of BeanDefinitionRegistry interface\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n\t\tif (beanDefinition instanceof AbstractBeanDefinition abd) {\n\t\t\ttry {\n\t\t\t\tabd.validate();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n\t\tif (existingDefinition != null) {\n\t\t\tif (!isBeanDefinitionOverridable(beanName)) {\n\t\t\t\tthrow new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogBeanDefinitionOverriding(beanName, beanDefinition, existingDefinition);\n\t\t\t}\n\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\telse {\n\t\t\tif (isAlias(beanName)) {\n\t\t\t\tString aliasedName = canonicalName(beanName);\n\t\t\t\tif (!isBeanDefinitionOverridable(aliasedName)) {\n\t\t\t\t\tif (containsBeanDefinition(aliasedName)) {  // alias for existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionOverrideException(\n\t\t\t\t\t\t\t\tbeanName, beanDefinition, getBeanDefinition(aliasedName));\n\t\t\t\t\t}\n\t\t\t\t\telse {  // alias pointing to non-existing bean definition\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\"Cannot register bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\t\"' since there is already an alias for bean '\" + aliasedName + \"' bound.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\tlogger.info(\"Removing alias '\" + beanName + \"' for bean '\" + aliasedName +\n\t\t\t\t\t\t\t\t\"' due to registration of bean definition for bean '\" + beanName + \"': [\" +\n\t\t\t\t\t\t\t\tbeanDefinition + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tremoveAlias(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasBeanCreationStarted()) {\n\t\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n\t\t\t\t\tupdatedDefinitions.addAll(this.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Still in startup registration phase\n\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\tthis.beanDefinitionNames.add(beanName);\n\t\t\t\tremoveManualSingletonName(beanName);\n\t\t\t}\n\t\t\tthis.frozenBeanDefinitionNames = null;\n\t\t}\n\n\t\tif (existingDefinition != null || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t\telse if (isConfigurationFrozen()) {\n\t\t\tclearByTypeCache();\n\t\t}\n\n\t\t// Cache a primary marker for the given bean.\n\t\tif (beanDefinition.isPrimary()) {\n\t\t\tthis.primaryBeanNames.add(beanName);\n\t\t}\n\t}\n\n\tprivate void logBeanDefinitionOverriding(String beanName, BeanDefinition beanDefinition,\n\t\t\tBeanDefinition existingDefinition) {\n\n\t\tboolean explicitBeanOverride = (this.allowBeanDefinitionOverriding != null);\n\t\tif (existingDefinition.getRole() < beanDefinition.getRole()) {\n\t\t\t// for example, was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Overriding user-defined bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with a framework-generated bean definition: replacing [\" +\n\t\t\t\t\t\texistingDefinition + \"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t}\n\t\telse if (!beanDefinition.equals(existingDefinition)) {\n\t\t\tif (explicitBeanOverride && logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with a different definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with a different definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (explicitBeanOverride && logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + existingDefinition +\n\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tAssert.hasText(beanName, \"'beanName' must not be empty\");\n\n\t\tBeanDefinition bd = this.beanDefinitionMap.remove(beanName);\n\t\tif (bd == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No bean named '\" + beanName + \"' found in \" + this);\n\t\t\t}\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n\t\t}\n\n\t\tif (hasBeanCreationStarted()) {\n\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\tList<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames);\n\t\t\t\tupdatedDefinitions.remove(beanName);\n\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Still in startup registration phase\n\t\t\tthis.beanDefinitionNames.remove(beanName);\n\t\t}\n\t\tthis.frozenBeanDefinitionNames = null;\n\n\t\tresetBeanDefinition(beanName);\n\t}\n\n\t/**\n\t * Reset all bean definition caches for the given bean,\n\t * including the caches of beans that are derived from it.\n\t * <p>Called after an existing bean definition has been replaced or removed,\n\t * triggering {@link #clearMergedBeanDefinition}, {@link #destroySingleton}\n\t * and {@link MergedBeanDefinitionPostProcessor#resetBeanDefinition} on the\n\t * given bean and on all bean definitions that have the given bean as parent.\n\t * @param beanName the name of the bean to reset\n\t * @see #registerBeanDefinition\n\t * @see #removeBeanDefinition\n\t */\n\tprotected void resetBeanDefinition(String beanName) {\n\t\t// Remove the merged bean definition for the given bean, if already created.\n\t\tclearMergedBeanDefinition(beanName);\n\n\t\t// Remove corresponding bean from singleton cache, if any. Shouldn't usually\n\t\t// be necessary, rather just meant for overriding a context's default beans\n\t\t// (for example, the default StaticMessageSource in a StaticApplicationContext).\n\t\tdestroySingleton(beanName);\n\n\t\t// Remove a cached primary marker for the given bean.\n\t\tthis.primaryBeanNames.remove(beanName);\n\n\t\t// Notify all post-processors that the specified bean definition has been reset.\n\t\tfor (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {\n\t\t\tprocessor.resetBeanDefinition(beanName);\n\t\t}\n\n\t\t// Reset all bean definitions that have the given bean as parent (recursively).\n\t\tfor (String bdName : this.beanDefinitionNames) {\n\t\t\tif (!beanName.equals(bdName)) {\n\t\t\t\tBeanDefinition bd = this.beanDefinitionMap.get(bdName);\n\t\t\t\t// Ensure bd is non-null due to potential concurrent modification of beanDefinitionMap.\n\t\t\t\tif (bd != null && beanName.equals(bd.getParentName())) {\n\t\t\t\t\tresetBeanDefinition(bdName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This implementation returns {@code true} if bean definition overriding\n\t * is generally allowed.\n\t * @see #setAllowBeanDefinitionOverriding\n\t */\n\t@Override\n\tpublic boolean isBeanDefinitionOverridable(String beanName) {\n\t\treturn isAllowBeanDefinitionOverriding();\n\t}\n\n\t/**\n\t * Only allows alias overriding if bean definition overriding is allowed.\n\t * @see #setAllowBeanDefinitionOverriding\n\t */\n\t@Override\n\tprotected boolean allowAliasOverriding() {\n\t\treturn isAllowBeanDefinitionOverriding();\n\t}\n\n\t/**\n\t * Also checks for an alias overriding a bean definition of the same name.\n\t */\n\t@Override\n\tprotected void checkForAliasCircle(String name, String alias) {\n\t\tsuper.checkForAliasCircle(name, alias);\n\t\tif (!isBeanDefinitionOverridable(alias) && containsBeanDefinition(alias)) {\n\t\t\tthrow new IllegalStateException(\"Cannot register alias '\" + alias +\n\t\t\t\t\t\"' for name '\" + name + \"': Alias would override bean definition '\" + alias + \"'\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {\n\t\tsuper.registerSingleton(beanName, singletonObject);\n\t\tupdateManualSingletonNames(set -> set.add(beanName), set -> !this.beanDefinitionMap.containsKey(beanName));\n\t\tclearByTypeCache();\n\t}\n\n\t@Override\n\tpublic void destroySingletons() {\n\t\tsuper.destroySingletons();\n\t\tupdateManualSingletonNames(Set::clear, set -> !set.isEmpty());\n\t\tclearByTypeCache();\n\t}\n\n\t@Override\n\tpublic void destroySingleton(String beanName) {\n\t\tsuper.destroySingleton(beanName);\n\t\tremoveManualSingletonName(beanName);\n\t\tclearByTypeCache();\n\t}\n\n\tprivate void removeManualSingletonName(String beanName) {\n\t\tupdateManualSingletonNames(set -> set.remove(beanName), set -> set.contains(beanName));\n\t}\n\n\t/**\n\t * Update the factory's internal set of manual singleton names.\n\t * @param action the modification action\n\t * @param condition a precondition for the modification action\n\t * (if this condition does not apply, the action can be skipped)\n\t */\n\tprivate void updateManualSingletonNames(Consumer<Set<String>> action, Predicate<Set<String>> condition) {\n\t\tif (hasBeanCreationStarted()) {\n\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\tif (condition.test(this.manualSingletonNames)) {\n\t\t\t\t\tSet<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);\n\t\t\t\t\taction.accept(updatedSingletons);\n\t\t\t\t\tthis.manualSingletonNames = updatedSingletons;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Still in startup registration phase\n\t\t\tif (condition.test(this.manualSingletonNames)) {\n\t\t\t\taction.accept(this.manualSingletonNames);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove any assumptions about by-type mappings.\n\t */\n\tprivate void clearByTypeCache() {\n\t\tthis.allBeanNamesByType.clear();\n\t\tthis.singletonBeanNamesByType.clear();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Dependency resolution functionality\n\t//---------------------------------------------------------------------\n\n\t@Override\n\tpublic <T> NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType) throws BeansException {\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tNamedBeanHolder<T> namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), null, false);\n\t\tif (namedBean != null) {\n\t\t\treturn namedBean;\n\t\t}\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent instanceof AutowireCapableBeanFactory acbf) {\n\t\t\treturn acbf.resolveNamedBean(requiredType);\n\t\t}\n\t\tthrow new NoSuchBeanDefinitionException(requiredType);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprivate <T> NamedBeanHolder<T> resolveNamedBean(\n\t\t\tResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {\n\n\t\tAssert.notNull(requiredType, \"Required type must not be null\");\n\t\tString[] candidateNames = getBeanNamesForType(requiredType);\n\n\t\tif (candidateNames.length > 1) {\n\t\t\tList<String> autowireCandidates = new ArrayList<>(candidateNames.length);\n\t\t\tfor (String beanName : candidateNames) {\n\t\t\t\tif (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {\n\t\t\t\t\tautowireCandidates.add(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!autowireCandidates.isEmpty()) {\n\t\t\t\tcandidateNames = StringUtils.toStringArray(autowireCandidates);\n\t\t\t}\n\t\t}\n\n\t\tif (candidateNames.length == 1) {\n\t\t\treturn resolveNamedBean(candidateNames[0], requiredType, args);\n\t\t}\n\t\telse if (candidateNames.length > 1) {\n\t\t\tMap<String, Object> candidates = CollectionUtils.newLinkedHashMap(candidateNames.length);\n\t\t\tfor (String beanName : candidateNames) {\n\t\t\t\tif (containsSingleton(beanName) && args == null) {\n\t\t\t\t\tObject beanInstance = getBean(beanName);\n\t\t\t\t\tcandidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcandidates.put(beanName, getType(beanName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tString candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());\n\t\t\tif (candidateName == null) {\n\t\t\t\tcandidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());\n\t\t\t}\n\t\t\tif (candidateName != null) {\n\t\t\t\tObject beanInstance = candidates.get(candidateName);\n\t\t\t\tif (beanInstance == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (beanInstance instanceof Class) {\n\t\t\t\t\treturn resolveNamedBean(candidateName, requiredType, args);\n\t\t\t\t}\n\t\t\t\treturn new NamedBeanHolder<>(candidateName, (T) beanInstance);\n\t\t\t}\n\t\t\tif (!nonUniqueAsNull) {\n\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate <T> NamedBeanHolder<T> resolveNamedBean(\n\t\t\tString beanName, ResolvableType requiredType, @Nullable Object[] args) throws BeansException {\n\n\t\tObject bean = getBean(beanName, null, args);\n\t\tif (bean instanceof NullBean) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new NamedBeanHolder<>(beanName, adaptBeanInstance(beanName, bean, requiredType.toClass()));\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\n\t\tif (Optional.class == descriptor.getDependencyType()) {\n\t\t\treturn createOptionalDependency(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (ObjectFactory.class == descriptor.getDependencyType() ||\n\t\t\t\tObjectProvider.class == descriptor.getDependencyType()) {\n\t\t\treturn new DependencyObjectProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (jakartaInjectProviderClass == descriptor.getDependencyType()) {\n\t\t\treturn new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);\n\t\t}\n\t\telse if (descriptor.supportsLazyResolution()) {\n\t\t\tObject result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(\n\t\t\t\t\tdescriptor, requestingBeanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);\n\t}\n\n\t@Nullable\n\t@SuppressWarnings(\"NullAway\")\n\tpublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {\n\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\t// Step 1: pre-resolved shortcut for single bean match, for example, from @Autowired\n\t\t\tObject shortcut = descriptor.resolveShortcut(this);\n\t\t\tif (shortcut != null) {\n\t\t\t\treturn shortcut;\n\t\t\t}\n\n\t\t\tClass<?> type = descriptor.getDependencyType();\n\n\t\t\t// Step 2: pre-defined value or expression, for example, from @Value\n\t\t\tObject value = getAutowireCandidateResolver().getSuggestedValue(descriptor);\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof String strValue) {\n\t\t\t\t\tString resolvedValue = resolveEmbeddedValue(strValue);\n\t\t\t\t\tBeanDefinition bd = (beanName != null && containsBean(beanName) ?\n\t\t\t\t\t\t\tgetMergedBeanDefinition(beanName) : null);\n\t\t\t\t\tvalue = evaluateBeanDefinitionString(resolvedValue, bd);\n\t\t\t\t}\n\t\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\t\ttry {\n\t\t\t\t\treturn converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedOperationException ex) {\n\t\t\t\t\t// A custom TypeConverter which does not support TypeDescriptor resolution...\n\t\t\t\t\treturn (descriptor.getField() != null ?\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getField()) :\n\t\t\t\t\t\t\tconverter.convertIfNecessary(value, type, descriptor.getMethodParameter()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Step 3: shortcut for declared dependency name or qualifier-suggested name matching target bean name\n\t\t\tif (descriptor.usesStandardBeanLookup()) {\n\t\t\t\tString dependencyName = descriptor.getDependencyName();\n\t\t\t\tif (dependencyName == null || !containsBean(dependencyName)) {\n\t\t\t\t\tString suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);\n\t\t\t\t\tdependencyName = (suggestedName != null && containsBean(suggestedName) ? suggestedName : null);\n\t\t\t\t}\n\t\t\t\tif (dependencyName != null) {\n\t\t\t\t\tdependencyName = canonicalName(dependencyName);  // dependency name can be alias of target name\n\t\t\t\t\tif (isTypeMatch(dependencyName, type) && isAutowireCandidate(dependencyName, descriptor) &&\n\t\t\t\t\t\t\t!isFallback(dependencyName) && !hasPrimaryConflict(dependencyName, type) &&\n\t\t\t\t\t\t\t!isSelfReference(beanName, dependencyName)) {\n\t\t\t\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\t\t\t\tautowiredBeanNames.add(dependencyName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObject dependencyBean = getBean(dependencyName);\n\t\t\t\t\t\treturn resolveInstance(dependencyBean, descriptor, type, dependencyName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Step 4a: multiple beans as stream / array / standard collection / plain map\n\t\t\tObject multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\tif (multipleBeans != null) {\n\t\t\t\treturn multipleBeans;\n\t\t\t}\n\t\t\t// Step 4b: direct bean matches, possibly direct beans of type Collection / Map\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\t// Step 4c (fallback): custom Collection / Map declarations for collecting multiple beans\n\t\t\t\tmultipleBeans = resolveMultipleBeansFallback(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t\t\tif (multipleBeans != null) {\n\t\t\t\t\treturn multipleBeans;\n\t\t\t\t}\n\t\t\t\t// Raise exception if nothing found for required injection point\n\t\t\t\tif (isRequired(descriptor)) {\n\t\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tString autowiredBeanName;\n\t\t\tObject instanceCandidate;\n\n\t\t\t// Step 5: determine single candidate\n\t\t\tif (matchingBeans.size() > 1) {\n\t\t\t\tautowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);\n\t\t\t\tif (autowiredBeanName == null) {\n\t\t\t\t\tif (isRequired(descriptor) || !indicatesArrayCollectionOrMap(type)) {\n\t\t\t\t\t\t// Raise exception if no clear match found for required injection point\n\t\t\t\t\t\treturn descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// In case of an optional Collection/Map, silently ignore a non-unique case:\n\t\t\t\t\t\t// possibly it was meant to be an empty collection of multiple regular beans\n\t\t\t\t\t\t// (before 4.3 in particular when we didn't even look for collection beans).\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinstanceCandidate = matchingBeans.get(autowiredBeanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We have exactly one match.\n\t\t\t\tMap.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();\n\t\t\t\tautowiredBeanName = entry.getKey();\n\t\t\t\tinstanceCandidate = entry.getValue();\n\t\t\t}\n\n\t\t\t// Step 6: validate single result\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.add(autowiredBeanName);\n\t\t\t}\n\t\t\tif (instanceCandidate instanceof Class) {\n\t\t\t\tinstanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);\n\t\t\t}\n\t\t\treturn resolveInstance(instanceCandidate, descriptor, type, autowiredBeanName);\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate Object resolveInstance(Object candidate, DependencyDescriptor descriptor, Class<?> type, String name) {\n\t\tObject result = candidate;\n\t\tif (result instanceof NullBean) {\n\t\t\t// Raise exception if null encountered for required injection point\n\t\t\tif (isRequired(descriptor)) {\n\t\t\t\traiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);\n\t\t\t}\n\t\t\tresult = null;\n\t\t}\n\t\tif (!ClassUtils.isAssignableValue(type, result)) {\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, type, candidate.getClass());\n\t\t}\n\t\treturn result;\n\n\t}\n\n\t@Nullable\n\tprivate Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tClass<?> type = descriptor.getDependencyType();\n\n\t\tif (descriptor instanceof StreamDependencyDescriptor streamDependencyDescriptor) {\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\tStream<Object> stream = matchingBeans.keySet().stream()\n\t\t\t\t\t.map(name -> descriptor.resolveCandidate(name, type, this))\n\t\t\t\t\t.filter(bean -> !(bean instanceof NullBean));\n\t\t\tif (streamDependencyDescriptor.isOrdered()) {\n\t\t\t\tstream = stream.sorted(adaptOrderComparator(matchingBeans));\n\t\t\t}\n\t\t\treturn stream;\n\t\t}\n\t\telse if (type.isArray()) {\n\t\t\tClass<?> componentType = type.componentType();\n\t\t\tResolvableType resolvableType = descriptor.getResolvableType();\n\t\t\tClass<?> resolvedArrayType = resolvableType.resolve(type);\n\t\t\tif (resolvedArrayType != type) {\n\t\t\t\tcomponentType = resolvableType.getComponentType().resolve();\n\t\t\t}\n\t\t\tif (componentType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType,\n\t\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\t\tif (matchingBeans.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (autowiredBeanNames != null) {\n\t\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t\t}\n\t\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\t\tObject result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);\n\t\t\tif (result instanceof Object[] array && array.length > 1) {\n\t\t\t\tComparator<Object> comparator = adaptDependencyComparator(matchingBeans);\n\t\t\t\tif (comparator != null) {\n\t\t\t\t\tArrays.sort(array, comparator);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse if (Collection.class == type || Set.class == type || List.class == type) {\n\t\t\treturn resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\telse if (Map.class == type) {\n\t\t\treturn resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Nullable\n\tprivate Object resolveMultipleBeansFallback(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tClass<?> type = descriptor.getDependencyType();\n\n\t\tif (Collection.class.isAssignableFrom(type) && type.isInterface()) {\n\t\t\treturn resolveMultipleBeanCollection(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\telse if (Map.class.isAssignableFrom(type) && type.isInterface()) {\n\t\t\treturn resolveMultipleBeanMap(descriptor, beanName, autowiredBeanNames, typeConverter);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate Object resolveMultipleBeanCollection(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tClass<?> elementType = descriptor.getResolvableType().asCollection().resolveGeneric();\n\t\tif (elementType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType,\n\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\tif (matchingBeans.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (autowiredBeanNames != null) {\n\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t}\n\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\tObject result = converter.convertIfNecessary(matchingBeans.values(), descriptor.getDependencyType());\n\t\tif (result instanceof List<?> list && list.size() > 1) {\n\t\t\tComparator<Object> comparator = adaptDependencyComparator(matchingBeans);\n\t\t\tif (comparator != null) {\n\t\t\t\tlist.sort(comparator);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Nullable\n\tprivate Object resolveMultipleBeanMap(DependencyDescriptor descriptor, @Nullable String beanName,\n\t\t\t@Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) {\n\n\t\tResolvableType mapType = descriptor.getResolvableType().asMap();\n\t\tClass<?> keyType = mapType.resolveGeneric(0);\n\t\tif (String.class != keyType) {\n\t\t\treturn null;\n\t\t}\n\t\tClass<?> valueType = mapType.resolveGeneric(1);\n\t\tif (valueType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType,\n\t\t\t\tnew MultiElementDescriptor(descriptor));\n\t\tif (matchingBeans.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (autowiredBeanNames != null) {\n\t\t\tautowiredBeanNames.addAll(matchingBeans.keySet());\n\t\t}\n\t\tTypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());\n\t\treturn converter.convertIfNecessary(matchingBeans, descriptor.getDependencyType());\n\t}\n\n\tprivate boolean indicatesArrayCollectionOrMap(Class<?> type) {\n\t\treturn (type.isArray() || (type.isInterface() &&\n\t\t\t\t(Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type))));\n\t}\n\n\tprivate boolean isRequired(DependencyDescriptor descriptor) {\n\t\treturn getAutowireCandidateResolver().isRequired(descriptor);\n\t}\n\n\t@Nullable\n\tprivate Comparator<Object> adaptDependencyComparator(Map<String, ?> matchingBeans) {\n\t\tComparator<Object> comparator = getDependencyComparator();\n\t\tif (comparator instanceof OrderComparator orderComparator) {\n\t\t\treturn orderComparator.withSourceProvider(\n\t\t\t\t\tcreateFactoryAwareOrderSourceProvider(matchingBeans));\n\t\t}\n\t\telse {\n\t\t\treturn comparator;\n\t\t}\n\t}\n\n\tprivate Comparator<Object> adaptOrderComparator(Map<String, ?> matchingBeans) {\n\t\tComparator<Object> dependencyComparator = getDependencyComparator();\n\t\tOrderComparator comparator = (dependencyComparator instanceof OrderComparator orderComparator ?\n\t\t\t\torderComparator : OrderComparator.INSTANCE);\n\t\treturn comparator.withSourceProvider(createFactoryAwareOrderSourceProvider(matchingBeans));\n\t}\n\n\tprivate OrderComparator.OrderSourceProvider createFactoryAwareOrderSourceProvider(Map<String, ?> beans) {\n\t\tIdentityHashMap<Object, String> instancesToBeanNames = new IdentityHashMap<>();\n\t\tbeans.forEach((beanName, instance) -> instancesToBeanNames.put(instance, beanName));\n\t\treturn new FactoryAwareOrderSourceProvider(instancesToBeanNames);\n\t}\n\n\t/**\n\t * Find bean instances that match the required type.\n\t * Called during autowiring for the specified bean.\n\t * @param beanName the name of the bean that is about to be wired\n\t * @param requiredType the actual type of bean to look for\n\t * (may be an array component type or collection element type)\n\t * @param descriptor the descriptor of the dependency to resolve\n\t * @return a Map of candidate names and candidate instances that match\n\t * the required type (never {@code null})\n\t * @throws BeansException in case of errors\n\t * @see #autowireByType\n\t * @see #autowireConstructor\n\t */\n\tprotected Map<String, Object> findAutowireCandidates(\n\t\t\t@Nullable String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {\n\n\t\tString[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\tthis, requiredType, true, descriptor.isEager());\n\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(candidateNames.length);\n\t\tfor (Map.Entry<Class<?>, Object> classObjectEntry : this.resolvableDependencies.entrySet()) {\n\t\t\tClass<?> autowiringType = classObjectEntry.getKey();\n\t\t\tif (autowiringType.isAssignableFrom(requiredType)) {\n\t\t\t\tObject autowiringValue = classObjectEntry.getValue();\n\t\t\t\tautowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);\n\t\t\t\tif (requiredType.isInstance(autowiringValue)) {\n\t\t\t\t\tresult.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (String candidate : candidateNames) {\n\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {\n\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t}\n\t\t}\n\t\tif (result.isEmpty()) {\n\t\t\tboolean multiple = indicatesArrayCollectionOrMap(requiredType);\n\t\t\t// Consider fallback matches if the first pass failed to find anything...\n\t\t\tDependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();\n\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor) &&\n\t\t\t\t\t\t(!multiple || getAutowireCandidateResolver().hasQualifier(descriptor))) {\n\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.isEmpty() && !multiple) {\n\t\t\t\t// Consider self references as a final pass...\n\t\t\t\t// but in the case of a dependency collection, not the very same bean itself.\n\t\t\t\tfor (String candidate : candidateNames) {\n\t\t\t\t\tif (isSelfReference(beanName, candidate) &&\n\t\t\t\t\t\t\t(!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&\n\t\t\t\t\t\t\tisAutowireCandidate(candidate, fallbackDescriptor)) {\n\t\t\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Add an entry to the candidate map: a bean instance if available or just the resolved\n\t * type, preventing early bean initialization ahead of primary candidate selection.\n\t */\n\tprivate void addCandidateEntry(Map<String, Object> candidates, String candidateName,\n\t\t\tDependencyDescriptor descriptor, Class<?> requiredType) {\n\n\t\tif (descriptor instanceof MultiElementDescriptor) {\n\t\t\tObject beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);\n\t\t\tif (!(beanInstance instanceof NullBean)) {\n\t\t\t\tcandidates.put(candidateName, beanInstance);\n\t\t\t}\n\t\t}\n\t\telse if (containsSingleton(candidateName) || (descriptor instanceof StreamDependencyDescriptor streamDescriptor &&\n\t\t\t\tstreamDescriptor.isOrdered())) {\n\t\t\tObject beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);\n\t\t\tcandidates.put(candidateName, (beanInstance instanceof NullBean ? null : beanInstance));\n\t\t}\n\t\telse {\n\t\t\tcandidates.put(candidateName, getType(candidateName));\n\t\t}\n\t}\n\n\t/**\n\t * Determine the autowire candidate in the given set of beans.\n\t * <p>Looks for {@code @Primary} and {@code @Priority} (in that order).\n\t * @param candidates a Map of candidate names and candidate instances\n\t * that match the required type, as returned by {@link #findAutowireCandidates}\n\t * @param descriptor the target dependency to match against\n\t * @return the name of the autowire candidate, or {@code null} if none found\n\t */\n\t@Nullable\n\tprotected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {\n\t\tClass<?> requiredType = descriptor.getDependencyType();\n\t\t// Step 1: check primary candidate\n\t\tString primaryCandidate = determinePrimaryCandidate(candidates, requiredType);\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\t\t// Step 2a: match bean name against declared dependency name\n\t\tString dependencyName = descriptor.getDependencyName();\n\t\tif (dependencyName != null) {\n\t\t\tfor (String beanName : candidates.keySet()) {\n\t\t\t\tif (matchesBeanName(beanName, dependencyName)) {\n\t\t\t\t\treturn beanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Step 2b: match bean name against qualifier-suggested name\n\t\tString suggestedName = getAutowireCandidateResolver().getSuggestedName(descriptor);\n\t\tif (suggestedName != null) {\n\t\t\tfor (String beanName : candidates.keySet()) {\n\t\t\t\tif (matchesBeanName(beanName, suggestedName)) {\n\t\t\t\t\treturn beanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Step 3: check highest priority candidate\n\t\tString priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);\n\t\tif (priorityCandidate != null) {\n\t\t\treturn priorityCandidate;\n\t\t}\n\t\t// Step 4: pick directly registered dependency\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) {\n\t\t\t\treturn candidateName;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of beans.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see #isPrimary(String, Object)\n\t */\n\t@Nullable\n\tprotected String determinePrimaryCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (isPrimary(candidateBeanName, beanInstance)) {\n\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\tboolean candidateLocal = containsBeanDefinition(candidateBeanName);\n\t\t\t\t\tboolean primaryLocal = containsBeanDefinition(primaryBeanName);\n\t\t\t\t\tif (candidateLocal == primaryLocal) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidates.keySet());\n\t\t\t\t\t}\n\t\t\t\t\telse if (candidateLocal) {\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidates.keySet()) {\n\t\t\t\tif (!isFallback(candidateBeanName)) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Determine the candidate with the highest priority in the given set of beans.\n\t * <p>Based on {@code @jakarta.annotation.Priority}. As defined by the related\n\t * {@link org.springframework.core.Ordered} interface, the lowest value has\n\t * the highest priority.\n\t * @param candidates a Map of candidate names and candidate instances\n\t * (or candidate classes if not created yet) that match the required type\n\t * @param requiredType the target dependency type to match against\n\t * @return the name of the candidate with the highest priority,\n\t * or {@code null} if none found\n\t * @throws NoUniqueBeanDefinitionException if multiple beans are detected with\n\t * the same highest priority value\n\t * @see #getPriority(Object)\n\t */\n\t@Nullable\n\tprotected String determineHighestPriorityCandidate(Map<String, Object> candidates, Class<?> requiredType) {\n\t\tString highestPriorityBeanName = null;\n\t\tInteger highestPriority = null;\n\t\tboolean highestPriorityConflictDetected = false;\n\t\tfor (Map.Entry<String, Object> entry : candidates.entrySet()) {\n\t\t\tString candidateBeanName = entry.getKey();\n\t\t\tObject beanInstance = entry.getValue();\n\t\t\tif (beanInstance != null) {\n\t\t\t\tInteger candidatePriority = getPriority(beanInstance);\n\t\t\t\tif (candidatePriority != null) {\n\t\t\t\t\tif (highestPriority != null) {\n\t\t\t\t\t\tif (candidatePriority.equals(highestPriority)) {\n\t\t\t\t\t\t\thighestPriorityConflictDetected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (candidatePriority < highestPriority) {\n\t\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t\t\thighestPriorityConflictDetected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thighestPriorityBeanName = candidateBeanName;\n\t\t\t\t\t\thighestPriority = candidatePriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (highestPriorityConflictDetected) {\n\t\t\tthrow new NoUniqueBeanDefinitionException(requiredType, candidates.size(),\n\t\t\t\t\t\"Multiple beans found with the same highest priority (\" + highestPriority +\n\t\t\t\t\t\") among candidates: \" + candidates.keySet());\n\n\t\t}\n\t\treturn highestPriorityBeanName;\n\t}\n\n\t/**\n\t * Return whether the bean definition for the given bean name has been\n\t * marked as a primary bean.\n\t * @param beanName the name of the bean\n\t * @param beanInstance the corresponding bean instance (can be {@code null})\n\t * @return whether the given bean qualifies as primary\n\t */\n\tprotected boolean isPrimary(String beanName, Object beanInstance) {\n\t\tString transformedBeanName = transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(transformedBeanName)) {\n\t\t\treturn getMergedLocalBeanDefinition(transformedBeanName).isPrimary();\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.isPrimary(transformedBeanName, beanInstance));\n\t}\n\n\t/**\n\t * Return whether the bean definition for the given bean name has been\n\t * marked as a fallback bean.\n\t * @param beanName the name of the bean\n\t * @since 6.2\n\t */\n\tprivate boolean isFallback(String beanName) {\n\t\tString transformedBeanName = transformedBeanName(beanName);\n\t\tif (containsBeanDefinition(transformedBeanName)) {\n\t\t\treturn getMergedLocalBeanDefinition(transformedBeanName).isFallback();\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.isFallback(transformedBeanName));\n\t}\n\n\t/**\n\t * Return the priority assigned for the given bean instance by\n\t * the {@code jakarta.annotation.Priority} annotation.\n\t * <p>The default implementation delegates to the specified\n\t * {@link #setDependencyComparator dependency comparator}, checking its\n\t * {@link OrderComparator#getPriority method} if it is an extension of\n\t * Spring's common {@link OrderComparator} - typically, an\n\t * {@link org.springframework.core.annotation.AnnotationAwareOrderComparator}.\n\t * If no such comparator is present, this implementation returns {@code null}.\n\t * @param beanInstance the bean instance to check (can be {@code null})\n\t * @return the priority assigned to that bean or {@code null} if none is set\n\t */\n\t@Nullable\n\tprotected Integer getPriority(Object beanInstance) {\n\t\tComparator<Object> comparator = getDependencyComparator();\n\t\tif (comparator instanceof OrderComparator orderComparator) {\n\t\t\treturn orderComparator.getPriority(beanInstance);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Determine whether the given candidate name matches the bean name or the aliases\n\t * stored in this bean definition.\n\t */\n\tprotected boolean matchesBeanName(String beanName, @Nullable String candidateName) {\n\t\treturn (candidateName != null &&\n\t\t\t\t(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));\n\t}\n\n\t/**\n\t * Determine whether the given beanName/candidateName pair indicates a self reference,\n\t * i.e. whether the candidate points back to the original bean or to a factory method\n\t * on the original bean.\n\t */\n\t@Contract(\"null, _ -> false;_, null -> false;\")\n\tprivate boolean isSelfReference(@Nullable String beanName, @Nullable String candidateName) {\n\t\treturn (beanName != null && candidateName != null &&\n\t\t\t\t(beanName.equals(candidateName) || (containsBeanDefinition(candidateName) &&\n\t\t\t\t\t\tbeanName.equals(getMergedLocalBeanDefinition(candidateName).getFactoryBeanName()))));\n\t}\n\n\t/**\n\t * Determine whether there is a primary bean registered for the given dependency type,\n\t * not matching the given bean name.\n\t */\n\tprivate boolean hasPrimaryConflict(String beanName, Class<?> dependencyType) {\n\t\tfor (String candidate : this.primaryBeanNames) {\n\t\t\tif (isTypeMatch(candidate, dependencyType) && !candidate.equals(beanName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (getParentBeanFactory() instanceof DefaultListableBeanFactory parent &&\n\t\t\t\tparent.hasPrimaryConflict(beanName, dependencyType));\n\t}\n\n\t/**\n\t * Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException\n\t * for an unresolvable dependency.\n\t */\n\tprivate void raiseNoMatchingBeanFound(\n\t\t\tClass<?> type, ResolvableType resolvableType, DependencyDescriptor descriptor) throws BeansException {\n\n\t\tcheckBeanNotOfRequiredType(type, descriptor);\n\n\t\tthrow new NoSuchBeanDefinitionException(resolvableType,\n\t\t\t\t\"expected at least 1 bean which qualifies as autowire candidate. \" +\n\t\t\t\t\"Dependency annotations: \" + ObjectUtils.nullSafeToString(descriptor.getAnnotations()));\n\t}\n\n\t/**\n\t * Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable,\n\t * i.e. if the target type of the bean would match but an exposed proxy doesn't.\n\t */\n\tprivate void checkBeanNotOfRequiredType(Class<?> type, DependencyDescriptor descriptor) {\n\t\tfor (String beanName : this.beanDefinitionNames) {\n\t\t\ttry {\n\t\t\t\tRootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tClass<?> targetType = mbd.getTargetType();\n\t\t\t\tif (targetType != null && type.isAssignableFrom(targetType) &&\n\t\t\t\t\t\tisAutowireCandidate(beanName, mbd, descriptor, getAutowireCandidateResolver())) {\n\t\t\t\t\t// Probably a proxy interfering with target type match -> throw meaningful exception.\n\t\t\t\t\tObject beanInstance = getSingleton(beanName, false);\n\t\t\t\t\tClass<?> beanType = (beanInstance != null && beanInstance.getClass() != NullBean.class ?\n\t\t\t\t\t\t\tbeanInstance.getClass() : predictBeanType(beanName, mbd));\n\t\t\t\t\tif (beanType != null && !type.isAssignableFrom(beanType)) {\n\t\t\t\t\t\tthrow new BeanNotOfRequiredTypeException(beanName, type, beanType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Bean definition got removed while we were iterating -> ignore.\n\t\t\t}\n\t\t}\n\n\t\tif (getParentBeanFactory() instanceof DefaultListableBeanFactory parent) {\n\t\t\tparent.checkBeanNotOfRequiredType(type, descriptor);\n\t\t}\n\t}\n\n\t/**\n\t * Create an {@link Optional} wrapper for the specified dependency.\n\t */\n\tprivate Optional<?> createOptionalDependency(\n\t\t\tDependencyDescriptor descriptor, @Nullable String beanName, final Object... args) {\n\n\t\tDependencyDescriptor descriptorToUse = new NestedDependencyDescriptor(descriptor) {\n\t\t\t@Override\n\t\t\tpublic boolean isRequired() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {\n\t\t\t\treturn (!ObjectUtils.isEmpty(args) ? beanFactory.getBean(beanName, args) :\n\t\t\t\t\t\tsuper.resolveCandidate(beanName, requiredType, beanFactory));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\treturn ObjectUtils.isEmpty(args);\n\t\t\t}\n\t\t};\n\t\tObject result = doResolveDependency(descriptorToUse, beanName, null, null);\n\t\treturn (result instanceof Optional<?> optional ? optional : Optional.ofNullable(result));\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(ObjectUtils.identityToString(this));\n\t\tsb.append(\": defining beans [\");\n\t\tsb.append(StringUtils.collectionToCommaDelimitedString(this.beanDefinitionNames));\n\t\tsb.append(\"]; \");\n\t\tBeanFactory parent = getParentBeanFactory();\n\t\tif (parent == null) {\n\t\t\tsb.append(\"root of factory hierarchy\");\n\t\t}\n\t\telse {\n\t\t\tsb.append(\"parent: \").append(ObjectUtils.identityToString(parent));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Serialization support\n\t//---------------------------------------------------------------------\n\n\t@Serial\n\tprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n\t\tthrow new NotSerializableException(\"DefaultListableBeanFactory itself is not deserializable - \" +\n\t\t\t\t\"just a SerializedBeanFactoryReference is\");\n\t}\n\n\t@Serial\n\tprotected Object writeReplace() throws ObjectStreamException {\n\t\tif (this.serializationId != null) {\n\t\t\treturn new SerializedBeanFactoryReference(this.serializationId);\n\t\t}\n\t\telse {\n\t\t\tthrow new NotSerializableException(\"DefaultListableBeanFactory has no serialization id\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Minimal id reference to the factory.\n\t * Resolved to the actual factory instance on deserialization.\n\t */\n\tprivate static class SerializedBeanFactoryReference implements Serializable {\n\n\t\tprivate final String id;\n\n\t\tpublic SerializedBeanFactoryReference(String id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tprivate Object readResolve() {\n\t\t\tReference<?> ref = serializableFactories.get(this.id);\n\t\t\tif (ref != null) {\n\t\t\t\tObject result = ref.get();\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Lenient fallback: dummy factory in case of original factory not found...\n\t\t\tDefaultListableBeanFactory dummyFactory = new DefaultListableBeanFactory();\n\t\t\tdummyFactory.serializationId = this.id;\n\t\t\treturn dummyFactory;\n\t\t}\n\t}\n\n\n\t/**\n\t * A dependency descriptor marker for nested elements.\n\t */\n\tprivate static class NestedDependencyDescriptor extends DependencyDescriptor {\n\n\t\tpublic NestedDependencyDescriptor(DependencyDescriptor original) {\n\t\t\tsuper(original);\n\t\t\tincreaseNestingLevel();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\t/**\n\t * A dependency descriptor for a multi-element declaration with nested elements.\n\t */\n\tprivate static class MultiElementDescriptor extends NestedDependencyDescriptor {\n\n\t\tpublic MultiElementDescriptor(DependencyDescriptor original) {\n\t\t\tsuper(original);\n\t\t}\n\t}\n\n\n\t/**\n\t * A dependency descriptor marker for stream access to multiple elements.\n\t */\n\tprivate static class StreamDependencyDescriptor extends DependencyDescriptor {\n\n\t\tprivate final boolean ordered;\n\n\t\tpublic StreamDependencyDescriptor(DependencyDescriptor original, boolean ordered) {\n\t\t\tsuper(original);\n\t\t\tthis.ordered = ordered;\n\t\t}\n\n\t\tpublic boolean isOrdered() {\n\t\t\treturn this.ordered;\n\t\t}\n\t}\n\n\n\tprivate interface BeanObjectProvider<T> extends ObjectProvider<T>, Serializable {\n\t}\n\n\n\t/**\n\t * Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency.\n\t */\n\tprivate class DependencyObjectProvider implements BeanObjectProvider<Object> {\n\n\t\tprivate final DependencyDescriptor descriptor;\n\n\t\tprivate final boolean optional;\n\n\t\t@Nullable\n\t\tprivate final String beanName;\n\n\t\tpublic DependencyObjectProvider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\tthis.descriptor = new NestedDependencyDescriptor(descriptor);\n\t\t\tthis.optional = (this.descriptor.getDependencyType() == Optional.class);\n\t\t\tthis.beanName = beanName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() throws BeansException {\n\t\t\tif (this.optional) {\n\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject result = doResolveDependency(this.descriptor, this.beanName, null, null);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject(final Object... args) throws BeansException {\n\t\t\tif (this.optional) {\n\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName, args);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object resolveCandidate(String beanName, Class<?> requiredType, BeanFactory beanFactory) {\n\t\t\t\t\t\treturn beanFactory.getBean(beanName, args);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tObject result = doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new NoSuchBeanDefinitionException(this.descriptor.getResolvableType());\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getIfAvailable() throws BeansException {\n\t\t\ttry {\n\t\t\t\tif (this.optional) {\n\t\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tDependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean isRequired() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void ifAvailable(Consumer<Object> dependencyConsumer) throws BeansException {\n\t\t\tObject dependency = getIfAvailable();\n\t\t\tif (dependency != null) {\n\t\t\t\ttry {\n\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getIfUnique() throws BeansException {\n\t\t\tDependencyDescriptor descriptorToUse = new DependencyDescriptor(this.descriptor) {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isRequired() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean usesStandardBeanLookup() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\t@Nullable\n\t\t\t\tpublic Object resolveNotUnique(ResolvableType type, Map<String, Object> matchingBeans) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tif (this.optional) {\n\t\t\t\t\treturn createOptionalDependency(descriptorToUse, this.beanName);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t// Ignore resolved bean in non-active scope\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void ifUnique(Consumer<Object> dependencyConsumer) throws BeansException {\n\t\t\tObject dependency = getIfUnique();\n\t\t\tif (dependency != null) {\n\t\t\t\ttry {\n\t\t\t\t\tdependencyConsumer.accept(dependency);\n\t\t\t\t}\n\t\t\t\tcatch (ScopeNotActiveException ex) {\n\t\t\t\t\t// Ignore resolved bean in non-active scope, even on scoped proxy invocation\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Nullable\n\t\tprotected Object getValue() throws BeansException {\n\t\t\tif (this.optional) {\n\t\t\t\treturn createOptionalDependency(this.descriptor, this.beanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn doResolveDependency(this.descriptor, this.beanName, null, null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<Object> stream() {\n\t\t\treturn resolveStream(false);\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<Object> orderedStream() {\n\t\t\treturn resolveStream(true);\n\t\t}\n\n\t\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\t\tprivate Stream<Object> resolveStream(boolean ordered) {\n\t\t\tDependencyDescriptor descriptorToUse = new StreamDependencyDescriptor(this.descriptor, ordered);\n\t\t\tObject result = doResolveDependency(descriptorToUse, this.beanName, null, null);\n\t\t\treturn (result instanceof Stream stream ? stream : Stream.of(result));\n\t\t}\n\t}\n\n\n\t/**\n\t * Separate inner class for avoiding a hard dependency on the {@code jakarta.inject} API.\n\t * Actual {@code jakarta.inject.Provider} implementation is nested here in order to make it\n\t * invisible for Graal's introspection of DefaultListableBeanFactory's nested classes.\n\t */\n\tprivate class Jsr330Factory implements Serializable {\n\n\t\tpublic Object createDependencyProvider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\treturn new Jsr330Provider(descriptor, beanName);\n\t\t}\n\n\t\tprivate class Jsr330Provider extends DependencyObjectProvider implements Provider<Object> {\n\n\t\t\tpublic Jsr330Provider(DependencyDescriptor descriptor, @Nullable String beanName) {\n\t\t\t\tsuper(descriptor, beanName);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\t@Nullable\n\t\t\tpublic Object get() throws BeansException {\n\t\t\t\treturn getValue();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * An {@link org.springframework.core.OrderComparator.OrderSourceProvider} implementation\n\t * that is aware of the bean metadata of the instances to sort.\n\t * <p>Lookup for the method factory of an instance to sort, if any, and let the\n\t * comparator retrieve the {@link org.springframework.core.annotation.Order}\n\t * value defined on it.\n\t * <p>As of 6.1.2, this class takes the {@link AbstractBeanDefinition#ORDER_ATTRIBUTE}\n\t * attribute into account.\n\t */\n\tprivate class FactoryAwareOrderSourceProvider implements OrderComparator.OrderSourceProvider {\n\n\t\tprivate final Map<Object, String> instancesToBeanNames;\n\n\t\tpublic FactoryAwareOrderSourceProvider(Map<Object, String> instancesToBeanNames) {\n\t\t\tthis.instancesToBeanNames = instancesToBeanNames;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getOrderSource(Object obj) {\n\t\t\tString beanName = this.instancesToBeanNames.get(obj);\n\t\t\tif (beanName == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tRootBeanDefinition beanDefinition = (RootBeanDefinition) getMergedBeanDefinition(beanName);\n\t\t\t\tList<Object> sources = new ArrayList<>(3);\n\t\t\t\tObject orderAttribute = beanDefinition.getAttribute(AbstractBeanDefinition.ORDER_ATTRIBUTE);\n\t\t\t\tif (orderAttribute != null) {\n\t\t\t\t\tif (orderAttribute instanceof Integer order) {\n\t\t\t\t\t\tsources.add((Ordered) () -> order);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Invalid value type for attribute '\" +\n\t\t\t\t\t\t\t\tAbstractBeanDefinition.ORDER_ATTRIBUTE + \"': \" + orderAttribute.getClass().getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMethod factoryMethod = beanDefinition.getResolvedFactoryMethod();\n\t\t\t\tif (factoryMethod != null) {\n\t\t\t\t\tsources.add(factoryMethod);\n\t\t\t\t}\n\t\t\t\tClass<?> targetType = beanDefinition.getTargetType();\n\t\t\t\tif (targetType != null && targetType != obj.getClass()) {\n\t\t\t\t\tsources.add(targetType);\n\t\t\t\t}\n\t\t\t\treturn sources.toArray();\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate enum PreInstantiation {\n\n\t\tMAIN, BACKGROUND\n\t}\n\n}\n"
    },
    {
        "index": 3,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "aa7b4598031b7633be68cc550da19da79e370f75",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@code BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// - JVM runtime\n\t\t// - AOT processing\n\t\t// - AOT runtime\n\t\t//\n\t\t// In addition, this method supports 4 distinct use cases.\n\t\t//\n\t\t// 1) Override existing bean by-type\n\t\t// 2) Create bean by-type, with a generated name\n\t\t// 3) Override existing bean by-name\n\t\t// 4) Create bean by-name, with a provided name\n\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\tif (beanName != null) {\n\t\t\t\t// 1) We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// 2) We are creating a bean by-type, with a generated name.\n\t\t\t\t// Since NullAway will reject leaving the beanName set to null,\n\t\t\t\t// we set it to a placeholder that will be replaced later.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// 3) We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to replace bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType(),\n\t\t\t\t\t\t\t\tfield.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\t// 4) We are creating a bean by-name with the provided beanName.\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that does not implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * or {@link BeanOverrideHandler#getBeanType() type} has already been registered\n\t * in the {@code BeanFactory}.\n\t * <p>If so, register the {@link BeanOverrideHandler} and the corresponding bean\n\t * name in the {@link BeanOverrideRegistry}.\n\t * <p>The registry will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the early bean post-processing phase.\n\t * @see BeanOverrideRegistry#registerBeanOverrideHandler(BeanOverrideHandler, String)\n\t * @see WrapEarlyBeanPostProcessor#getEarlyBeanReference(Object, String)\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tif (beanName == null) {\n\t\t\t// We are wrapping an existing bean by-type.\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount == 1) {\n\t\t\t\tbeanName = candidateNames.iterator().next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\t\t\tif (primaryCandidate != null) {\n\t\t\t\t\tbeanName = primaryCandidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString message = \"Unable to select a bean to wrap: \";\n\t\t\t\t\tif (candidateCount == 0) {\n\t\t\t\t\t\tmessage += \"there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmessage += \"found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\t\t\tfield.getName(), candidateNames);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t}\n\t\telse {\n\t\t\t// We are wrapping an existing bean by-name.\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to wrap bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\tfield.getName()));\n\t\t\t}\n\t\t}\n\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"Unable to select a bean to override: found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tClass<?> producedType = beanFactory.getType(beanName, false);\n\t\t\tif (type.equals(producedType)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of bean names.\n\t * <p>Honors both <em>primary</em> and <em>fallback</em> semantics.\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#determinePrimaryCandidate(Map, Class)\n\t */\n\t@Nullable\n\tprivate static String determinePrimaryCandidate(\n\t\t\tConfigurableListableBeanFactory beanFactory, Set<String> candidateBeanNames, Class<?> beanType) {\n\n\t\tif (candidateBeanNames.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(beanType, candidateBeanNames.size(),\n\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeanNames);\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\t\tif (!beanDefinition.isFallback()) {\n\t\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\t\t// More than one non-fallback bean found among candidates.\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@code BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that does not implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@code BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tSet<String> generatedBeanNames = new HashSet<>();\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler, generatedBeanNames);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tSet<String> generatedBeanNames) {\n\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, generatedBeanNames, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, generatedBeanNames, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tSet<String> generatedBeanNames, boolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// - JVM runtime\n\t\t// - AOT processing\n\t\t// - AOT runtime\n\t\t//\n\t\t// In addition, this method supports 4 distinct use cases.\n\t\t//\n\t\t// 1) Override existing bean by-type\n\t\t// 2) Create bean by-type, with a generated name\n\t\t// 3) Override existing bean by-name\n\t\t// 4) Create bean by-name, with a provided name\n\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\t// If the generatedBeanNames set already contains the beanName that we\n\t\t\t// just found by-type, that means we are experiencing a \"phantom read\"\n\t\t\t// (i.e., we found a bean that was not previously there). Consequently,\n\t\t\t// we cannot \"override the override\", because we would lose one of the\n\t\t\t// overrides. Instead, we must create a new override for the current\n\t\t\t// handler. For example, if one handler creates an override for a SubType\n\t\t\t// and a subsequent handler creates an override for a SuperType of that\n\t\t\t// SubType, we must end up with overrides for both SuperType and SubType.\n\t\t\tif (beanName != null && !generatedBeanNames.contains(beanName)) {\n\t\t\t\t// 1) We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// 2) We are creating a bean by-type, with a generated name.\n\t\t\t\t// Since NullAway will reject leaving the beanName set to null,\n\t\t\t\t// we set it to a placeholder that will be replaced later.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// 3) We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to replace bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType(),\n\t\t\t\t\t\t\t\tfield.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\t// 4) We are creating a bean by-name with the provided beanName.\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that does not implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t\tgeneratedBeanNames.add(beanName);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * or {@link BeanOverrideHandler#getBeanType() type} has already been registered\n\t * in the {@code BeanFactory}.\n\t * <p>If so, register the {@link BeanOverrideHandler} and the corresponding bean\n\t * name in the {@link BeanOverrideRegistry}.\n\t * <p>The registry will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the early bean post-processing phase.\n\t * @see BeanOverrideRegistry#registerBeanOverrideHandler(BeanOverrideHandler, String)\n\t * @see WrapEarlyBeanPostProcessor#getEarlyBeanReference(Object, String)\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tif (beanName == null) {\n\t\t\t// We are wrapping an existing bean by-type.\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount == 1) {\n\t\t\t\tbeanName = candidateNames.iterator().next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\t\t\tif (primaryCandidate != null) {\n\t\t\t\t\tbeanName = primaryCandidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString message = \"Unable to select a bean to wrap: \";\n\t\t\t\t\tif (candidateCount == 0) {\n\t\t\t\t\t\tmessage += \"there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmessage += \"found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\t\t\tfield.getName(), candidateNames);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t}\n\t\telse {\n\t\t\t// We are wrapping an existing bean by-name.\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to wrap bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\tfield.getName()));\n\t\t\t}\n\t\t}\n\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"Unable to select a bean to override: found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tClass<?> producedType = beanFactory.getType(beanName, false);\n\t\t\tif (type.equals(producedType)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of bean names.\n\t * <p>Honors both <em>primary</em> and <em>fallback</em> semantics.\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#determinePrimaryCandidate(Map, Class)\n\t */\n\t@Nullable\n\tprivate static String determinePrimaryCandidate(\n\t\t\tConfigurableListableBeanFactory beanFactory, Set<String> candidateBeanNames, Class<?> beanType) {\n\n\t\tif (candidateBeanNames.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(beanType, candidateBeanNames.size(),\n\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeanNames);\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\t\tif (!beanDefinition.isFallback()) {\n\t\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\t\t// More than one non-fallback bean found among candidates.\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@code BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that does not implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n"
    },
    {
        "index": 4,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "03fe1f0df38090eff97f7ab2e292d881275e860d",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@link BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// 1) JVM runtime\n\t\t// 2) AOT processing\n\t\t// 3) AOT runtime\n\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\tif (beanName != null) {\n\t\t\t\t// We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We will later generate a name for the nonexistent bean, but since NullAway\n\t\t\t\t// will reject leaving the beanName set to null, we set it to a placeholder.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to replace bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType(),\n\t\t\t\t\t\t\t\tfield.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that does not implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * and {@link BeanOverrideHandler#getBeanType() type} is registered.\n\t * <p>If so, put the {@link BeanOverrideHandler} in the early tracking map.\n\t * <p>The map will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the {@link WrapEarlyBeanPostProcessor#getEarlyBeanReference}\n\t * phase.\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tif (beanName == null) {\n\t\t\t// We are wrapping an existing bean by-type.\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount == 1) {\n\t\t\t\tbeanName = candidateNames.iterator().next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\t\t\tif (primaryCandidate != null) {\n\t\t\t\t\tbeanName = primaryCandidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString message = \"Unable to select a bean to wrap: \";\n\t\t\t\t\tif (candidateCount == 0) {\n\t\t\t\t\t\tmessage += \"there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmessage += \"found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\t\t\tfield.getName(), candidateNames);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t}\n\t\telse {\n\t\t\t// We are wrapping an existing bean by-name.\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to wrap bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\tfield.getName()));\n\t\t\t}\n\t\t}\n\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"Unable to select a bean to override: found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tClass<?> producedType = beanFactory.getType(beanName, false);\n\t\t\tif (type.equals(producedType)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of bean names.\n\t * <p>Honors both <em>primary</em> and <em>fallback</em> semantics.\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#determinePrimaryCandidate(Map, Class)\n\t */\n\t@Nullable\n\tprivate static String determinePrimaryCandidate(\n\t\t\tConfigurableListableBeanFactory beanFactory, Set<String> candidateBeanNames, Class<?> beanType) {\n\n\t\tif (candidateBeanNames.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(beanType, candidateBeanNames.size(),\n\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeanNames);\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\t\tif (!beanDefinition.isFallback()) {\n\t\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\t\t// More than one non-fallback bean found among candidates.\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@link BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that does not implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@code BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// - JVM runtime\n\t\t// - AOT processing\n\t\t// - AOT runtime\n\t\t//\n\t\t// In addition, this method supports 4 distinct use cases.\n\t\t//\n\t\t// 1) Override existing bean by-type\n\t\t// 2) Create bean by-type, with a generated name\n\t\t// 3) Override existing bean by-name\n\t\t// 4) Create bean by-name, with a provided name\n\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\tif (beanName != null) {\n\t\t\t\t// 1) We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// 2) We are creating a bean by-type, with a generated name.\n\t\t\t\t// Since NullAway will reject leaving the beanName set to null,\n\t\t\t\t// we set it to a placeholder that will be replaced later.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// 3) We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to replace bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType(),\n\t\t\t\t\t\t\t\tfield.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\t// 4) We are creating a bean by-name with the provided beanName.\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that does not implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * or {@link BeanOverrideHandler#getBeanType() type} has already been registered\n\t * in the {@code BeanFactory}.\n\t * <p>If so, register the {@link BeanOverrideHandler} and the corresponding bean\n\t * name in the {@link BeanOverrideRegistry}.\n\t * <p>The registry will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the early bean post-processing phase.\n\t * @see BeanOverrideRegistry#registerBeanOverrideHandler(BeanOverrideHandler, String)\n\t * @see WrapEarlyBeanPostProcessor#getEarlyBeanReference(Object, String)\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tif (beanName == null) {\n\t\t\t// We are wrapping an existing bean by-type.\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount == 1) {\n\t\t\t\tbeanName = candidateNames.iterator().next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\t\t\tif (primaryCandidate != null) {\n\t\t\t\t\tbeanName = primaryCandidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString message = \"Unable to select a bean to wrap: \";\n\t\t\t\t\tif (candidateCount == 0) {\n\t\t\t\t\t\tmessage += \"there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmessage += \"found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\t\t\tfield.getName(), candidateNames);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t}\n\t\telse {\n\t\t\t// We are wrapping an existing bean by-name.\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to wrap bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\tfield.getName()));\n\t\t\t}\n\t\t}\n\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"Unable to select a bean to override: found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tClass<?> producedType = beanFactory.getType(beanName, false);\n\t\t\tif (type.equals(producedType)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of bean names.\n\t * <p>Honors both <em>primary</em> and <em>fallback</em> semantics.\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#determinePrimaryCandidate(Map, Class)\n\t */\n\t@Nullable\n\tprivate static String determinePrimaryCandidate(\n\t\t\tConfigurableListableBeanFactory beanFactory, Set<String> candidateBeanNames, Class<?> beanType) {\n\n\t\tif (candidateBeanNames.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(beanType, candidateBeanNames.size(),\n\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeanNames);\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\t\tif (!beanDefinition.isFallback()) {\n\t\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\t\t// More than one non-fallback bean found among candidates.\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@code BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that does not implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n"
    },
    {
        "index": 5,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "384dc2a9b812b19f5801e6b10480064efd0be1b5",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.beans.factory.support;\n\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.logging.Log;\n\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.BeanWrapperImpl;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.InvalidPropertyException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.PropertyAccessorUtils;\nimport org.springframework.beans.PropertyValue;\nimport org.springframework.beans.PropertyValues;\nimport org.springframework.beans.TypeConverter;\nimport org.springframework.beans.factory.Aware;\nimport org.springframework.beans.factory.BeanClassLoaderAware;\nimport org.springframework.beans.factory.BeanCreationException;\nimport org.springframework.beans.factory.BeanCurrentlyInCreationException;\nimport org.springframework.beans.factory.BeanDefinitionStoreException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanNameAware;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.InjectionPoint;\nimport org.springframework.beans.factory.UnsatisfiedDependencyException;\nimport org.springframework.beans.factory.config.AutowireCapableBeanFactory;\nimport org.springframework.beans.factory.config.AutowiredPropertyMarker;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.beans.factory.config.ConstructorArgumentValues;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\nimport org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor;\nimport org.springframework.beans.factory.config.TypedStringValue;\nimport org.springframework.core.DefaultParameterNameDiscoverer;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.NamedThreadLocal;\nimport org.springframework.core.ParameterNameDiscoverer;\nimport org.springframework.core.PriorityOrdered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.ReflectionUtils.MethodCallback;\nimport org.springframework.util.StringUtils;\nimport org.springframework.util.function.ThrowingSupplier;\n\n/**\n * Abstract bean factory superclass that implements default bean creation,\n * with the full capabilities specified by the {@link RootBeanDefinition} class.\n * Implements the {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory}\n * interface in addition to AbstractBeanFactory's {@link #createBean} method.\n *\n * <p>Provides bean creation (with constructor resolution), property population,\n * wiring (including autowiring), and initialization. Handles runtime bean\n * references, resolves managed collections, calls initialization methods, etc.\n * Supports autowiring constructors, properties by name, and properties by type.\n *\n * <p>The main template method to be implemented by subclasses is\n * {@link #resolveDependency(DependencyDescriptor, String, Set, TypeConverter)}, used for\n * autowiring. In case of a {@link org.springframework.beans.factory.ListableBeanFactory}\n * which is capable of searching its bean definitions, matching beans will typically be\n * implemented through such a search. Otherwise, simplified matching can be implemented.\n *\n * <p>Note that this class does <i>not</i> assume or implement bean definition\n * registry capabilities. See {@link DefaultListableBeanFactory} for an implementation\n * of the {@link org.springframework.beans.factory.ListableBeanFactory} and\n * {@link BeanDefinitionRegistry} interfaces, which represent the API and SPI\n * view of such a factory, respectively.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Mark Fisher\n * @author Costin Leau\n * @author Chris Beams\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 13.02.2004\n * @see RootBeanDefinition\n * @see DefaultListableBeanFactory\n * @see BeanDefinitionRegistry\n */\npublic abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory\n\t\timplements AutowireCapableBeanFactory {\n\n\t/** Strategy for creating bean instances. */\n\tprivate InstantiationStrategy instantiationStrategy;\n\n\t/** Resolver strategy for method parameter names. */\n\t@Nullable\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\t/** Whether to automatically try to resolve circular references between beans. */\n\tprivate boolean allowCircularReferences = true;\n\n\t/**\n\t * Whether to resort to injecting a raw bean instance in case of circular reference,\n\t * even if the injected bean eventually got wrapped.\n\t */\n\tprivate boolean allowRawInjectionDespiteWrapping = false;\n\n\t/**\n\t * Dependency types to ignore on dependency check and autowire, as Set of\n\t * Class objects: for example, String. Default is none.\n\t */\n\tprivate final Set<Class<?>> ignoredDependencyTypes = new HashSet<>();\n\n\t/**\n\t * Dependency interfaces to ignore on dependency check and autowire, as Set of\n\t * Class objects. By default, only the BeanFactory interface is ignored.\n\t */\n\tprivate final Set<Class<?>> ignoredDependencyInterfaces = new HashSet<>();\n\n\t/**\n\t * The name of the currently created bean, for implicit dependency registration\n\t * on getBean etc invocations triggered from a user-specified Supplier callback.\n\t */\n\tprivate final NamedThreadLocal<String> currentlyCreatedBean = new NamedThreadLocal<>(\"Currently created bean\");\n\n\t/** Cache of unfinished FactoryBean instances: FactoryBean name to BeanWrapper. */\n\tprivate final ConcurrentMap<String, BeanWrapper> factoryBeanInstanceCache = new ConcurrentHashMap<>();\n\n\t/** Cache of candidate factory methods per factory class. */\n\tprivate final ConcurrentMap<Class<?>, Method[]> factoryMethodCandidateCache = new ConcurrentHashMap<>();\n\n\t/** Cache of filtered PropertyDescriptors: bean Class to PropertyDescriptor array. */\n\tprivate final ConcurrentMap<Class<?>, PropertyDescriptor[]> filteredPropertyDescriptorsCache =\n\t\t\tnew ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new AbstractAutowireCapableBeanFactory.\n\t */\n\tpublic AbstractAutowireCapableBeanFactory() {\n\t\tsuper();\n\t\tignoreDependencyInterface(BeanNameAware.class);\n\t\tignoreDependencyInterface(BeanFactoryAware.class);\n\t\tignoreDependencyInterface(BeanClassLoaderAware.class);\n\t\tthis.instantiationStrategy = new CglibSubclassingInstantiationStrategy();\n\t}\n\n\t/**\n\t * Create a new AbstractAutowireCapableBeanFactory with the given parent.\n\t * @param parentBeanFactory parent bean factory, or {@code null} if none\n\t */\n\tpublic AbstractAutowireCapableBeanFactory(@Nullable BeanFactory parentBeanFactory) {\n\t\tthis();\n\t\tsetParentBeanFactory(parentBeanFactory);\n\t}\n\n\n\t/**\n\t * Set the instantiation strategy to use for creating bean instances.\n\t * Default is CglibSubclassingInstantiationStrategy.\n\t * @see CglibSubclassingInstantiationStrategy\n\t */\n\tpublic void setInstantiationStrategy(InstantiationStrategy instantiationStrategy) {\n\t\tthis.instantiationStrategy = instantiationStrategy;\n\t}\n\n\t/**\n\t * Return the instantiation strategy to use for creating bean instances.\n\t */\n\tpublic InstantiationStrategy getInstantiationStrategy() {\n\t\treturn this.instantiationStrategy;\n\t}\n\n\t/**\n\t * Set the ParameterNameDiscoverer to use for resolving method parameter\n\t * names if needed (for example, for constructor names).\n\t * <p>Default is a {@link DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the ParameterNameDiscoverer to use for resolving method parameter\n\t * names if needed.\n\t */\n\t@Nullable\n\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Set whether to allow circular references between beans - and automatically\n\t * try to resolve them.\n\t * <p>Note that circular reference resolution means that one of the involved beans\n\t * will receive a reference to another bean that is not fully initialized yet.\n\t * This can lead to subtle and not-so-subtle side effects on initialization;\n\t * it does work fine for many scenarios, though.\n\t * <p>Default is \"true\". Turn this off to throw an exception when encountering\n\t * a circular reference, disallowing them completely.\n\t * <p><b>NOTE:</b> It is generally recommended to not rely on circular references\n\t * between your beans. Refactor your application logic to have the two beans\n\t * involved delegate to a third bean that encapsulates their common logic.\n\t */\n\tpublic void setAllowCircularReferences(boolean allowCircularReferences) {\n\t\tthis.allowCircularReferences = allowCircularReferences;\n\t}\n\n\t/**\n\t * Return whether to allow circular references between beans.\n\t * @since 5.3.10\n\t * @see #setAllowCircularReferences\n\t */\n\tpublic boolean isAllowCircularReferences() {\n\t\treturn this.allowCircularReferences;\n\t}\n\n\t/**\n\t * Set whether to allow the raw injection of a bean instance into some other\n\t * bean's property, despite the injected bean eventually getting wrapped\n\t * (for example, through AOP auto-proxying).\n\t * <p>This will only be used as a last resort in case of a circular reference\n\t * that cannot be resolved otherwise: essentially, preferring a raw instance\n\t * getting injected over a failure of the entire bean wiring process.\n\t * <p>Default is \"false\", as of Spring 2.0. Turn this on to allow for non-wrapped\n\t * raw beans injected into some of your references, which was Spring 1.2's\n\t * (arguably unclean) default behavior.\n\t * <p><b>NOTE:</b> It is generally recommended to not rely on circular references\n\t * between your beans, in particular with auto-proxying involved.\n\t * @see #setAllowCircularReferences\n\t */\n\tpublic void setAllowRawInjectionDespiteWrapping(boolean allowRawInjectionDespiteWrapping) {\n\t\tthis.allowRawInjectionDespiteWrapping = allowRawInjectionDespiteWrapping;\n\t}\n\n\t/**\n\t * Return whether to allow the raw injection of a bean instance.\n\t * @since 5.3.10\n\t * @see #setAllowRawInjectionDespiteWrapping\n\t */\n\tpublic boolean isAllowRawInjectionDespiteWrapping() {\n\t\treturn this.allowRawInjectionDespiteWrapping;\n\t}\n\n\t/**\n\t * Ignore the given dependency type for autowiring:\n\t * for example, String. Default is none.\n\t */\n\tpublic void ignoreDependencyType(Class<?> type) {\n\t\tthis.ignoredDependencyTypes.add(type);\n\t}\n\n\t/**\n\t * Ignore the given dependency interface for autowiring.\n\t * <p>This will typically be used by application contexts to register\n\t * dependencies that are resolved in other ways, like BeanFactory through\n\t * BeanFactoryAware or ApplicationContext through ApplicationContextAware.\n\t * <p>By default, only the BeanFactoryAware interface is ignored.\n\t * For further types to ignore, invoke this method for each type.\n\t * @see org.springframework.beans.factory.BeanFactoryAware\n\t * @see org.springframework.context.ApplicationContextAware\n\t */\n\tpublic void ignoreDependencyInterface(Class<?> ifc) {\n\t\tthis.ignoredDependencyInterfaces.add(ifc);\n\t}\n\n\t@Override\n\tpublic void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {\n\t\tsuper.copyConfigurationFrom(otherFactory);\n\t\tif (otherFactory instanceof AbstractAutowireCapableBeanFactory otherAutowireFactory) {\n\t\t\tthis.instantiationStrategy = otherAutowireFactory.instantiationStrategy;\n\t\t\tthis.allowCircularReferences = otherAutowireFactory.allowCircularReferences;\n\t\t\tthis.ignoredDependencyTypes.addAll(otherAutowireFactory.ignoredDependencyTypes);\n\t\t\tthis.ignoredDependencyInterfaces.addAll(otherAutowireFactory.ignoredDependencyInterfaces);\n\t\t}\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Typical methods for creating and populating external bean instances\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T createBean(Class<T> beanClass) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new CreateFromClassBeanDefinition(beanClass);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tbd.allowCaching = ClassUtils.isCacheSafe(beanClass, getBeanClassLoader());\n\t\treturn (T) createBean(beanClass.getName(), bd, null);\n\t}\n\n\t@Override\n\tpublic void autowireBean(Object existingBean) {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(ClassUtils.getUserClass(existingBean));\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tbd.allowCaching = ClassUtils.isCacheSafe(bd.getBeanClass(), getBeanClassLoader());\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(bd.getBeanClass().getName(), bd, bw);\n\t}\n\n\t@Override\n\tpublic Object configureBean(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition mbd = getMergedBeanDefinition(beanName);\n\t\tRootBeanDefinition bd = null;\n\t\tif (mbd instanceof RootBeanDefinition rbd) {\n\t\t\tbd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition());\n\t\t}\n\t\tif (bd == null) {\n\t\t\tbd = new RootBeanDefinition(mbd);\n\t\t}\n\t\tif (!bd.isPrototype()) {\n\t\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\t\tbd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader());\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(beanName, bd, bw);\n\t\treturn initializeBean(beanName, existingBean, bd);\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Specialized methods for fine-grained control over the bean lifecycle\n\t//-------------------------------------------------------------------------\n\n\t@Deprecated\n\t@Override\n\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\treturn createBean(beanClass.getName(), bd, null);\n\t}\n\n\t@Override\n\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tif (bd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR) {\n\t\t\treturn autowireConstructor(beanClass.getName(), bd, null, null).getWrappedInstance();\n\t\t}\n\t\telse {\n\t\t\tObject bean = getInstantiationStrategy().instantiate(bd, null, this);\n\t\t\tpopulateBean(beanClass.getName(), bd, new BeanWrapperImpl(bean));\n\t\t\treturn bean;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)\n\t\t\tthrows BeansException {\n\n\t\tif (autowireMode == AUTOWIRE_CONSTRUCTOR) {\n\t\t\tthrow new IllegalArgumentException(\"AUTOWIRE_CONSTRUCTOR not supported for existing bean instance\");\n\t\t}\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd =\n\t\t\t\tnew RootBeanDefinition(ClassUtils.getUserClass(existingBean), autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(bd.getBeanClass().getName(), bd, bw);\n\t}\n\n\t@Override\n\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tapplyPropertyValues(beanName, bd, bw, bd.getPropertyValues());\n\t}\n\n\t@Override\n\tpublic Object initializeBean(Object existingBean, String beanName) {\n\t\treturn initializeBean(beanName, existingBean, null);\n\t}\n\n\t@Deprecated(since = \"6.1\")\n\t@Override\n\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessBeforeInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Deprecated(since = \"6.1\")\n\t@Override\n\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessAfterInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic void destroyBean(Object existingBean) {\n\t\tnew DisposableBeanAdapter(existingBean, getBeanPostProcessorCache().destructionAware).destroy();\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Delegate methods for resolving injection points\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) {\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\treturn getBean(name, descriptor.getDependencyType());\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException {\n\t\treturn resolveDependency(descriptor, requestingBeanName, null, null);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of relevant AbstractBeanFactory template methods\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Central method of this class: creates a bean instance,\n\t * populates the bean instance, applies post-processors, etc.\n\t * @see #doCreateBean\n\t */\n\t@Override\n\tprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Creating instance of bean '\" + beanName + \"'\");\n\t\t}\n\t\tRootBeanDefinition mbdToUse = mbd;\n\n\t\t// Make sure bean class is actually resolved at this point, and\n\t\t// clone the bean definition in case of a dynamically resolved Class\n\t\t// which cannot be stored in the shared merged bean definition.\n\t\tClass<?> resolvedClass = resolveBeanClass(mbd, beanName);\n\t\tif (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n\t\t\tmbdToUse = new RootBeanDefinition(mbd);\n\t\t\tmbdToUse.setBeanClass(resolvedClass);\n\t\t\ttry {\n\t\t\t\tmbdToUse.prepareMethodOverrides();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n\t\t\t\t\t\tbeanName, \"Validation of method overrides failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\tObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\n\t\t\tif (bean != null) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n\t\t\t\t\t\"BeanPostProcessor before instantiation of bean failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n\t\tcatch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n\t\t\t// A previously detected exception with proper bean creation context already,\n\t\t\t// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Actually create the specified bean. Pre-creation processing has already happened\n\t * at this point, for example, checking {@code postProcessBeforeInstantiation} callbacks.\n\t * <p>Differentiates between default bean instantiation, use of a\n\t * factory method, and autowiring a constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t * @see #instantiateBean\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t */\n\tprotected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\t// Instantiate the bean.\n\t\tBeanWrapper instanceWrapper = null;\n\t\tif (mbd.isSingleton()) {\n\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n\t\t}\n\t\tif (instanceWrapper == null) {\n\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t\t}\n\t\tObject bean = instanceWrapper.getWrappedInstance();\n\t\tClass<?> beanType = instanceWrapper.getWrappedClass();\n\t\tif (beanType != NullBean.class) {\n\t\t\tmbd.resolvedTargetType = beanType;\n\t\t}\n\n\t\t// Allow post-processors to modify the merged bean definition.\n\t\tsynchronized (mbd.postProcessingLock) {\n\t\t\tif (!mbd.postProcessed) {\n\t\t\t\ttry {\n\t\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Post-processing of merged bean definition failed\", ex);\n\t\t\t\t}\n\t\t\t\tmbd.markAsPostProcessed();\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly cache singletons to be able to resolve circular references\n\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\t\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t\t}\n\n\t\t// Initialize the bean instance.\n\t\tObject exposedObject = bean;\n\t\ttry {\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {\n\t\t\t\tthrow bce;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t\t}\n\t\t}\n\n\t\tif (earlySingletonExposure) {\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet<String> actualDependentBeans = CollectionUtils.newLinkedHashSet(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t\"] in its raw version as part of a circular reference, but has eventually been \" +\n\t\t\t\t\t\t\t\t\"wrapped. This means that said other beans do not use the final version of the \" +\n\t\t\t\t\t\t\t\t\"bean. This is often the result of over-eager type matching - consider using \" +\n\t\t\t\t\t\t\t\t\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Register bean as disposable.\n\t\ttry {\n\t\t\tregisterDisposableBeanIfNecessary(beanName, bean, mbd);\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n\t\t}\n\n\t\treturn exposedObject;\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {\n\t\tClass<?> targetType = determineTargetType(beanName, mbd, typesToMatch);\n\t\t// Apply SmartInstantiationAwareBeanPostProcessors to predict the\n\t\t// eventual type after a before-instantiation shortcut.\n\t\tif (targetType != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tboolean matchingOnlyFactoryBean = (typesToMatch.length == 1 && typesToMatch[0] == FactoryBean.class);\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\tClass<?> predicted = bp.predictBeanType(targetType, beanName);\n\t\t\t\tif (predicted != null &&\n\t\t\t\t\t\t(!matchingOnlyFactoryBean || FactoryBean.class.isAssignableFrom(predicted))) {\n\t\t\t\t\treturn predicted;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn targetType;\n\t}\n\n\t/**\n\t * Determine the target type for the given bean definition.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param typesToMatch the types to match in case of internal type matching purposes\n\t * (also signals that the returned {@code Class} will never be exposed to application code)\n\t * @return the type for the bean if determinable, or {@code null} otherwise\n\t */\n\t@Nullable\n\tprotected Class<?> determineTargetType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {\n\t\tClass<?> targetType = mbd.getTargetType();\n\t\tif (targetType == null) {\n\t\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\t\ttargetType = getTypeForFactoryMethod(beanName, mbd, typesToMatch);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetType = resolveBeanClass(mbd, beanName, typesToMatch);\n\t\t\t\tif (mbd.hasBeanClass()) {\n\t\t\t\t\ttargetType = getInstantiationStrategy().getActualBeanClass(mbd, beanName, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ObjectUtils.isEmpty(typesToMatch) || getTempClassLoader() == null) {\n\t\t\t\tmbd.resolvedTargetType = targetType;\n\t\t\t}\n\t\t}\n\t\treturn targetType;\n\t}\n\n\t/**\n\t * Determine the target type for the given bean definition which is based on\n\t * a factory method. Only called if there is no singleton instance registered\n\t * for the target bean already.\n\t * <p>This implementation determines the type matching {@link #createBean}'s\n\t * different creation strategies. As far as possible, we'll perform static\n\t * type checking to avoid creation of the target bean.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param typesToMatch the types to match in case of internal type matching purposes\n\t * (also signals that the returned {@code Class} will never be exposed to application code)\n\t * @return the type for the bean if determinable, or {@code null} otherwise\n\t * @see #createBean\n\t */\n\t@Nullable\n\tprotected Class<?> getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {\n\t\tResolvableType cachedReturnType = mbd.factoryMethodReturnType;\n\t\tif (cachedReturnType != null) {\n\t\t\treturn cachedReturnType.resolve();\n\t\t}\n\n\t\tClass<?> commonType = null;\n\t\tMethod uniqueCandidate = mbd.factoryMethodToIntrospect;\n\n\t\tif (uniqueCandidate == null) {\n\t\t\tClass<?> factoryClass;\n\t\t\tboolean isStatic = true;\n\n\t\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\t\tif (factoryBeanName != null) {\n\t\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t\t}\n\t\t\t\t// Check declared factory method return type on factory class.\n\t\t\t\tfactoryClass = getType(factoryBeanName);\n\t\t\t\tisStatic = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check declared factory method return type on bean class.\n\t\t\t\tfactoryClass = resolveBeanClass(mbd, beanName, typesToMatch);\n\t\t\t}\n\n\t\t\tif (factoryClass == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n\n\t\t\t// If all factory methods have the same return type, return that type.\n\t\t\t// Can't clearly figure out exact method due to type converting / autowiring!\n\t\t\tint minNrOfArgs =\n\t\t\t\t\t(mbd.hasConstructorArgumentValues() ? mbd.getConstructorArgumentValues().getArgumentCount() : 0);\n\t\t\tMethod[] candidates = this.factoryMethodCandidateCache.computeIfAbsent(factoryClass,\n\t\t\t\t\tclazz -> ReflectionUtils.getUniqueDeclaredMethods(clazz, ReflectionUtils.USER_DECLARED_METHODS));\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate) &&\n\t\t\t\t\t\tcandidate.getParameterCount() >= minNrOfArgs) {\n\t\t\t\t\t// Declared type variables to inspect?\n\t\t\t\t\tif (candidate.getTypeParameters().length > 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Fully resolve parameter names and argument values.\n\t\t\t\t\t\t\tConstructorArgumentValues cav = mbd.getConstructorArgumentValues();\n\t\t\t\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\t\t\t\tString[] paramNames = null;\n\t\t\t\t\t\t\tif (cav.containsNamedArgument()) {\n\t\t\t\t\t\t\t\tParameterNameDiscoverer pnd = getParameterNameDiscoverer();\n\t\t\t\t\t\t\t\tif (pnd != null) {\n\t\t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSet<ConstructorArgumentValues.ValueHolder> usedValueHolders = CollectionUtils.newHashSet(paramTypes.length);\n\t\t\t\t\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\t\t\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = cav.getArgumentValue(\n\t\t\t\t\t\t\t\t\t\ti, paramTypes[i], (paramNames != null ? paramNames[i] : null), usedValueHolders);\n\t\t\t\t\t\t\t\tif (valueHolder == null) {\n\t\t\t\t\t\t\t\t\tvalueHolder = cav.getGenericArgumentValue(null, null, usedValueHolders);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (valueHolder != null) {\n\t\t\t\t\t\t\t\t\targs[i] = valueHolder.getValue();\n\t\t\t\t\t\t\t\t\tusedValueHolders.add(valueHolder);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClass<?> returnType = AutowireUtils.resolveReturnTypeForFactoryMethod(\n\t\t\t\t\t\t\t\t\tcandidate, args, getBeanClassLoader());\n\t\t\t\t\t\t\tuniqueCandidate = (commonType == null && returnType == candidate.getReturnType() ?\n\t\t\t\t\t\t\t\t\tcandidate : null);\n\t\t\t\t\t\t\tcommonType = ClassUtils.determineCommonAncestor(returnType, commonType);\n\t\t\t\t\t\t\tif (commonType == null) {\n\t\t\t\t\t\t\t\t// Ambiguous return types found: return null to indicate \"not determinable\".\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to resolve generic return type for factory method: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuniqueCandidate = (commonType == null ? candidate : null);\n\t\t\t\t\t\tcommonType = ClassUtils.determineCommonAncestor(candidate.getReturnType(), commonType);\n\t\t\t\t\t\tif (commonType == null) {\n\t\t\t\t\t\t\t// Ambiguous return types found: return null to indicate \"not determinable\".\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmbd.factoryMethodToIntrospect = uniqueCandidate;\n\t\t\tif (commonType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Common return type found: all factory methods return same type. For a non-parameterized\n\t\t// unique candidate, cache the full type declaration context of the target factory method.\n\t\ttry {\n\t\t\tcachedReturnType = (uniqueCandidate != null ?\n\t\t\t\t\tResolvableType.forMethodReturnType(uniqueCandidate) : ResolvableType.forClass(commonType));\n\t\t\tmbd.factoryMethodReturnType = cachedReturnType;\n\t\t\treturn cachedReturnType.resolve();\n\t\t}\n\t\tcatch (LinkageError err) {\n\t\t\t// For example, a NoClassDefFoundError for a generic method return type\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to resolve type for factory method of bean '\" + beanName + \"': \" +\n\t\t\t\t\t\t(uniqueCandidate != null ? uniqueCandidate : commonType), err);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * This implementation attempts to query the FactoryBean's generic parameter metadata\n\t * if present to determine the object type. If not present, i.e. the FactoryBean is\n\t * declared as a raw type, it checks the FactoryBean's {@code getObjectType} method\n\t * on a plain instance of the FactoryBean, without bean properties applied yet.\n\t * If this doesn't return a type yet and {@code allowInit} is {@code true}, full\n\t * creation of the FactoryBean is attempted as fallback (through delegation to the\n\t * superclass implementation).\n\t * <p>The shortcut check for a FactoryBean is only applied in case of a singleton\n\t * FactoryBean. If the FactoryBean instance itself is not kept as singleton,\n\t * it will be fully created to check the type of its exposed object.\n\t */\n\t@Override\n\tprotected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit) {\n\t\tResolvableType result;\n\n\t\t// Check if the bean definition itself has defined the type with an attribute\n\t\ttry {\n\t\t\tresult = getTypeForFactoryBeanFromAttributes(mbd);\n\t\t\tif (result != ResolvableType.NONE) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\tString.valueOf(ex.getMessage()));\n\t\t}\n\n\t\t// For instance supplied beans, try the target type and bean class immediately\n\t\tif (mbd.getInstanceSupplier() != null) {\n\t\t\tresult = getFactoryBeanGeneric(mbd.targetType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = getFactoryBeanGeneric(mbd.hasBeanClass() ? ResolvableType.forClass(mbd.getBeanClass()) : null);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// Consider factory methods\n\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\tString factoryMethodName = mbd.getFactoryMethodName();\n\n\t\t// Scan the factory bean methods\n\t\tif (factoryBeanName != null) {\n\t\t\tif (factoryMethodName != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from its factory method\n\t\t\t\t// declaration without instantiating the containing bean at all.\n\t\t\t\tBeanDefinition factoryBeanDefinition = getBeanDefinition(factoryBeanName);\n\t\t\t\tClass<?> factoryBeanClass;\n\t\t\t\tif (factoryBeanDefinition instanceof AbstractBeanDefinition abstractBeanDefinition &&\n\t\t\t\t\t\tabstractBeanDefinition.hasBeanClass()) {\n\t\t\t\t\tfactoryBeanClass = abstractBeanDefinition.getBeanClass();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tRootBeanDefinition fbmbd = getMergedBeanDefinition(factoryBeanName, factoryBeanDefinition);\n\t\t\t\t\tfactoryBeanClass = determineTargetType(factoryBeanName, fbmbd);\n\t\t\t\t}\n\t\t\t\tif (factoryBeanClass != null) {\n\t\t\t\t\tresult = getTypeForFactoryBeanFromMethod(factoryBeanClass, factoryMethodName);\n\t\t\t\t\tif (result.resolve() != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If not resolvable above and the referenced factory bean doesn't exist yet,\n\t\t\t// exit here - we don't want to force the creation of another bean just to\n\t\t\t// obtain a FactoryBean's object type...\n\t\t\tif (!isBeanEligibleForMetadataCaching(factoryBeanName)) {\n\t\t\t\treturn ResolvableType.NONE;\n\t\t\t}\n\t\t}\n\n\t\t// If we're allowed, we can create the factory bean and call getObjectType() early\n\t\tif (allowInit) {\n\t\t\tFactoryBean<?> factoryBean = (mbd.isSingleton() ?\n\t\t\t\t\tgetSingletonFactoryBeanForTypeCheck(beanName, mbd) :\n\t\t\t\t\tgetNonSingletonFactoryBeanForTypeCheck(beanName, mbd));\n\t\t\tif (factoryBean != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from this early stage of the instance.\n\t\t\t\tClass<?> type = getTypeForFactoryBean(factoryBean);\n\t\t\t\tif (type != null) {\n\t\t\t\t\treturn ResolvableType.forClass(type);\n\t\t\t\t}\n\t\t\t\t// No type found for shortcut FactoryBean instance:\n\t\t\t\t// fall back to full creation of the FactoryBean instance.\n\t\t\t\treturn super.getTypeForFactoryBean(beanName, mbd, true);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryBeanName == null && mbd.hasBeanClass() && factoryMethodName != null) {\n\t\t\t// No early bean instantiation possible: determine FactoryBean's type from\n\t\t\t// static factory method signature or from class inheritance hierarchy...\n\t\t\treturn getTypeForFactoryBeanFromMethod(mbd.getBeanClass(), factoryMethodName);\n\t\t}\n\n\t\t// For regular beans, try the target type and bean class as fallback\n\t\tif (mbd.getInstanceSupplier() == null) {\n\t\t\tresult = getFactoryBeanGeneric(mbd.targetType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = getFactoryBeanGeneric(mbd.hasBeanClass() ? ResolvableType.forClass(mbd.getBeanClass()) : null);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// FactoryBean type not resolvable\n\t\treturn ResolvableType.NONE;\n\t}\n\n\t/**\n\t * Introspect the factory method signatures on the given bean class,\n\t * trying to find a common {@code FactoryBean} object type declared there.\n\t * @param beanClass the bean class to find the factory method on\n\t * @param factoryMethodName the name of the factory method\n\t * @return the common {@code FactoryBean} object type, or {@code null} if none\n\t */\n\tprivate ResolvableType getTypeForFactoryBeanFromMethod(Class<?> beanClass, String factoryMethodName) {\n\t\t// CGLIB subclass methods hide generic parameters; look at the original user class.\n\t\tClass<?> factoryBeanClass = ClassUtils.getUserClass(beanClass);\n\t\tFactoryBeanMethodTypeFinder finder = new FactoryBeanMethodTypeFinder(factoryMethodName);\n\t\tReflectionUtils.doWithMethods(factoryBeanClass, finder, ReflectionUtils.USER_DECLARED_METHODS);\n\t\treturn finder.getResult();\n\t}\n\n\t/**\n\t * Obtain a reference for early access to the specified bean,\n\t * typically for the purpose of resolving a circular reference.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param bean the raw bean instance\n\t * @return the object to expose as bean reference\n\t */\n\tprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\texposedObject = bp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation methods\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Obtain a \"shortcut\" singleton FactoryBean instance to use for a\n\t * {@code getObjectType()} call, without full initialization of the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the FactoryBean instance, or {@code null} to indicate\n\t * that we couldn't obtain a shortcut FactoryBean instance\n\t */\n\t@Nullable\n\tprivate FactoryBean<?> getSingletonFactoryBeanForTypeCheck(String beanName, RootBeanDefinition mbd) {\n\t\tBeanWrapper bw = this.factoryBeanInstanceCache.get(beanName);\n\t\tif (bw != null) {\n\t\t\treturn (FactoryBean<?>) bw.getWrappedInstance();\n\t\t}\n\t\tObject beanInstance = getSingleton(beanName, false);\n\t\tif (beanInstance instanceof FactoryBean<?> factoryBean) {\n\t\t\treturn factoryBean;\n\t\t}\n\t\tif (isSingletonCurrentlyInCreation(beanName) ||\n\t\t\t\t(mbd.getFactoryBeanName() != null && isSingletonCurrentlyInCreation(mbd.getFactoryBeanName()))) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject instance;\n\t\ttry {\n\t\t\t// Mark this bean as currently in creation, even if just partially.\n\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\tinstance = resolveBeforeInstantiation(beanName, mbd);\n\t\t\tif (instance == null) {\n\t\t\t\tbw = createBeanInstance(beanName, mbd, null);\n\t\t\t\tinstance = bw.getWrappedInstance();\n\t\t\t\tthis.factoryBeanInstanceCache.put(beanName, bw);\n\t\t\t}\n\t\t}\n\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t// Don't swallow, probably misconfiguration...\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\t// Don't swallow a linkage error since it contains a full stacktrace on\n\t\t\t// first occurrence... and just a plain NoClassDefFoundError afterwards.\n\t\t\tif (ex.contains(LinkageError.class)) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\t// Instantiation failure, maybe too early...\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Bean creation exception on singleton FactoryBean type check: \" + ex);\n\t\t\t}\n\t\t\tonSuppressedException(ex);\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\t// Finished partial creation of this bean.\n\t\t\tafterSingletonCreation(beanName);\n\t\t}\n\n\t\treturn getFactoryBean(beanName, instance);\n\t}\n\n\t/**\n\t * Obtain a \"shortcut\" non-singleton FactoryBean instance to use for a\n\t * {@code getObjectType()} call, without full initialization of the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the FactoryBean instance, or {@code null} to indicate\n\t * that we couldn't obtain a shortcut FactoryBean instance\n\t */\n\t@Nullable\n\tprivate FactoryBean<?> getNonSingletonFactoryBeanForTypeCheck(String beanName, RootBeanDefinition mbd) {\n\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject instance;\n\t\ttry {\n\t\t\t// Mark this bean as currently in creation, even if just partially.\n\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\tinstance = resolveBeforeInstantiation(beanName, mbd);\n\t\t\tif (instance == null) {\n\t\t\t\tBeanWrapper bw = createBeanInstance(beanName, mbd, null);\n\t\t\t\tinstance = bw.getWrappedInstance();\n\t\t\t}\n\t\t}\n\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t// Don't swallow, probably misconfiguration...\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\t// Instantiation failure, maybe too early...\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Bean creation exception on non-singleton FactoryBean type check: \" + ex);\n\t\t\t}\n\t\t\tonSuppressedException(ex);\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\t// Finished partial creation of this bean.\n\t\t\tafterPrototypeCreation(beanName);\n\t\t}\n\n\t\treturn getFactoryBean(beanName, instance);\n\t}\n\n\t/**\n\t * Apply MergedBeanDefinitionPostProcessors to the specified bean definition,\n\t * invoking their {@code postProcessMergedBeanDefinition} methods.\n\t * @param mbd the merged bean definition for the bean\n\t * @param beanType the actual type of the managed bean instance\n\t * @param beanName the name of the bean\n\t * @see MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition\n\t */\n\tprotected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {\n\t\tfor (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {\n\t\t\tprocessor.postProcessMergedBeanDefinition(mbd, beanType, beanName);\n\t\t}\n\t}\n\n\t/**\n\t * Apply before-instantiation post-processors, resolving whether there is a\n\t * before-instantiation shortcut for the specified bean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the shortcut-determined bean instance, or {@code null} if none\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\t@Nullable\n\tprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n\t\tObject bean = null;\n\t\tif (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n\t\t\t// Make sure bean class is actually resolved at this point.\n\t\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\t\tClass<?> targetType = determineTargetType(beanName, mbd);\n\t\t\t\tif (targetType != null) {\n\t\t\t\t\tbean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n\t\t\t\t\tif (bean != null) {\n\t\t\t\t\t\tbean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmbd.beforeInstantiationResolved = (bean != null);\n\t\t}\n\t\treturn bean;\n\t}\n\n\t/**\n\t * Apply InstantiationAwareBeanPostProcessors to the specified bean definition\n\t * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods.\n\t * <p>Any returned object will be used as the bean instead of actually instantiating\n\t * the target bean. A {@code null} return value from the post-processor will\n\t * result in the target bean being instantiated.\n\t * @param beanClass the class of the bean to be instantiated\n\t * @param beanName the name of the bean\n\t * @return the bean object to use instead of a default instance of the target bean, or {@code null}\n\t * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\t */\n\t@Nullable\n\tprotected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\tObject result = bp.postProcessBeforeInstantiation(beanClass, beanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Create a new instance for the specified bean, using an appropriate instantiation strategy:\n\t * factory method, constructor autowiring, or simple instantiation.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a BeanWrapper for the new instance\n\t * @see #obtainFromSupplier\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t * @see #instantiateBean\n\t */\n\tprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n\t\t// Make sure bean class is actually resolved at this point.\n\t\tClass<?> beanClass = resolveBeanClass(mbd, beanName);\n\n\t\tif (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n\t\t}\n\n\t\tif (args == null) {\n\t\t\tSupplier<?> instanceSupplier = mbd.getInstanceSupplier();\n\t\t\tif (instanceSupplier != null) {\n\t\t\t\treturn obtainFromSupplier(instanceSupplier, beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\treturn instantiateUsingFactoryMethod(beanName, mbd, args);\n\t\t}\n\n\t\t// Shortcut when re-creating the same bean...\n\t\tboolean resolved = false;\n\t\tboolean autowireNecessary = false;\n\t\tif (args == null) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tif (mbd.resolvedConstructorOrFactoryMethod != null) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tautowireNecessary = mbd.constructorArgumentsResolved;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (resolved) {\n\t\t\tif (autowireNecessary) {\n\t\t\t\treturn autowireConstructor(beanName, mbd, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn instantiateBean(beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\t// Candidate constructors for autowiring?\n\t\tConstructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n\t\tif (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||\n\t\t\t\tmbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, args);\n\t\t}\n\n\t\t// Preferred constructors for default construction?\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n\n\t\t// No special handling: simply use no-arg constructor.\n\t\treturn instantiateBean(beanName, mbd);\n\t}\n\n\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @return a BeanWrapper for the new instance\n\t */\n\tprivate BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd) {\n\t\tString outerBean = this.currentlyCreatedBean.get();\n\t\tthis.currentlyCreatedBean.set(beanName);\n\t\tObject instance;\n\n\t\ttry {\n\t\t\tinstance = obtainInstanceFromSupplier(supplier, beanName, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeansException beansException) {\n\t\t\t\tthrow beansException;\n\t\t\t}\n\t\t\tthrow new BeanCreationException(beanName, \"Instantiation of supplied bean failed\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (outerBean != null) {\n\t\t\t\tthis.currentlyCreatedBean.set(outerBean);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.currentlyCreatedBean.remove();\n\t\t\t}\n\t\t}\n\n\t\tif (instance == null) {\n\t\t\tinstance = new NullBean();\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(instance);\n\t\tinitBeanWrapper(bw);\n\t\treturn bw;\n\t}\n\n\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @param mbd the bean definition for the bean\n\t * @return the bean instance (possibly {@code null})\n\t * @since 6.0.7\n\t */\n\t@Nullable\n\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)\n\t\t\tthrows Exception {\n\n\t\tif (supplier instanceof ThrowingSupplier<?> throwingSupplier) {\n\t\t\treturn throwingSupplier.getWithException();\n\t\t}\n\t\treturn supplier.get();\n\t}\n\n\t/**\n\t * Overridden in order to implicitly register the currently created bean as\n\t * dependent on further beans getting programmatically retrieved during a\n\t * {@link Supplier} callback.\n\t * @since 5.0\n\t * @see #obtainFromSupplier\n\t */\n\t@Override\n\tprotected Object getObjectForBeanInstance(\n\t\t\tObject beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {\n\n\t\tString currentlyCreatedBean = this.currentlyCreatedBean.get();\n\t\tif (currentlyCreatedBean != null) {\n\t\t\tregisterDependentBean(beanName, currentlyCreatedBean);\n\t\t}\n\n\t\treturn super.getObjectForBeanInstance(beanInstance, name, beanName, mbd);\n\t}\n\n\t/**\n\t * Determine candidate constructors to use for the given bean, checking all registered\n\t * {@link SmartInstantiationAwareBeanPostProcessor SmartInstantiationAwareBeanPostProcessors}.\n\t * @param beanClass the raw class of the bean\n\t * @param beanName the name of the bean\n\t * @return the candidate constructors, or {@code null} if none specified\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors\n\t */\n\t@Nullable\n\tprotected Constructor<?>[] determineConstructorsFromBeanPostProcessors(@Nullable Class<?> beanClass, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tif (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\tConstructor<?>[] ctors = bp.determineCandidateConstructors(beanClass, beanName);\n\t\t\t\tif (ctors != null) {\n\t\t\t\t\treturn ctors;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Instantiate the given bean using its default constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return a BeanWrapper for the new instance\n\t */\n\tprotected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {\n\t\ttry {\n\t\t\tObject beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this);\n\t\t\tBeanWrapper bw = new BeanWrapperImpl(beanInstance);\n\t\t\tinitBeanWrapper(bw);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate the bean using a named factory method. The method may be static, if the\n\t * mbd parameter specifies a class, rather than a factoryBean, or an instance variable\n\t * on a factory object itself configured using Dependency Injection.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t * @see #getBean(String, Object[])\n\t */\n\tprotected BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);\n\t}\n\n\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param ctors the chosen candidate constructors\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */\n\tprotected BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);\n\t}\n\n\t/**\n\t * Populate the bean instance in the given BeanWrapper with the property values\n\t * from the bean definition.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param bw the BeanWrapper with bean instance\n\t */\n\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\tif (bw == null) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (bw.getWrappedClass().isRecord()) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to a record\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for records since they are immutable.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\tpvs = newPvs;\n\t\t}\n\t\tif (hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tPropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n\t\t\t\tif (pvsToUse == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpvs = pvsToUse;\n\t\t\t}\n\t\t}\n\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\t\tif (needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t}\n\n\t\tif (pvs != null) {\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}\n\n\t/**\n\t * Fill in any missing property values with references to\n\t * other beans in this factory if autowire is set to \"byName\".\n\t * @param beanName the name of the bean we're wiring up.\n\t * Useful for debugging messages; not used functionally.\n\t * @param mbd bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */\n\tprotected void autowireByName(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\tif (containsBean(propertyName)) {\n\t\t\t\tObject bean = getBean(propertyName);\n\t\t\t\tpvs.add(propertyName, bean);\n\t\t\t\tregisterDependentBean(propertyName, beanName);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Added autowiring by name from bean name '\" + beanName +\n\t\t\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\"' by name: no matching bean found\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Abstract method defining \"autowire by type\" (bean properties by type) behavior.\n\t * <p>This is like PicoContainer default, in which there must be exactly one bean\n\t * of the property type in the bean factory. This makes bean factories simple to\n\t * configure for small namespaces, but doesn't work as well as standard Spring\n\t * behavior for bigger applications.\n\t * @param beanName the name of the bean to autowire by type\n\t * @param mbd the merged bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */\n\tprotected void autowireByType(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(propertyNames.length * 2);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\ttry {\n\t\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\t\t// Don't try autowiring by type for type Object: never makes sense,\n\t\t\t\t// even if it technically is an unsatisfied, non-simple property.\n\t\t\t\tif (Object.class != pd.getPropertyType()) {\n\t\t\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t\t// Do not allow eager init for type matching in case of a prioritized post-processor.\n\t\t\t\t\tboolean eager = !(bw.getWrappedInstance() instanceof PriorityOrdered);\n\t\t\t\t\tDependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);\n\t\t\t\t\tObject autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);\n\t\t\t\t\tif (autowiredArgument != null) {\n\t\t\t\t\t\tpvs.add(propertyName, autowiredArgument);\n\t\t\t\t\t}\n\t\t\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\t\t\tregisterDependentBean(autowiredBeanName, beanName);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Autowiring by type from bean name '\" + beanName + \"' via property '\" +\n\t\t\t\t\t\t\t\t\tpropertyName + \"' to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tautowiredBeanNames.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Return an array of non-simple bean properties that are unsatisfied.\n\t * These are probably unsatisfied references to other beans in the\n\t * factory. Does not include simple properties like primitives or Strings.\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param bw the BeanWrapper the bean was created with\n\t * @return an array of bean property names\n\t * @see org.springframework.beans.BeanUtils#isSimpleProperty\n\t */\n\tprotected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {\n\t\tSet<String> result = new TreeSet<>();\n\t\tPropertyValues pvs = mbd.getPropertyValues();\n\t\tPropertyDescriptor[] pds = bw.getPropertyDescriptors();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && !isExcludedFromDependencyCheck(pd) && !pvs.contains(pd.getName()) &&\n\t\t\t\t\t!BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n\t\t\t\tresult.add(pd.getName());\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(result);\n\t}\n\n\t/**\n\t * Extract a filtered set of PropertyDescriptors from the given BeanWrapper,\n\t * excluding ignored dependency types or properties defined on ignored dependency interfaces.\n\t * @param bw the BeanWrapper the bean was created with\n\t * @param cache whether to cache filtered PropertyDescriptors for the given bean Class\n\t * @return the filtered PropertyDescriptors\n\t * @see #isExcludedFromDependencyCheck\n\t * @see #filterPropertyDescriptorsForDependencyCheck(org.springframework.beans.BeanWrapper)\n\t */\n\tprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache) {\n\t\tPropertyDescriptor[] filtered = this.filteredPropertyDescriptorsCache.get(bw.getWrappedClass());\n\t\tif (filtered == null) {\n\t\t\tfiltered = filterPropertyDescriptorsForDependencyCheck(bw);\n\t\t\tif (cache) {\n\t\t\t\tPropertyDescriptor[] existing =\n\t\t\t\t\t\tthis.filteredPropertyDescriptorsCache.putIfAbsent(bw.getWrappedClass(), filtered);\n\t\t\t\tif (existing != null) {\n\t\t\t\t\tfiltered = existing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}\n\n\t/**\n\t * Extract a filtered set of PropertyDescriptors from the given BeanWrapper,\n\t * excluding ignored dependency types or properties defined on ignored dependency interfaces.\n\t * @param bw the BeanWrapper the bean was created with\n\t * @return the filtered PropertyDescriptors\n\t * @see #isExcludedFromDependencyCheck\n\t */\n\tprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) {\n\t\tList<PropertyDescriptor> pds = new ArrayList<>(Arrays.asList(bw.getPropertyDescriptors()));\n\t\tpds.removeIf(this::isExcludedFromDependencyCheck);\n\t\treturn pds.toArray(new PropertyDescriptor[0]);\n\t}\n\n\t/**\n\t * Determine whether the given bean property is excluded from dependency checks.\n\t * <p>This implementation excludes properties defined by CGLIB and\n\t * properties whose type matches an ignored dependency type or which\n\t * are defined by an ignored dependency interface.\n\t * @param pd the PropertyDescriptor of the bean property\n\t * @return whether the bean property is excluded\n\t * @see #ignoreDependencyType(Class)\n\t * @see #ignoreDependencyInterface(Class)\n\t */\n\tprotected boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {\n\t\treturn (AutowireUtils.isExcludedFromDependencyCheck(pd) ||\n\t\t\t\tthis.ignoredDependencyTypes.contains(pd.getPropertyType()) ||\n\t\t\t\tAutowireUtils.isSetterDefinedInInterface(pd, this.ignoredDependencyInterfaces));\n\t}\n\n\t/**\n\t * Perform a dependency check that all properties exposed have been set,\n\t * if desired. Dependency checks can be objects (collaborating beans),\n\t * simple (primitives and String), or all (both).\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param pds the relevant property descriptors for the target bean\n\t * @param pvs the property values to be applied to the bean\n\t * @see #isExcludedFromDependencyCheck(java.beans.PropertyDescriptor)\n\t */\n\tprotected void checkDependencies(\n\t\t\tString beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)\n\t\t\tthrows UnsatisfiedDependencyException {\n\n\t\tint dependencyCheck = mbd.getDependencyCheck();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && (pvs == null || !pvs.contains(pd.getName()))) {\n\t\t\t\tboolean isSimple = BeanUtils.isSimpleProperty(pd.getPropertyType());\n\t\t\t\tboolean unsatisfied = (dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_ALL) ||\n\t\t\t\t\t\t(isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_SIMPLE) ||\n\t\t\t\t\t\t(!isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_OBJECTS);\n\t\t\t\tif (unsatisfied) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, pd.getName(),\n\t\t\t\t\t\t\t\"Set this property value or disable dependency checking for this bean.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Apply the given property values, resolving any runtime references\n\t * to other beans in this bean factory. Must use deep copy, so we\n\t * don't permanently modify this property.\n\t * @param beanName the bean name passed for better exception information\n\t * @param mbd the merged bean definition\n\t * @param bw the BeanWrapper wrapping the target object\n\t * @param pvs the new property values\n\t */\n\tprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n\t\tif (pvs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMutablePropertyValues mpvs = null;\n\t\tList<PropertyValue> original;\n\n\t\tif (pvs instanceof MutablePropertyValues _mpvs) {\n\t\t\tmpvs = _mpvs;\n\t\t\tif (mpvs.isConverted()) {\n\t\t\t\t// Shortcut: use the pre-converted values as-is.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValues(mpvs);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\toriginal = mpvs.getPropertyValueList();\n\t\t}\n\t\telse {\n\t\t\toriginal = Arrays.asList(pvs.getPropertyValues());\n\t\t}\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\t\tBeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n\t\t// Create a deep copy, resolving any references for values.\n\t\tList<PropertyValue> deepCopy = new ArrayList<>(original.size());\n\t\tboolean resolveNecessary = false;\n\t\tfor (PropertyValue pv : original) {\n\t\t\tif (pv.isConverted()) {\n\t\t\t\tdeepCopy.add(pv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString propertyName = pv.getName();\n\t\t\t\tObject originalValue = pv.getValue();\n\t\t\t\tif (originalValue == AutowiredPropertyMarker.INSTANCE) {\n\t\t\t\t\tMethod writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();\n\t\t\t\t\tif (writeMethod == null) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Autowire marker for property without write method: \" + pv);\n\t\t\t\t\t}\n\t\t\t\t\toriginalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true);\n\t\t\t\t}\n\t\t\t\tObject resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n\t\t\t\tObject convertedValue = resolvedValue;\n\t\t\t\tboolean convertible = isConvertibleProperty(propertyName, bw);\n\t\t\t\tif (convertible) {\n\t\t\t\t\tconvertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n\t\t\t\t}\n\t\t\t\t// Possibly store converted value in merged bean definition,\n\t\t\t\t// in order to avoid re-conversion for every created bean instance.\n\t\t\t\tif (resolvedValue == originalValue) {\n\t\t\t\t\tif (convertible) {\n\t\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse if (convertible && originalValue instanceof TypedStringValue typedStringValue &&\n\t\t\t\t\t\t!typedStringValue.isDynamic() &&\n\t\t\t\t\t\t!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveNecessary = true;\n\t\t\t\t\tdeepCopy.add(new PropertyValue(pv, convertedValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mpvs != null && !resolveNecessary) {\n\t\t\tmpvs.setConverted();\n\t\t}\n\n\t\t// Set our (possibly massaged) deep copy.\n\t\ttry {\n\t\t\tbw.setPropertyValues(new MutablePropertyValues(deepCopy));\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the factory should cache a converted value for the given property.\n\t */\n\tprivate boolean isConvertibleProperty(String propertyName, BeanWrapper bw) {\n\t\ttry {\n\t\t\treturn !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName) &&\n\t\t\t\t\tBeanUtils.hasUniqueWriteMethod(bw.getPropertyDescriptor(propertyName));\n\t\t}\n\t\tcatch (InvalidPropertyException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the given value for the specified target property.\n\t */\n\t@Nullable\n\tprivate Object convertForProperty(\n\t\t\t@Nullable Object value, String propertyName, BeanWrapper bw, TypeConverter converter) {\n\n\t\tif (converter instanceof BeanWrapperImpl beanWrapper) {\n\t\t\treturn beanWrapper.convertForProperty(value, propertyName);\n\t\t}\n\t\telse {\n\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\treturn converter.convertIfNecessary(value, pd.getPropertyType(), methodParam);\n\t\t}\n\t}\n\n\n\t/**\n\t * Initialize the given bean instance, applying factory callbacks\n\t * as well as init methods and bean post processors.\n\t * <p>Called from {@link #createBean} for traditionally defined beans,\n\t * and from {@link #initializeBean} for existing bean instances.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @return the initialized bean instance (potentially wrapped)\n\t * @see BeanNameAware\n\t * @see BeanClassLoaderAware\n\t * @see BeanFactoryAware\n\t * @see #applyBeanPostProcessorsBeforeInitialization\n\t * @see #invokeInitMethods\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n\t\tinvokeAwareMethods(beanName, bean);\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}\n\n\tprivate void invokeAwareMethods(String beanName, Object bean) {\n\t\tif (bean instanceof Aware) {\n\t\t\tif (bean instanceof BeanNameAware beanNameAware) {\n\t\t\t\tbeanNameAware.setBeanName(beanName);\n\t\t\t}\n\t\t\tif (bean instanceof BeanClassLoaderAware beanClassLoaderAware) {\n\t\t\t\tClassLoader bcl = getBeanClassLoader();\n\t\t\t\tif (bcl != null) {\n\t\t\t\t\tbeanClassLoaderAware.setBeanClassLoader(bcl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bean instanceof BeanFactoryAware beanFactoryAware) {\n\t\t\t\tbeanFactoryAware.setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Give a bean a chance to initialize itself after all its properties are set,\n\t * and a chance to know about its owning bean factory (this object).\n\t * <p>This means checking whether the bean implements {@link InitializingBean}\n\t * or defines any custom init methods, and invoking the necessary callback(s)\n\t * if it does.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the merged bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @throws Throwable if thrown by init methods or by the invocation process\n\t * @see #invokeCustomInitMethod\n\t */\n\tprotected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)\n\t\t\tthrows Throwable {\n\n\t\tboolean isInitializingBean = (bean instanceof InitializingBean);\n\t\tif (isInitializingBean && (mbd == null || !mbd.hasAnyExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\t((InitializingBean) bean).afterPropertiesSet();\n\t\t}\n\n\t\tif (mbd != null && bean.getClass() != NullBean.class) {\n\t\t\tString[] initMethodNames = mbd.getInitMethodNames();\n\t\t\tif (initMethodNames != null) {\n\t\t\t\tfor (String initMethodName : initMethodNames) {\n\t\t\t\t\tif (StringUtils.hasLength(initMethodName) &&\n\t\t\t\t\t\t\t!(isInitializingBean && \"afterPropertiesSet\".equals(initMethodName)) &&\n\t\t\t\t\t\t\t!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {\n\t\t\t\t\t\tinvokeCustomInitMethod(beanName, bean, mbd, initMethodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the specified custom init method on the given bean.\n\t * <p>Called by {@link #invokeInitMethods(String, Object, RootBeanDefinition)}.\n\t * <p>Can be overridden in subclasses for custom resolution of init methods\n\t * with arguments.\n\t * @see #invokeInitMethods\n\t */\n\tprotected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)\n\t\t\tthrows Throwable {\n\n\t\tClass<?> beanClass = bean.getClass();\n\t\tMethodDescriptor descriptor = MethodDescriptor.create(beanName, beanClass, initMethodName);\n\t\tString methodName = descriptor.methodName();\n\n\t\tMethod initMethod = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\tBeanUtils.findMethod(descriptor.declaringClass(), methodName) :\n\t\t\t\tClassUtils.getMethodIfAvailable(beanClass, methodName));\n\n\t\tif (initMethod == null) {\n\t\t\tif (mbd.isEnforceInitMethod()) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\"Could not find an init method named '\" +\n\t\t\t\t\t\tmethodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No default init method named '\" + methodName +\n\t\t\t\t\t\t\t\"' found on bean with name '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t\t// Ignore non-existent default lifecycle methods.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking init method '\" + methodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t}\n\t\tMethod methodToInvoke = ClassUtils.getPubliclyAccessibleMethodIfPossible(initMethod, beanClass);\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(methodToInvoke);\n\t\t\tmethodToInvoke.invoke(bean);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t}\n\n\n\t/**\n\t * Applies the {@code postProcessAfterInitialization} callback of all\n\t * registered BeanPostProcessors, giving them a chance to post-process the\n\t * object obtained from FactoryBeans (for example, to auto-proxy them).\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\t@Override\n\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n\t\treturn applyBeanPostProcessorsAfterInitialization(object, beanName);\n\t}\n\n\t/**\n\t * Overridden to clear FactoryBean instance cache as well.\n\t */\n\t@Override\n\tprotected void removeSingleton(String beanName) {\n\t\tsuper.removeSingleton(beanName);\n\t\tthis.factoryBeanInstanceCache.remove(beanName);\n\t}\n\n\t/**\n\t * Overridden to clear FactoryBean instance cache as well.\n\t */\n\t@Override\n\tprotected void clearSingletonCache() {\n\t\tsuper.clearSingletonCache();\n\t\tthis.factoryBeanInstanceCache.clear();\n\t}\n\n\t/**\n\t * Expose the logger to collaborating delegates.\n\t * @since 5.0.7\n\t */\n\tLog getLogger() {\n\t\treturn logger;\n\t}\n\n\n\t/**\n\t * {@link RootBeanDefinition} subclass for {@code #createBean} calls with\n\t * flexible selection of a Kotlin primary / single public / single non-public\n\t * constructor candidate in addition to the default constructor.\n\t * @see BeanUtils#getResolvableConstructor(Class)\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class CreateFromClassBeanDefinition extends RootBeanDefinition {\n\n\t\tpublic CreateFromClassBeanDefinition(Class<?> beanClass) {\n\t\t\tsuper(beanClass);\n\t\t}\n\n\t\tpublic CreateFromClassBeanDefinition(CreateFromClassBeanDefinition original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Constructor<?>[] getPreferredConstructors() {\n\t\t\tConstructor<?>[] fromAttribute = super.getPreferredConstructors();\n\t\t\tif (fromAttribute != null) {\n\t\t\t\treturn fromAttribute;\n\t\t\t}\n\t\t\treturn ConstructorResolver.determinePreferredConstructors(getBeanClass());\n\t\t}\n\n\t\t@Override\n\t\tpublic RootBeanDefinition cloneBeanDefinition() {\n\t\t\treturn new CreateFromClassBeanDefinition(this);\n\t\t}\n\t}\n\n\n\t/**\n\t * Special DependencyDescriptor variant for Spring's good old autowire=\"byType\" mode.\n\t * Always optional; never considering the parameter name for choosing a primary candidate.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class AutowireByTypeDependencyDescriptor extends DependencyDescriptor {\n\n\t\tpublic AutowireByTypeDependencyDescriptor(MethodParameter methodParameter, boolean eager) {\n\t\t\tsuper(methodParameter, false, eager);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic String getDependencyName() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodCallback} used to find {@link FactoryBean} type information.\n\t */\n\tprivate static class FactoryBeanMethodTypeFinder implements MethodCallback {\n\n\t\tprivate final String factoryMethodName;\n\n\t\tprivate ResolvableType result = ResolvableType.NONE;\n\n\t\tFactoryBeanMethodTypeFinder(String factoryMethodName) {\n\t\t\tthis.factoryMethodName = factoryMethodName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void doWith(Method method) throws IllegalArgumentException {\n\t\t\tif (isFactoryBeanMethod(method)) {\n\t\t\t\tResolvableType returnType = ResolvableType.forMethodReturnType(method);\n\t\t\t\tResolvableType candidate = returnType.as(FactoryBean.class).getGeneric();\n\t\t\t\tif (this.result == ResolvableType.NONE) {\n\t\t\t\t\tthis.result = candidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tClass<?> resolvedResult = this.result.resolve();\n\t\t\t\t\tClass<?> commonAncestor = ClassUtils.determineCommonAncestor(candidate.resolve(), resolvedResult);\n\t\t\t\t\tif (!ObjectUtils.nullSafeEquals(resolvedResult, commonAncestor)) {\n\t\t\t\t\t\tthis.result = ResolvableType.forClass(commonAncestor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isFactoryBeanMethod(Method method) {\n\t\t\treturn (method.getName().equals(this.factoryMethodName) &&\n\t\t\t\t\tFactoryBean.class.isAssignableFrom(method.getReturnType()));\n\t\t}\n\n\t\tResolvableType getResult() {\n\t\t\tClass<?> resolved = this.result.resolve();\n\t\t\tboolean foundResult = resolved != null && resolved != Object.class;\n\t\t\treturn (foundResult ? this.result : ResolvableType.NONE);\n\t\t}\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.beans.factory.support;\n\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.logging.Log;\n\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.BeanWrapperImpl;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.InvalidPropertyException;\nimport org.springframework.beans.MutablePropertyValues;\nimport org.springframework.beans.PropertyAccessorUtils;\nimport org.springframework.beans.PropertyValue;\nimport org.springframework.beans.PropertyValues;\nimport org.springframework.beans.TypeConverter;\nimport org.springframework.beans.factory.Aware;\nimport org.springframework.beans.factory.BeanClassLoaderAware;\nimport org.springframework.beans.factory.BeanCreationException;\nimport org.springframework.beans.factory.BeanCurrentlyInCreationException;\nimport org.springframework.beans.factory.BeanDefinitionStoreException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanNameAware;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.InjectionPoint;\nimport org.springframework.beans.factory.UnsatisfiedDependencyException;\nimport org.springframework.beans.factory.config.AutowireCapableBeanFactory;\nimport org.springframework.beans.factory.config.AutowiredPropertyMarker;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.beans.factory.config.ConstructorArgumentValues;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\nimport org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor;\nimport org.springframework.beans.factory.config.TypedStringValue;\nimport org.springframework.core.DefaultParameterNameDiscoverer;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.NamedThreadLocal;\nimport org.springframework.core.ParameterNameDiscoverer;\nimport org.springframework.core.PriorityOrdered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.ReflectionUtils.MethodCallback;\nimport org.springframework.util.StringUtils;\nimport org.springframework.util.function.ThrowingSupplier;\n\n/**\n * Abstract bean factory superclass that implements default bean creation,\n * with the full capabilities specified by the {@link RootBeanDefinition} class.\n * Implements the {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory}\n * interface in addition to AbstractBeanFactory's {@link #createBean} method.\n *\n * <p>Provides bean creation (with constructor resolution), property population,\n * wiring (including autowiring), and initialization. Handles runtime bean\n * references, resolves managed collections, calls initialization methods, etc.\n * Supports autowiring constructors, properties by name, and properties by type.\n *\n * <p>The main template method to be implemented by subclasses is\n * {@link #resolveDependency(DependencyDescriptor, String, Set, TypeConverter)}, used for\n * autowiring. In case of a {@link org.springframework.beans.factory.ListableBeanFactory}\n * which is capable of searching its bean definitions, matching beans will typically be\n * implemented through such a search. Otherwise, simplified matching can be implemented.\n *\n * <p>Note that this class does <i>not</i> assume or implement bean definition\n * registry capabilities. See {@link DefaultListableBeanFactory} for an implementation\n * of the {@link org.springframework.beans.factory.ListableBeanFactory} and\n * {@link BeanDefinitionRegistry} interfaces, which represent the API and SPI\n * view of such a factory, respectively.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Mark Fisher\n * @author Costin Leau\n * @author Chris Beams\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 13.02.2004\n * @see RootBeanDefinition\n * @see DefaultListableBeanFactory\n * @see BeanDefinitionRegistry\n */\npublic abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory\n\t\timplements AutowireCapableBeanFactory {\n\n\t/** Strategy for creating bean instances. */\n\tprivate InstantiationStrategy instantiationStrategy;\n\n\t/** Resolver strategy for method parameter names. */\n\t@Nullable\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\t/** Whether to automatically try to resolve circular references between beans. */\n\tprivate boolean allowCircularReferences = true;\n\n\t/**\n\t * Whether to resort to injecting a raw bean instance in case of circular reference,\n\t * even if the injected bean eventually got wrapped.\n\t */\n\tprivate boolean allowRawInjectionDespiteWrapping = false;\n\n\t/**\n\t * Dependency types to ignore on dependency check and autowire, as Set of\n\t * Class objects: for example, String. Default is none.\n\t */\n\tprivate final Set<Class<?>> ignoredDependencyTypes = new HashSet<>();\n\n\t/**\n\t * Dependency interfaces to ignore on dependency check and autowire, as Set of\n\t * Class objects. By default, only the BeanFactory interface is ignored.\n\t */\n\tprivate final Set<Class<?>> ignoredDependencyInterfaces = new HashSet<>();\n\n\t/**\n\t * The name of the currently created bean, for implicit dependency registration\n\t * on getBean etc invocations triggered from a user-specified Supplier callback.\n\t */\n\tprivate final NamedThreadLocal<String> currentlyCreatedBean = new NamedThreadLocal<>(\"Currently created bean\");\n\n\t/** Cache of unfinished FactoryBean instances: FactoryBean name to BeanWrapper. */\n\tprivate final ConcurrentMap<String, BeanWrapper> factoryBeanInstanceCache = new ConcurrentHashMap<>();\n\n\t/** Cache of candidate factory methods per factory class. */\n\tprivate final ConcurrentMap<Class<?>, Method[]> factoryMethodCandidateCache = new ConcurrentHashMap<>();\n\n\t/** Cache of filtered PropertyDescriptors: bean Class to PropertyDescriptor array. */\n\tprivate final ConcurrentMap<Class<?>, PropertyDescriptor[]> filteredPropertyDescriptorsCache =\n\t\t\tnew ConcurrentHashMap<>();\n\n\n\t/**\n\t * Create a new AbstractAutowireCapableBeanFactory.\n\t */\n\tpublic AbstractAutowireCapableBeanFactory() {\n\t\tsuper();\n\t\tignoreDependencyInterface(BeanNameAware.class);\n\t\tignoreDependencyInterface(BeanFactoryAware.class);\n\t\tignoreDependencyInterface(BeanClassLoaderAware.class);\n\t\tthis.instantiationStrategy = new CglibSubclassingInstantiationStrategy();\n\t}\n\n\t/**\n\t * Create a new AbstractAutowireCapableBeanFactory with the given parent.\n\t * @param parentBeanFactory parent bean factory, or {@code null} if none\n\t */\n\tpublic AbstractAutowireCapableBeanFactory(@Nullable BeanFactory parentBeanFactory) {\n\t\tthis();\n\t\tsetParentBeanFactory(parentBeanFactory);\n\t}\n\n\n\t/**\n\t * Set the instantiation strategy to use for creating bean instances.\n\t * Default is CglibSubclassingInstantiationStrategy.\n\t * @see CglibSubclassingInstantiationStrategy\n\t */\n\tpublic void setInstantiationStrategy(InstantiationStrategy instantiationStrategy) {\n\t\tthis.instantiationStrategy = instantiationStrategy;\n\t}\n\n\t/**\n\t * Return the instantiation strategy to use for creating bean instances.\n\t */\n\tpublic InstantiationStrategy getInstantiationStrategy() {\n\t\treturn this.instantiationStrategy;\n\t}\n\n\t/**\n\t * Set the ParameterNameDiscoverer to use for resolving method parameter\n\t * names if needed (for example, for constructor names).\n\t * <p>Default is a {@link DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Return the ParameterNameDiscoverer to use for resolving method parameter\n\t * names if needed.\n\t */\n\t@Nullable\n\tpublic ParameterNameDiscoverer getParameterNameDiscoverer() {\n\t\treturn this.parameterNameDiscoverer;\n\t}\n\n\t/**\n\t * Set whether to allow circular references between beans - and automatically\n\t * try to resolve them.\n\t * <p>Note that circular reference resolution means that one of the involved beans\n\t * will receive a reference to another bean that is not fully initialized yet.\n\t * This can lead to subtle and not-so-subtle side effects on initialization;\n\t * it does work fine for many scenarios, though.\n\t * <p>Default is \"true\". Turn this off to throw an exception when encountering\n\t * a circular reference, disallowing them completely.\n\t * <p><b>NOTE:</b> It is generally recommended to not rely on circular references\n\t * between your beans. Refactor your application logic to have the two beans\n\t * involved delegate to a third bean that encapsulates their common logic.\n\t */\n\tpublic void setAllowCircularReferences(boolean allowCircularReferences) {\n\t\tthis.allowCircularReferences = allowCircularReferences;\n\t}\n\n\t/**\n\t * Return whether to allow circular references between beans.\n\t * @since 5.3.10\n\t * @see #setAllowCircularReferences\n\t */\n\tpublic boolean isAllowCircularReferences() {\n\t\treturn this.allowCircularReferences;\n\t}\n\n\t/**\n\t * Set whether to allow the raw injection of a bean instance into some other\n\t * bean's property, despite the injected bean eventually getting wrapped\n\t * (for example, through AOP auto-proxying).\n\t * <p>This will only be used as a last resort in case of a circular reference\n\t * that cannot be resolved otherwise: essentially, preferring a raw instance\n\t * getting injected over a failure of the entire bean wiring process.\n\t * <p>Default is \"false\", as of Spring 2.0. Turn this on to allow for non-wrapped\n\t * raw beans injected into some of your references, which was Spring 1.2's\n\t * (arguably unclean) default behavior.\n\t * <p><b>NOTE:</b> It is generally recommended to not rely on circular references\n\t * between your beans, in particular with auto-proxying involved.\n\t * @see #setAllowCircularReferences\n\t */\n\tpublic void setAllowRawInjectionDespiteWrapping(boolean allowRawInjectionDespiteWrapping) {\n\t\tthis.allowRawInjectionDespiteWrapping = allowRawInjectionDespiteWrapping;\n\t}\n\n\t/**\n\t * Return whether to allow the raw injection of a bean instance.\n\t * @since 5.3.10\n\t * @see #setAllowRawInjectionDespiteWrapping\n\t */\n\tpublic boolean isAllowRawInjectionDespiteWrapping() {\n\t\treturn this.allowRawInjectionDespiteWrapping;\n\t}\n\n\t/**\n\t * Ignore the given dependency type for autowiring:\n\t * for example, String. Default is none.\n\t */\n\tpublic void ignoreDependencyType(Class<?> type) {\n\t\tthis.ignoredDependencyTypes.add(type);\n\t}\n\n\t/**\n\t * Ignore the given dependency interface for autowiring.\n\t * <p>This will typically be used by application contexts to register\n\t * dependencies that are resolved in other ways, like BeanFactory through\n\t * BeanFactoryAware or ApplicationContext through ApplicationContextAware.\n\t * <p>By default, only the BeanFactoryAware interface is ignored.\n\t * For further types to ignore, invoke this method for each type.\n\t * @see org.springframework.beans.factory.BeanFactoryAware\n\t * @see org.springframework.context.ApplicationContextAware\n\t */\n\tpublic void ignoreDependencyInterface(Class<?> ifc) {\n\t\tthis.ignoredDependencyInterfaces.add(ifc);\n\t}\n\n\t@Override\n\tpublic void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) {\n\t\tsuper.copyConfigurationFrom(otherFactory);\n\t\tif (otherFactory instanceof AbstractAutowireCapableBeanFactory otherAutowireFactory) {\n\t\t\tthis.instantiationStrategy = otherAutowireFactory.instantiationStrategy;\n\t\t\tthis.allowCircularReferences = otherAutowireFactory.allowCircularReferences;\n\t\t\tthis.ignoredDependencyTypes.addAll(otherAutowireFactory.ignoredDependencyTypes);\n\t\t\tthis.ignoredDependencyInterfaces.addAll(otherAutowireFactory.ignoredDependencyInterfaces);\n\t\t}\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Typical methods for creating and populating external bean instances\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T createBean(Class<T> beanClass) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new CreateFromClassBeanDefinition(beanClass);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tbd.allowCaching = ClassUtils.isCacheSafe(beanClass, getBeanClassLoader());\n\t\treturn (T) createBean(beanClass.getName(), bd, null);\n\t}\n\n\t@Override\n\tpublic void autowireBean(Object existingBean) {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(ClassUtils.getUserClass(existingBean));\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tbd.allowCaching = ClassUtils.isCacheSafe(bd.getBeanClass(), getBeanClassLoader());\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(bd.getBeanClass().getName(), bd, bw);\n\t}\n\n\t@Override\n\tpublic Object configureBean(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition mbd = getMergedBeanDefinition(beanName);\n\t\tRootBeanDefinition bd = null;\n\t\tif (mbd instanceof RootBeanDefinition rbd) {\n\t\t\tbd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition());\n\t\t}\n\t\tif (bd == null) {\n\t\t\tbd = new RootBeanDefinition(mbd);\n\t\t}\n\t\tif (!bd.isPrototype()) {\n\t\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\t\tbd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader());\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(beanName, bd, bw);\n\t\treturn initializeBean(beanName, existingBean, bd);\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Specialized methods for fine-grained control over the bean lifecycle\n\t//-------------------------------------------------------------------------\n\n\t@Deprecated\n\t@Override\n\tpublic Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\treturn createBean(beanClass.getName(), bd, null);\n\t}\n\n\t@Override\n\tpublic Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException {\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd = new RootBeanDefinition(beanClass, autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tif (bd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR) {\n\t\t\treturn autowireConstructor(beanClass.getName(), bd, null, null).getWrappedInstance();\n\t\t}\n\t\telse {\n\t\t\tObject bean = getInstantiationStrategy().instantiate(bd, null, this);\n\t\t\tpopulateBean(beanClass.getName(), bd, new BeanWrapperImpl(bean));\n\t\t\treturn bean;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)\n\t\t\tthrows BeansException {\n\n\t\tif (autowireMode == AUTOWIRE_CONSTRUCTOR) {\n\t\t\tthrow new IllegalArgumentException(\"AUTOWIRE_CONSTRUCTOR not supported for existing bean instance\");\n\t\t}\n\t\t// Use non-singleton bean definition, to avoid registering bean as dependent bean.\n\t\tRootBeanDefinition bd =\n\t\t\t\tnew RootBeanDefinition(ClassUtils.getUserClass(existingBean), autowireMode, dependencyCheck);\n\t\tbd.setScope(SCOPE_PROTOTYPE);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tpopulateBean(bd.getBeanClass().getName(), bd, bw);\n\t}\n\n\t@Override\n\tpublic void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException {\n\t\tmarkBeanAsCreated(beanName);\n\t\tBeanDefinition bd = getMergedBeanDefinition(beanName);\n\t\tBeanWrapper bw = new BeanWrapperImpl(existingBean);\n\t\tinitBeanWrapper(bw);\n\t\tapplyPropertyValues(beanName, bd, bw, bd.getPropertyValues());\n\t}\n\n\t@Override\n\tpublic Object initializeBean(Object existingBean, String beanName) {\n\t\treturn initializeBean(beanName, existingBean, null);\n\t}\n\n\t@Deprecated(since = \"6.1\")\n\t@Override\n\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessBeforeInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Deprecated(since = \"6.1\")\n\t@Override\n\tpublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessAfterInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic void destroyBean(Object existingBean) {\n\t\tnew DisposableBeanAdapter(existingBean, getBeanPostProcessorCache().destructionAware).destroy();\n\t}\n\n\n\t//-------------------------------------------------------------------------\n\t// Delegate methods for resolving injection points\n\t//-------------------------------------------------------------------------\n\n\t@Override\n\tpublic Object resolveBeanByName(String name, DependencyDescriptor descriptor) {\n\t\tInjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\n\t\ttry {\n\t\t\treturn getBean(name, descriptor.getDependencyType());\n\t\t}\n\t\tfinally {\n\t\t\tConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);\n\t\t}\n\t}\n\n\t@Override\n\t@Nullable\n\tpublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName) throws BeansException {\n\t\treturn resolveDependency(descriptor, requestingBeanName, null, null);\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation of relevant AbstractBeanFactory template methods\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Central method of this class: creates a bean instance,\n\t * populates the bean instance, applies post-processors, etc.\n\t * @see #doCreateBean\n\t */\n\t@Override\n\tprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Creating instance of bean '\" + beanName + \"'\");\n\t\t}\n\t\tRootBeanDefinition mbdToUse = mbd;\n\n\t\t// Make sure bean class is actually resolved at this point, and\n\t\t// clone the bean definition in case of a dynamically resolved Class\n\t\t// which cannot be stored in the shared merged bean definition.\n\t\tClass<?> resolvedClass = resolveBeanClass(mbd, beanName);\n\t\tif (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n\t\t\tmbdToUse = new RootBeanDefinition(mbd);\n\t\t\tmbdToUse.setBeanClass(resolvedClass);\n\t\t\ttry {\n\t\t\t\tmbdToUse.prepareMethodOverrides();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n\t\t\t\t\t\tbeanName, \"Validation of method overrides failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\tObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\n\t\t\tif (bean != null) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n\t\t\t\t\t\"BeanPostProcessor before instantiation of bean failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n\t\tcatch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n\t\t\t// A previously detected exception with proper bean creation context already,\n\t\t\t// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * Actually create the specified bean. Pre-creation processing has already happened\n\t * at this point, for example, checking {@code postProcessBeforeInstantiation} callbacks.\n\t * <p>Differentiates between default bean instantiation, use of a\n\t * factory method, and autowiring a constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a new instance of the bean\n\t * @throws BeanCreationException if the bean could not be created\n\t * @see #instantiateBean\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t */\n\tprotected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\t// Instantiate the bean.\n\t\tBeanWrapper instanceWrapper = null;\n\t\tif (mbd.isSingleton()) {\n\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n\t\t}\n\t\tif (instanceWrapper == null) {\n\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t\t}\n\t\tObject bean = instanceWrapper.getWrappedInstance();\n\t\tClass<?> beanType = instanceWrapper.getWrappedClass();\n\t\tif (beanType != NullBean.class) {\n\t\t\tmbd.resolvedTargetType = beanType;\n\t\t}\n\n\t\t// Allow post-processors to modify the merged bean definition.\n\t\tsynchronized (mbd.postProcessingLock) {\n\t\t\tif (!mbd.postProcessed) {\n\t\t\t\ttry {\n\t\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Post-processing of merged bean definition failed\", ex);\n\t\t\t\t}\n\t\t\t\tmbd.markAsPostProcessed();\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly cache singletons to be able to resolve circular references\n\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\t\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t\t}\n\n\t\t// Initialize the bean instance.\n\t\tObject exposedObject = bean;\n\t\ttry {\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException bce && beanName.equals(bce.getBeanName())) {\n\t\t\t\tthrow bce;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t\t}\n\t\t}\n\n\t\tif (earlySingletonExposure) {\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet<String> actualDependentBeans = CollectionUtils.newLinkedHashSet(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t\"] in its raw version as part of a circular reference, but has eventually been \" +\n\t\t\t\t\t\t\t\t\"wrapped. This means that said other beans do not use the final version of the \" +\n\t\t\t\t\t\t\t\t\"bean. This is often the result of over-eager type matching - consider using \" +\n\t\t\t\t\t\t\t\t\"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Register bean as disposable.\n\t\ttry {\n\t\t\tregisterDisposableBeanIfNecessary(beanName, bean, mbd);\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n\t\t}\n\n\t\treturn exposedObject;\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {\n\t\tClass<?> targetType = determineTargetType(beanName, mbd, typesToMatch);\n\t\t// Apply SmartInstantiationAwareBeanPostProcessors to predict the\n\t\t// eventual type after a before-instantiation shortcut.\n\t\tif (targetType != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tboolean matchingOnlyFactoryBean = (typesToMatch.length == 1 && typesToMatch[0] == FactoryBean.class);\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\tClass<?> predicted = bp.predictBeanType(targetType, beanName);\n\t\t\t\tif (predicted != null &&\n\t\t\t\t\t\t(!matchingOnlyFactoryBean || FactoryBean.class.isAssignableFrom(predicted))) {\n\t\t\t\t\treturn predicted;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn targetType;\n\t}\n\n\t/**\n\t * Determine the target type for the given bean definition.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param typesToMatch the types to match in case of internal type matching purposes\n\t * (also signals that the returned {@code Class} will never be exposed to application code)\n\t * @return the type for the bean if determinable, or {@code null} otherwise\n\t */\n\t@Nullable\n\tprotected Class<?> determineTargetType(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {\n\t\tClass<?> targetType = mbd.getTargetType();\n\t\tif (targetType == null) {\n\t\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\t\ttargetType = getTypeForFactoryMethod(beanName, mbd, typesToMatch);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttargetType = resolveBeanClass(mbd, beanName, typesToMatch);\n\t\t\t\tif (mbd.hasBeanClass()) {\n\t\t\t\t\ttargetType = getInstantiationStrategy().getActualBeanClass(mbd, beanName, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ObjectUtils.isEmpty(typesToMatch) || getTempClassLoader() == null) {\n\t\t\t\tmbd.resolvedTargetType = targetType;\n\t\t\t}\n\t\t}\n\t\treturn targetType;\n\t}\n\n\t/**\n\t * Determine the target type for the given bean definition which is based on\n\t * a factory method. Only called if there is no singleton instance registered\n\t * for the target bean already.\n\t * <p>This implementation determines the type matching {@link #createBean}'s\n\t * different creation strategies. As far as possible, we'll perform static\n\t * type checking to avoid creation of the target bean.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param typesToMatch the types to match in case of internal type matching purposes\n\t * (also signals that the returned {@code Class} will never be exposed to application code)\n\t * @return the type for the bean if determinable, or {@code null} otherwise\n\t * @see #createBean\n\t */\n\t@Nullable\n\tprotected Class<?> getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch) {\n\t\tResolvableType cachedReturnType = mbd.factoryMethodReturnType;\n\t\tif (cachedReturnType != null) {\n\t\t\treturn cachedReturnType.resolve();\n\t\t}\n\n\t\tClass<?> commonType = null;\n\t\tMethod uniqueCandidate = mbd.factoryMethodToIntrospect;\n\n\t\tif (uniqueCandidate == null) {\n\t\t\tClass<?> factoryClass;\n\t\t\tboolean isStatic = true;\n\n\t\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\t\tif (factoryBeanName != null) {\n\t\t\t\tif (factoryBeanName.equals(beanName)) {\n\t\t\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"factory-bean reference points back to the same bean definition\");\n\t\t\t\t}\n\t\t\t\t// Check declared factory method return type on factory class.\n\t\t\t\tfactoryClass = getType(factoryBeanName);\n\t\t\t\tisStatic = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Check declared factory method return type on bean class.\n\t\t\t\tfactoryClass = resolveBeanClass(mbd, beanName, typesToMatch);\n\t\t\t}\n\n\t\t\tif (factoryClass == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfactoryClass = ClassUtils.getUserClass(factoryClass);\n\n\t\t\t// If all factory methods have the same return type, return that type.\n\t\t\t// Can't clearly figure out exact method due to type converting / autowiring!\n\t\t\tint minNrOfArgs =\n\t\t\t\t\t(mbd.hasConstructorArgumentValues() ? mbd.getConstructorArgumentValues().getArgumentCount() : 0);\n\t\t\tMethod[] candidates = this.factoryMethodCandidateCache.computeIfAbsent(factoryClass,\n\t\t\t\t\tclazz -> ReflectionUtils.getUniqueDeclaredMethods(clazz, ReflectionUtils.USER_DECLARED_METHODS));\n\n\t\t\tfor (Method candidate : candidates) {\n\t\t\t\tif (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate) &&\n\t\t\t\t\t\tcandidate.getParameterCount() >= minNrOfArgs) {\n\t\t\t\t\t// Declared type variables to inspect?\n\t\t\t\t\tif (candidate.getTypeParameters().length > 0) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Fully resolve parameter names and argument values.\n\t\t\t\t\t\t\tConstructorArgumentValues cav = mbd.getConstructorArgumentValues();\n\t\t\t\t\t\t\tClass<?>[] paramTypes = candidate.getParameterTypes();\n\t\t\t\t\t\t\tString[] paramNames = null;\n\t\t\t\t\t\t\tif (cav.containsNamedArgument()) {\n\t\t\t\t\t\t\t\tParameterNameDiscoverer pnd = getParameterNameDiscoverer();\n\t\t\t\t\t\t\t\tif (pnd != null) {\n\t\t\t\t\t\t\t\t\tparamNames = pnd.getParameterNames(candidate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSet<ConstructorArgumentValues.ValueHolder> usedValueHolders = CollectionUtils.newHashSet(paramTypes.length);\n\t\t\t\t\t\t\tObject[] args = new Object[paramTypes.length];\n\t\t\t\t\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\t\tConstructorArgumentValues.ValueHolder valueHolder = cav.getArgumentValue(\n\t\t\t\t\t\t\t\t\t\ti, paramTypes[i], (paramNames != null ? paramNames[i] : null), usedValueHolders);\n\t\t\t\t\t\t\t\tif (valueHolder == null) {\n\t\t\t\t\t\t\t\t\tvalueHolder = cav.getGenericArgumentValue(null, null, usedValueHolders);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (valueHolder != null) {\n\t\t\t\t\t\t\t\t\targs[i] = valueHolder.getValue();\n\t\t\t\t\t\t\t\t\tusedValueHolders.add(valueHolder);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tClass<?> returnType = AutowireUtils.resolveReturnTypeForFactoryMethod(\n\t\t\t\t\t\t\t\t\tcandidate, args, getBeanClassLoader());\n\t\t\t\t\t\t\tuniqueCandidate = (commonType == null && returnType == candidate.getReturnType() ?\n\t\t\t\t\t\t\t\t\tcandidate : null);\n\t\t\t\t\t\t\tcommonType = ClassUtils.determineCommonAncestor(returnType, commonType);\n\t\t\t\t\t\t\tif (commonType == null) {\n\t\t\t\t\t\t\t\t// Ambiguous return types found: return null to indicate \"not determinable\".\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"Failed to resolve generic return type for factory method: \" + ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuniqueCandidate = (commonType == null ? candidate : null);\n\t\t\t\t\t\tcommonType = ClassUtils.determineCommonAncestor(candidate.getReturnType(), commonType);\n\t\t\t\t\t\tif (commonType == null) {\n\t\t\t\t\t\t\t// Ambiguous return types found: return null to indicate \"not determinable\".\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmbd.factoryMethodToIntrospect = uniqueCandidate;\n\t\t\tif (commonType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Common return type found: all factory methods return same type. For a non-parameterized\n\t\t// unique candidate, cache the full type declaration context of the target factory method.\n\t\ttry {\n\t\t\tcachedReturnType = (uniqueCandidate != null ?\n\t\t\t\t\tResolvableType.forMethodReturnType(uniqueCandidate) : ResolvableType.forClass(commonType));\n\t\t\tmbd.factoryMethodReturnType = cachedReturnType;\n\t\t\treturn cachedReturnType.resolve();\n\t\t}\n\t\tcatch (LinkageError err) {\n\t\t\t// For example, a NoClassDefFoundError for a generic method return type\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Failed to resolve type for factory method of bean '\" + beanName + \"': \" +\n\t\t\t\t\t\t(uniqueCandidate != null ? uniqueCandidate : commonType), err);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * This implementation attempts to query the FactoryBean's generic parameter metadata\n\t * if present to determine the object type. If not present, i.e. the FactoryBean is\n\t * declared as a raw type, it checks the FactoryBean's {@code getObjectType} method\n\t * on a plain instance of the FactoryBean, without bean properties applied yet.\n\t * If this doesn't return a type yet and {@code allowInit} is {@code true}, full\n\t * creation of the FactoryBean is attempted as fallback (through delegation to the\n\t * superclass implementation).\n\t * <p>The shortcut check for a FactoryBean is only applied in case of a singleton\n\t * FactoryBean. If the FactoryBean instance itself is not kept as singleton,\n\t * it will be fully created to check the type of its exposed object.\n\t */\n\t@Override\n\tprotected ResolvableType getTypeForFactoryBean(String beanName, RootBeanDefinition mbd, boolean allowInit) {\n\t\tResolvableType result;\n\n\t\t// Check if the bean definition itself has defined the type with an attribute\n\t\ttry {\n\t\t\tresult = getTypeForFactoryBeanFromAttributes(mbd);\n\t\t\tif (result != ResolvableType.NONE) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\tString.valueOf(ex.getMessage()));\n\t\t}\n\n\t\t// For instance supplied beans, try the target type and bean class immediately\n\t\tif (mbd.getInstanceSupplier() != null) {\n\t\t\tresult = getFactoryBeanGeneric(mbd.targetType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = getFactoryBeanGeneric(mbd.hasBeanClass() ? ResolvableType.forClass(mbd.getBeanClass()) : null);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// Consider factory methods\n\t\tString factoryBeanName = mbd.getFactoryBeanName();\n\t\tString factoryMethodName = mbd.getFactoryMethodName();\n\n\t\t// Scan the factory bean methods\n\t\tif (factoryBeanName != null) {\n\t\t\tif (factoryMethodName != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from its factory method\n\t\t\t\t// declaration without instantiating the containing bean at all.\n\t\t\t\tBeanDefinition factoryBeanDefinition = getBeanDefinition(factoryBeanName);\n\t\t\t\tClass<?> factoryBeanClass;\n\t\t\t\tif (factoryBeanDefinition instanceof AbstractBeanDefinition abstractBeanDefinition &&\n\t\t\t\t\t\tabstractBeanDefinition.hasBeanClass()) {\n\t\t\t\t\tfactoryBeanClass = abstractBeanDefinition.getBeanClass();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tRootBeanDefinition fbmbd = getMergedBeanDefinition(factoryBeanName, factoryBeanDefinition);\n\t\t\t\t\tfactoryBeanClass = determineTargetType(factoryBeanName, fbmbd);\n\t\t\t\t}\n\t\t\t\tif (factoryBeanClass != null) {\n\t\t\t\t\tresult = getTypeForFactoryBeanFromMethod(factoryBeanClass, factoryMethodName);\n\t\t\t\t\tif (result.resolve() != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If not resolvable above and the referenced factory bean doesn't exist yet,\n\t\t\t// exit here - we don't want to force the creation of another bean just to\n\t\t\t// obtain a FactoryBean's object type...\n\t\t\tif (!isBeanEligibleForMetadataCaching(factoryBeanName)) {\n\t\t\t\treturn ResolvableType.NONE;\n\t\t\t}\n\t\t}\n\n\t\t// If we're allowed, we can create the factory bean and call getObjectType() early\n\t\tif (allowInit) {\n\t\t\tFactoryBean<?> factoryBean = (mbd.isSingleton() ?\n\t\t\t\t\tgetSingletonFactoryBeanForTypeCheck(beanName, mbd) :\n\t\t\t\t\tgetNonSingletonFactoryBeanForTypeCheck(beanName, mbd));\n\t\t\tif (factoryBean != null) {\n\t\t\t\t// Try to obtain the FactoryBean's object type from this early stage of the instance.\n\t\t\t\tClass<?> type = getTypeForFactoryBean(factoryBean);\n\t\t\t\tif (type != null) {\n\t\t\t\t\treturn ResolvableType.forClass(type);\n\t\t\t\t}\n\t\t\t\t// No type found for shortcut FactoryBean instance:\n\t\t\t\t// fall back to full creation of the FactoryBean instance.\n\t\t\t\treturn super.getTypeForFactoryBean(beanName, mbd, true);\n\t\t\t}\n\t\t}\n\n\t\tif (factoryBeanName == null && mbd.hasBeanClass() && factoryMethodName != null) {\n\t\t\t// No early bean instantiation possible: determine FactoryBean's type from\n\t\t\t// static factory method signature or from class inheritance hierarchy...\n\t\t\treturn getTypeForFactoryBeanFromMethod(mbd.getBeanClass(), factoryMethodName);\n\t\t}\n\n\t\t// For regular beans, try the target type and bean class as fallback\n\t\tif (mbd.getInstanceSupplier() == null) {\n\t\t\tresult = getFactoryBeanGeneric(mbd.targetType);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = getFactoryBeanGeneric(mbd.hasBeanClass() ? ResolvableType.forClass(mbd.getBeanClass()) : null);\n\t\t\tif (result.resolve() != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// FactoryBean type not resolvable\n\t\treturn ResolvableType.NONE;\n\t}\n\n\t/**\n\t * Introspect the factory method signatures on the given bean class,\n\t * trying to find a common {@code FactoryBean} object type declared there.\n\t * @param beanClass the bean class to find the factory method on\n\t * @param factoryMethodName the name of the factory method\n\t * @return the common {@code FactoryBean} object type, or {@code null} if none\n\t */\n\tprivate ResolvableType getTypeForFactoryBeanFromMethod(Class<?> beanClass, String factoryMethodName) {\n\t\t// CGLIB subclass methods hide generic parameters; look at the original user class.\n\t\tClass<?> factoryBeanClass = ClassUtils.getUserClass(beanClass);\n\t\tFactoryBeanMethodTypeFinder finder = new FactoryBeanMethodTypeFinder(factoryMethodName);\n\t\tReflectionUtils.doWithMethods(factoryBeanClass, finder, ReflectionUtils.USER_DECLARED_METHODS);\n\t\treturn finder.getResult();\n\t}\n\n\t/**\n\t * Obtain a reference for early access to the specified bean,\n\t * typically for the purpose of resolving a circular reference.\n\t * @param beanName the name of the bean (for error handling purposes)\n\t * @param mbd the merged bean definition for the bean\n\t * @param bean the raw bean instance\n\t * @return the object to expose as bean reference\n\t */\n\tprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\texposedObject = bp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}\n\n\n\t//---------------------------------------------------------------------\n\t// Implementation methods\n\t//---------------------------------------------------------------------\n\n\t/**\n\t * Obtain a \"shortcut\" singleton FactoryBean instance to use for a\n\t * {@code getObjectType()} call, without full initialization of the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the FactoryBean instance, or {@code null} to indicate\n\t * that we couldn't obtain a shortcut FactoryBean instance\n\t */\n\t@Nullable\n\tprivate FactoryBean<?> getSingletonFactoryBeanForTypeCheck(String beanName, RootBeanDefinition mbd) {\n\t\tthis.singletonLock.lock();\n\t\ttry {\n\t\t\tBeanWrapper bw = this.factoryBeanInstanceCache.get(beanName);\n\t\t\tif (bw != null) {\n\t\t\t\treturn (FactoryBean<?>) bw.getWrappedInstance();\n\t\t\t}\n\t\t\tObject beanInstance = getSingleton(beanName, false);\n\t\t\tif (beanInstance instanceof FactoryBean<?> factoryBean) {\n\t\t\t\treturn factoryBean;\n\t\t\t}\n\t\t\tif (isSingletonCurrentlyInCreation(beanName) ||\n\t\t\t\t\t(mbd.getFactoryBeanName() != null && isSingletonCurrentlyInCreation(mbd.getFactoryBeanName()))) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tObject instance;\n\t\t\ttry {\n\t\t\t\t// Mark this bean as currently in creation, even if just partially.\n\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\t\tinstance = resolveBeforeInstantiation(beanName, mbd);\n\t\t\t\tif (instance == null) {\n\t\t\t\t\tbw = createBeanInstance(beanName, mbd, null);\n\t\t\t\t\tinstance = bw.getWrappedInstance();\n\t\t\t\t\tthis.factoryBeanInstanceCache.put(beanName, bw);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t\t// Don't swallow, probably misconfiguration...\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\t// Don't swallow a linkage error since it contains a full stacktrace on\n\t\t\t\t// first occurrence... and just a plain NoClassDefFoundError afterwards.\n\t\t\t\tif (ex.contains(LinkageError.class)) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\t// Instantiation failure, maybe too early...\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean creation exception on singleton FactoryBean type check: \" + ex);\n\t\t\t\t}\n\t\t\t\tonSuppressedException(ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t// Finished partial creation of this bean.\n\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t}\n\n\t\t\treturn getFactoryBean(beanName, instance);\n\t\t}\n\t\tfinally {\n\t\t\tthis.singletonLock.unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a \"shortcut\" non-singleton FactoryBean instance to use for a\n\t * {@code getObjectType()} call, without full initialization of the FactoryBean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the FactoryBean instance, or {@code null} to indicate\n\t * that we couldn't obtain a shortcut FactoryBean instance\n\t */\n\t@Nullable\n\tprivate FactoryBean<?> getNonSingletonFactoryBeanForTypeCheck(String beanName, RootBeanDefinition mbd) {\n\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject instance;\n\t\ttry {\n\t\t\t// Mark this bean as currently in creation, even if just partially.\n\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\tinstance = resolveBeforeInstantiation(beanName, mbd);\n\t\t\tif (instance == null) {\n\t\t\t\tBeanWrapper bw = createBeanInstance(beanName, mbd, null);\n\t\t\t\tinstance = bw.getWrappedInstance();\n\t\t\t}\n\t\t}\n\t\tcatch (UnsatisfiedDependencyException ex) {\n\t\t\t// Don't swallow, probably misconfiguration...\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (BeanCreationException ex) {\n\t\t\t// Instantiation failure, maybe too early...\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Bean creation exception on non-singleton FactoryBean type check: \" + ex);\n\t\t\t}\n\t\t\tonSuppressedException(ex);\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\t// Finished partial creation of this bean.\n\t\t\tafterPrototypeCreation(beanName);\n\t\t}\n\n\t\treturn getFactoryBean(beanName, instance);\n\t}\n\n\t/**\n\t * Apply MergedBeanDefinitionPostProcessors to the specified bean definition,\n\t * invoking their {@code postProcessMergedBeanDefinition} methods.\n\t * @param mbd the merged bean definition for the bean\n\t * @param beanType the actual type of the managed bean instance\n\t * @param beanName the name of the bean\n\t * @see MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition\n\t */\n\tprotected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {\n\t\tfor (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {\n\t\t\tprocessor.postProcessMergedBeanDefinition(mbd, beanType, beanName);\n\t\t}\n\t}\n\n\t/**\n\t * Apply before-instantiation post-processors, resolving whether there is a\n\t * before-instantiation shortcut for the specified bean.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return the shortcut-determined bean instance, or {@code null} if none\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\t@Nullable\n\tprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n\t\tObject bean = null;\n\t\tif (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n\t\t\t// Make sure bean class is actually resolved at this point.\n\t\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\t\tClass<?> targetType = determineTargetType(beanName, mbd);\n\t\t\t\tif (targetType != null) {\n\t\t\t\t\tbean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n\t\t\t\t\tif (bean != null) {\n\t\t\t\t\t\tbean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmbd.beforeInstantiationResolved = (bean != null);\n\t\t}\n\t\treturn bean;\n\t}\n\n\t/**\n\t * Apply InstantiationAwareBeanPostProcessors to the specified bean definition\n\t * (by class and name), invoking their {@code postProcessBeforeInstantiation} methods.\n\t * <p>Any returned object will be used as the bean instead of actually instantiating\n\t * the target bean. A {@code null} return value from the post-processor will\n\t * result in the target bean being instantiated.\n\t * @param beanClass the class of the bean to be instantiated\n\t * @param beanName the name of the bean\n\t * @return the bean object to use instead of a default instance of the target bean, or {@code null}\n\t * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n\t */\n\t@Nullable\n\tprotected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\tObject result = bp.postProcessBeforeInstantiation(beanClass, beanName);\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Create a new instance for the specified bean, using an appropriate instantiation strategy:\n\t * factory method, constructor autowiring, or simple instantiation.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param args explicit arguments to use for constructor or factory method invocation\n\t * @return a BeanWrapper for the new instance\n\t * @see #obtainFromSupplier\n\t * @see #instantiateUsingFactoryMethod\n\t * @see #autowireConstructor\n\t * @see #instantiateBean\n\t */\n\tprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {\n\t\t// Make sure bean class is actually resolved at this point.\n\t\tClass<?> beanClass = resolveBeanClass(mbd, beanName);\n\n\t\tif (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n\t\t}\n\n\t\tif (args == null) {\n\t\t\tSupplier<?> instanceSupplier = mbd.getInstanceSupplier();\n\t\t\tif (instanceSupplier != null) {\n\t\t\t\treturn obtainFromSupplier(instanceSupplier, beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\tif (mbd.getFactoryMethodName() != null) {\n\t\t\treturn instantiateUsingFactoryMethod(beanName, mbd, args);\n\t\t}\n\n\t\t// Shortcut when re-creating the same bean...\n\t\tboolean resolved = false;\n\t\tboolean autowireNecessary = false;\n\t\tif (args == null) {\n\t\t\tsynchronized (mbd.constructorArgumentLock) {\n\t\t\t\tif (mbd.resolvedConstructorOrFactoryMethod != null) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tautowireNecessary = mbd.constructorArgumentsResolved;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (resolved) {\n\t\t\tif (autowireNecessary) {\n\t\t\t\treturn autowireConstructor(beanName, mbd, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn instantiateBean(beanName, mbd);\n\t\t\t}\n\t\t}\n\n\t\t// Candidate constructors for autowiring?\n\t\tConstructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n\t\tif (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||\n\t\t\t\tmbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, args);\n\t\t}\n\n\t\t// Preferred constructors for default construction?\n\t\tctors = mbd.getPreferredConstructors();\n\t\tif (ctors != null) {\n\t\t\treturn autowireConstructor(beanName, mbd, ctors, null);\n\t\t}\n\n\t\t// No special handling: simply use no-arg constructor.\n\t\treturn instantiateBean(beanName, mbd);\n\t}\n\n\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @return a BeanWrapper for the new instance\n\t */\n\tprivate BeanWrapper obtainFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd) {\n\t\tString outerBean = this.currentlyCreatedBean.get();\n\t\tthis.currentlyCreatedBean.set(beanName);\n\t\tObject instance;\n\n\t\ttry {\n\t\t\tinstance = obtainInstanceFromSupplier(supplier, beanName, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeansException beansException) {\n\t\t\t\tthrow beansException;\n\t\t\t}\n\t\t\tthrow new BeanCreationException(beanName, \"Instantiation of supplied bean failed\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (outerBean != null) {\n\t\t\t\tthis.currentlyCreatedBean.set(outerBean);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.currentlyCreatedBean.remove();\n\t\t\t}\n\t\t}\n\n\t\tif (instance == null) {\n\t\t\tinstance = new NullBean();\n\t\t}\n\t\tBeanWrapper bw = new BeanWrapperImpl(instance);\n\t\tinitBeanWrapper(bw);\n\t\treturn bw;\n\t}\n\n\t/**\n\t * Obtain a bean instance from the given supplier.\n\t * @param supplier the configured supplier\n\t * @param beanName the corresponding bean name\n\t * @param mbd the bean definition for the bean\n\t * @return the bean instance (possibly {@code null})\n\t * @since 6.0.7\n\t */\n\t@Nullable\n\tprotected Object obtainInstanceFromSupplier(Supplier<?> supplier, String beanName, RootBeanDefinition mbd)\n\t\t\tthrows Exception {\n\n\t\tif (supplier instanceof ThrowingSupplier<?> throwingSupplier) {\n\t\t\treturn throwingSupplier.getWithException();\n\t\t}\n\t\treturn supplier.get();\n\t}\n\n\t/**\n\t * Overridden in order to implicitly register the currently created bean as\n\t * dependent on further beans getting programmatically retrieved during a\n\t * {@link Supplier} callback.\n\t * @since 5.0\n\t * @see #obtainFromSupplier\n\t */\n\t@Override\n\tprotected Object getObjectForBeanInstance(\n\t\t\tObject beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {\n\n\t\tString currentlyCreatedBean = this.currentlyCreatedBean.get();\n\t\tif (currentlyCreatedBean != null) {\n\t\t\tregisterDependentBean(beanName, currentlyCreatedBean);\n\t\t}\n\n\t\treturn super.getObjectForBeanInstance(beanInstance, name, beanName, mbd);\n\t}\n\n\t/**\n\t * Determine candidate constructors to use for the given bean, checking all registered\n\t * {@link SmartInstantiationAwareBeanPostProcessor SmartInstantiationAwareBeanPostProcessors}.\n\t * @param beanClass the raw class of the bean\n\t * @param beanName the name of the bean\n\t * @return the candidate constructors, or {@code null} if none specified\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors\n\t */\n\t@Nullable\n\tprotected Constructor<?>[] determineConstructorsFromBeanPostProcessors(@Nullable Class<?> beanClass, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tif (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\tConstructor<?>[] ctors = bp.determineCandidateConstructors(beanClass, beanName);\n\t\t\t\tif (ctors != null) {\n\t\t\t\t\treturn ctors;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Instantiate the given bean using its default constructor.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @return a BeanWrapper for the new instance\n\t */\n\tprotected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {\n\t\ttry {\n\t\t\tObject beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this);\n\t\t\tBeanWrapper bw = new BeanWrapperImpl(beanInstance);\n\t\t\tinitBeanWrapper(bw);\n\t\t\treturn bw;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate the bean using a named factory method. The method may be static, if the\n\t * mbd parameter specifies a class, rather than a factoryBean, or an instance variable\n\t * on a factory object itself configured using Dependency Injection.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t * @see #getBean(String, Object[])\n\t */\n\tprotected BeanWrapper instantiateUsingFactoryMethod(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);\n\t}\n\n\t/**\n\t * \"autowire constructor\" (with constructor arguments by type) behavior.\n\t * Also applied if explicit constructor argument values are specified,\n\t * matching all remaining arguments with beans from the bean factory.\n\t * <p>This corresponds to constructor injection: In this mode, a Spring\n\t * bean factory is able to host components that expect constructor-based\n\t * dependency resolution.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param ctors the chosen candidate constructors\n\t * @param explicitArgs argument values passed in programmatically via the getBean method,\n\t * or {@code null} if none (implying the use of constructor argument values from bean definition)\n\t * @return a BeanWrapper for the new instance\n\t */\n\tprotected BeanWrapper autowireConstructor(\n\t\t\tString beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {\n\n\t\treturn new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);\n\t}\n\n\t/**\n\t * Populate the bean instance in the given BeanWrapper with the property values\n\t * from the bean definition.\n\t * @param beanName the name of the bean\n\t * @param mbd the bean definition for the bean\n\t * @param bw the BeanWrapper with bean instance\n\t */\n\tprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n\t\tif (bw == null) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for null instance.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (bw.getWrappedClass().isRecord()) {\n\t\t\tif (mbd.hasPropertyValues()) {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Cannot apply property values to a record\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Skip property population phase for records since they are immutable.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n\t\t// state of the bean before properties are set. This can be used, for example,\n\t\t// to support styles of field injection.\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tif (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\tMutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\t\t\t// Add property values based on autowire by name if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n\t\t\t\tautowireByName(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\t// Add property values based on autowire by type if applicable.\n\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n\t\t\t\tautowireByType(beanName, mbd, bw, newPvs);\n\t\t\t}\n\t\t\tpvs = newPvs;\n\t\t}\n\t\tif (hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tif (pvs == null) {\n\t\t\t\tpvs = mbd.getPropertyValues();\n\t\t\t}\n\t\t\tfor (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {\n\t\t\t\tPropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n\t\t\t\tif (pvsToUse == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpvs = pvsToUse;\n\t\t\t}\n\t\t}\n\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\t\tif (needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t}\n\n\t\tif (pvs != null) {\n\t\t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t}\n\t}\n\n\t/**\n\t * Fill in any missing property values with references to\n\t * other beans in this factory if autowire is set to \"byName\".\n\t * @param beanName the name of the bean we're wiring up.\n\t * Useful for debugging messages; not used functionally.\n\t * @param mbd bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */\n\tprotected void autowireByName(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\tif (containsBean(propertyName)) {\n\t\t\t\tObject bean = getBean(propertyName);\n\t\t\t\tpvs.add(propertyName, bean);\n\t\t\t\tregisterDependentBean(propertyName, beanName);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Added autowiring by name from bean name '\" + beanName +\n\t\t\t\t\t\t\t\"' via property '\" + propertyName + \"' to bean named '\" + propertyName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Not autowiring property '\" + propertyName + \"' of bean '\" + beanName +\n\t\t\t\t\t\t\t\"' by name: no matching bean found\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Abstract method defining \"autowire by type\" (bean properties by type) behavior.\n\t * <p>This is like PicoContainer default, in which there must be exactly one bean\n\t * of the property type in the bean factory. This makes bean factories simple to\n\t * configure for small namespaces, but doesn't work as well as standard Spring\n\t * behavior for bigger applications.\n\t * @param beanName the name of the bean to autowire by type\n\t * @param mbd the merged bean definition to update through autowiring\n\t * @param bw the BeanWrapper from which we can obtain information about the bean\n\t * @param pvs the PropertyValues to register wired objects with\n\t */\n\tprotected void autowireByType(\n\t\t\tString beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\n\t\tString[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(propertyNames.length * 2);\n\t\tfor (String propertyName : propertyNames) {\n\t\t\ttry {\n\t\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\t\t// Don't try autowiring by type for type Object: never makes sense,\n\t\t\t\t// even if it technically is an unsatisfied, non-simple property.\n\t\t\t\tif (Object.class != pd.getPropertyType()) {\n\t\t\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\t\t\t// Do not allow eager init for type matching in case of a prioritized post-processor.\n\t\t\t\t\tboolean eager = !(bw.getWrappedInstance() instanceof PriorityOrdered);\n\t\t\t\t\tDependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);\n\t\t\t\t\tObject autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);\n\t\t\t\t\tif (autowiredArgument != null) {\n\t\t\t\t\t\tpvs.add(propertyName, autowiredArgument);\n\t\t\t\t\t}\n\t\t\t\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\t\t\t\tregisterDependentBean(autowiredBeanName, beanName);\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Autowiring by type from bean name '\" + beanName + \"' via property '\" +\n\t\t\t\t\t\t\t\t\tpropertyName + \"' to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tautowiredBeanNames.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Return an array of non-simple bean properties that are unsatisfied.\n\t * These are probably unsatisfied references to other beans in the\n\t * factory. Does not include simple properties like primitives or Strings.\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param bw the BeanWrapper the bean was created with\n\t * @return an array of bean property names\n\t * @see org.springframework.beans.BeanUtils#isSimpleProperty\n\t */\n\tprotected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {\n\t\tSet<String> result = new TreeSet<>();\n\t\tPropertyValues pvs = mbd.getPropertyValues();\n\t\tPropertyDescriptor[] pds = bw.getPropertyDescriptors();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && !isExcludedFromDependencyCheck(pd) && !pvs.contains(pd.getName()) &&\n\t\t\t\t\t!BeanUtils.isSimpleProperty(pd.getPropertyType())) {\n\t\t\t\tresult.add(pd.getName());\n\t\t\t}\n\t\t}\n\t\treturn StringUtils.toStringArray(result);\n\t}\n\n\t/**\n\t * Extract a filtered set of PropertyDescriptors from the given BeanWrapper,\n\t * excluding ignored dependency types or properties defined on ignored dependency interfaces.\n\t * @param bw the BeanWrapper the bean was created with\n\t * @param cache whether to cache filtered PropertyDescriptors for the given bean Class\n\t * @return the filtered PropertyDescriptors\n\t * @see #isExcludedFromDependencyCheck\n\t * @see #filterPropertyDescriptorsForDependencyCheck(org.springframework.beans.BeanWrapper)\n\t */\n\tprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw, boolean cache) {\n\t\tPropertyDescriptor[] filtered = this.filteredPropertyDescriptorsCache.get(bw.getWrappedClass());\n\t\tif (filtered == null) {\n\t\t\tfiltered = filterPropertyDescriptorsForDependencyCheck(bw);\n\t\t\tif (cache) {\n\t\t\t\tPropertyDescriptor[] existing =\n\t\t\t\t\t\tthis.filteredPropertyDescriptorsCache.putIfAbsent(bw.getWrappedClass(), filtered);\n\t\t\t\tif (existing != null) {\n\t\t\t\t\tfiltered = existing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}\n\n\t/**\n\t * Extract a filtered set of PropertyDescriptors from the given BeanWrapper,\n\t * excluding ignored dependency types or properties defined on ignored dependency interfaces.\n\t * @param bw the BeanWrapper the bean was created with\n\t * @return the filtered PropertyDescriptors\n\t * @see #isExcludedFromDependencyCheck\n\t */\n\tprotected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) {\n\t\tList<PropertyDescriptor> pds = new ArrayList<>(Arrays.asList(bw.getPropertyDescriptors()));\n\t\tpds.removeIf(this::isExcludedFromDependencyCheck);\n\t\treturn pds.toArray(new PropertyDescriptor[0]);\n\t}\n\n\t/**\n\t * Determine whether the given bean property is excluded from dependency checks.\n\t * <p>This implementation excludes properties defined by CGLIB and\n\t * properties whose type matches an ignored dependency type or which\n\t * are defined by an ignored dependency interface.\n\t * @param pd the PropertyDescriptor of the bean property\n\t * @return whether the bean property is excluded\n\t * @see #ignoreDependencyType(Class)\n\t * @see #ignoreDependencyInterface(Class)\n\t */\n\tprotected boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {\n\t\treturn (AutowireUtils.isExcludedFromDependencyCheck(pd) ||\n\t\t\t\tthis.ignoredDependencyTypes.contains(pd.getPropertyType()) ||\n\t\t\t\tAutowireUtils.isSetterDefinedInInterface(pd, this.ignoredDependencyInterfaces));\n\t}\n\n\t/**\n\t * Perform a dependency check that all properties exposed have been set,\n\t * if desired. Dependency checks can be objects (collaborating beans),\n\t * simple (primitives and String), or all (both).\n\t * @param beanName the name of the bean\n\t * @param mbd the merged bean definition the bean was created with\n\t * @param pds the relevant property descriptors for the target bean\n\t * @param pvs the property values to be applied to the bean\n\t * @see #isExcludedFromDependencyCheck(java.beans.PropertyDescriptor)\n\t */\n\tprotected void checkDependencies(\n\t\t\tString beanName, AbstractBeanDefinition mbd, PropertyDescriptor[] pds, @Nullable PropertyValues pvs)\n\t\t\tthrows UnsatisfiedDependencyException {\n\n\t\tint dependencyCheck = mbd.getDependencyCheck();\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (pd.getWriteMethod() != null && (pvs == null || !pvs.contains(pd.getName()))) {\n\t\t\t\tboolean isSimple = BeanUtils.isSimpleProperty(pd.getPropertyType());\n\t\t\t\tboolean unsatisfied = (dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_ALL) ||\n\t\t\t\t\t\t(isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_SIMPLE) ||\n\t\t\t\t\t\t(!isSimple && dependencyCheck == AbstractBeanDefinition.DEPENDENCY_CHECK_OBJECTS);\n\t\t\t\tif (unsatisfied) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, pd.getName(),\n\t\t\t\t\t\t\t\"Set this property value or disable dependency checking for this bean.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Apply the given property values, resolving any runtime references\n\t * to other beans in this bean factory. Must use deep copy, so we\n\t * don't permanently modify this property.\n\t * @param beanName the bean name passed for better exception information\n\t * @param mbd the merged bean definition\n\t * @param bw the BeanWrapper wrapping the target object\n\t * @param pvs the new property values\n\t */\n\tprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n\t\tif (pvs.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tMutablePropertyValues mpvs = null;\n\t\tList<PropertyValue> original;\n\n\t\tif (pvs instanceof MutablePropertyValues _mpvs) {\n\t\t\tmpvs = _mpvs;\n\t\t\tif (mpvs.isConverted()) {\n\t\t\t\t// Shortcut: use the pre-converted values as-is.\n\t\t\t\ttry {\n\t\t\t\t\tbw.setPropertyValues(mpvs);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\toriginal = mpvs.getPropertyValueList();\n\t\t}\n\t\telse {\n\t\t\toriginal = Arrays.asList(pvs.getPropertyValues());\n\t\t}\n\n\t\tTypeConverter converter = getCustomTypeConverter();\n\t\tif (converter == null) {\n\t\t\tconverter = bw;\n\t\t}\n\t\tBeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n\t\t// Create a deep copy, resolving any references for values.\n\t\tList<PropertyValue> deepCopy = new ArrayList<>(original.size());\n\t\tboolean resolveNecessary = false;\n\t\tfor (PropertyValue pv : original) {\n\t\t\tif (pv.isConverted()) {\n\t\t\t\tdeepCopy.add(pv);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString propertyName = pv.getName();\n\t\t\t\tObject originalValue = pv.getValue();\n\t\t\t\tif (originalValue == AutowiredPropertyMarker.INSTANCE) {\n\t\t\t\t\tMethod writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();\n\t\t\t\t\tif (writeMethod == null) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Autowire marker for property without write method: \" + pv);\n\t\t\t\t\t}\n\t\t\t\t\toriginalValue = new DependencyDescriptor(new MethodParameter(writeMethod, 0), true);\n\t\t\t\t}\n\t\t\t\tObject resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n\t\t\t\tObject convertedValue = resolvedValue;\n\t\t\t\tboolean convertible = isConvertibleProperty(propertyName, bw);\n\t\t\t\tif (convertible) {\n\t\t\t\t\tconvertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n\t\t\t\t}\n\t\t\t\t// Possibly store converted value in merged bean definition,\n\t\t\t\t// in order to avoid re-conversion for every created bean instance.\n\t\t\t\tif (resolvedValue == originalValue) {\n\t\t\t\t\tif (convertible) {\n\t\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\t}\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse if (convertible && originalValue instanceof TypedStringValue typedStringValue &&\n\t\t\t\t\t\t!typedStringValue.isDynamic() &&\n\t\t\t\t\t\t!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n\t\t\t\t\tpv.setConvertedValue(convertedValue);\n\t\t\t\t\tdeepCopy.add(pv);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolveNecessary = true;\n\t\t\t\t\tdeepCopy.add(new PropertyValue(pv, convertedValue));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mpvs != null && !resolveNecessary) {\n\t\t\tmpvs.setConverted();\n\t\t}\n\n\t\t// Set our (possibly massaged) deep copy.\n\t\ttry {\n\t\t\tbw.setPropertyValues(new MutablePropertyValues(deepCopy));\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);\n\t\t}\n\t}\n\n\t/**\n\t * Determine whether the factory should cache a converted value for the given property.\n\t */\n\tprivate boolean isConvertibleProperty(String propertyName, BeanWrapper bw) {\n\t\ttry {\n\t\t\treturn !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName) &&\n\t\t\t\t\tBeanUtils.hasUniqueWriteMethod(bw.getPropertyDescriptor(propertyName));\n\t\t}\n\t\tcatch (InvalidPropertyException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the given value for the specified target property.\n\t */\n\t@Nullable\n\tprivate Object convertForProperty(\n\t\t\t@Nullable Object value, String propertyName, BeanWrapper bw, TypeConverter converter) {\n\n\t\tif (converter instanceof BeanWrapperImpl beanWrapper) {\n\t\t\treturn beanWrapper.convertForProperty(value, propertyName);\n\t\t}\n\t\telse {\n\t\t\tPropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);\n\t\t\tMethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);\n\t\t\treturn converter.convertIfNecessary(value, pd.getPropertyType(), methodParam);\n\t\t}\n\t}\n\n\n\t/**\n\t * Initialize the given bean instance, applying factory callbacks\n\t * as well as init methods and bean post processors.\n\t * <p>Called from {@link #createBean} for traditionally defined beans,\n\t * and from {@link #initializeBean} for existing bean instances.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @return the initialized bean instance (potentially wrapped)\n\t * @see BeanNameAware\n\t * @see BeanClassLoaderAware\n\t * @see BeanFactoryAware\n\t * @see #applyBeanPostProcessorsBeforeInitialization\n\t * @see #invokeInitMethods\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {\n\t\tinvokeAwareMethods(beanName, bean);\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null), beanName, ex.getMessage(), ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}\n\n\tprivate void invokeAwareMethods(String beanName, Object bean) {\n\t\tif (bean instanceof Aware) {\n\t\t\tif (bean instanceof BeanNameAware beanNameAware) {\n\t\t\t\tbeanNameAware.setBeanName(beanName);\n\t\t\t}\n\t\t\tif (bean instanceof BeanClassLoaderAware beanClassLoaderAware) {\n\t\t\t\tClassLoader bcl = getBeanClassLoader();\n\t\t\t\tif (bcl != null) {\n\t\t\t\t\tbeanClassLoaderAware.setBeanClassLoader(bcl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bean instanceof BeanFactoryAware beanFactoryAware) {\n\t\t\t\tbeanFactoryAware.setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Give a bean a chance to initialize itself after all its properties are set,\n\t * and a chance to know about its owning bean factory (this object).\n\t * <p>This means checking whether the bean implements {@link InitializingBean}\n\t * or defines any custom init methods, and invoking the necessary callback(s)\n\t * if it does.\n\t * @param beanName the bean name in the factory (for debugging purposes)\n\t * @param bean the new bean instance we may need to initialize\n\t * @param mbd the merged bean definition that the bean was created with\n\t * (can also be {@code null}, if given an existing bean instance)\n\t * @throws Throwable if thrown by init methods or by the invocation process\n\t * @see #invokeCustomInitMethod\n\t */\n\tprotected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd)\n\t\t\tthrows Throwable {\n\n\t\tboolean isInitializingBean = (bean instanceof InitializingBean);\n\t\tif (isInitializingBean && (mbd == null || !mbd.hasAnyExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\t((InitializingBean) bean).afterPropertiesSet();\n\t\t}\n\n\t\tif (mbd != null && bean.getClass() != NullBean.class) {\n\t\t\tString[] initMethodNames = mbd.getInitMethodNames();\n\t\t\tif (initMethodNames != null) {\n\t\t\t\tfor (String initMethodName : initMethodNames) {\n\t\t\t\t\tif (StringUtils.hasLength(initMethodName) &&\n\t\t\t\t\t\t\t!(isInitializingBean && \"afterPropertiesSet\".equals(initMethodName)) &&\n\t\t\t\t\t\t\t!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) {\n\t\t\t\t\t\tinvokeCustomInitMethod(beanName, bean, mbd, initMethodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the specified custom init method on the given bean.\n\t * <p>Called by {@link #invokeInitMethods(String, Object, RootBeanDefinition)}.\n\t * <p>Can be overridden in subclasses for custom resolution of init methods\n\t * with arguments.\n\t * @see #invokeInitMethods\n\t */\n\tprotected void invokeCustomInitMethod(String beanName, Object bean, RootBeanDefinition mbd, String initMethodName)\n\t\t\tthrows Throwable {\n\n\t\tClass<?> beanClass = bean.getClass();\n\t\tMethodDescriptor descriptor = MethodDescriptor.create(beanName, beanClass, initMethodName);\n\t\tString methodName = descriptor.methodName();\n\n\t\tMethod initMethod = (mbd.isNonPublicAccessAllowed() ?\n\t\t\t\tBeanUtils.findMethod(descriptor.declaringClass(), methodName) :\n\t\t\t\tClassUtils.getMethodIfAvailable(beanClass, methodName));\n\n\t\tif (initMethod == null) {\n\t\t\tif (mbd.isEnforceInitMethod()) {\n\t\t\t\tthrow new BeanDefinitionValidationException(\"Could not find an init method named '\" +\n\t\t\t\t\t\tmethodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"No default init method named '\" + methodName +\n\t\t\t\t\t\t\t\"' found on bean with name '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t\t// Ignore non-existent default lifecycle methods.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking init method '\" + methodName + \"' on bean with name '\" + beanName + \"'\");\n\t\t}\n\t\tMethod methodToInvoke = ClassUtils.getPubliclyAccessibleMethodIfPossible(initMethod, beanClass);\n\n\t\ttry {\n\t\t\tReflectionUtils.makeAccessible(methodToInvoke);\n\t\t\tmethodToInvoke.invoke(bean);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\tthrow ex.getTargetException();\n\t\t}\n\t}\n\n\n\t/**\n\t * Applies the {@code postProcessAfterInitialization} callback of all\n\t * registered BeanPostProcessors, giving them a chance to post-process the\n\t * object obtained from FactoryBeans (for example, to auto-proxy them).\n\t * @see #applyBeanPostProcessorsAfterInitialization\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\t@Override\n\tprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) {\n\t\treturn applyBeanPostProcessorsAfterInitialization(object, beanName);\n\t}\n\n\t/**\n\t * Overridden to clear FactoryBean instance cache as well.\n\t */\n\t@Override\n\tprotected void removeSingleton(String beanName) {\n\t\tsuper.removeSingleton(beanName);\n\t\tthis.factoryBeanInstanceCache.remove(beanName);\n\t}\n\n\t/**\n\t * Overridden to clear FactoryBean instance cache as well.\n\t */\n\t@Override\n\tprotected void clearSingletonCache() {\n\t\tsuper.clearSingletonCache();\n\t\tthis.factoryBeanInstanceCache.clear();\n\t}\n\n\t/**\n\t * Expose the logger to collaborating delegates.\n\t * @since 5.0.7\n\t */\n\tLog getLogger() {\n\t\treturn logger;\n\t}\n\n\n\t/**\n\t * {@link RootBeanDefinition} subclass for {@code #createBean} calls with\n\t * flexible selection of a Kotlin primary / single public / single non-public\n\t * constructor candidate in addition to the default constructor.\n\t * @see BeanUtils#getResolvableConstructor(Class)\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class CreateFromClassBeanDefinition extends RootBeanDefinition {\n\n\t\tpublic CreateFromClassBeanDefinition(Class<?> beanClass) {\n\t\t\tsuper(beanClass);\n\t\t}\n\n\t\tpublic CreateFromClassBeanDefinition(CreateFromClassBeanDefinition original) {\n\t\t\tsuper(original);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Constructor<?>[] getPreferredConstructors() {\n\t\t\tConstructor<?>[] fromAttribute = super.getPreferredConstructors();\n\t\t\tif (fromAttribute != null) {\n\t\t\t\treturn fromAttribute;\n\t\t\t}\n\t\t\treturn ConstructorResolver.determinePreferredConstructors(getBeanClass());\n\t\t}\n\n\t\t@Override\n\t\tpublic RootBeanDefinition cloneBeanDefinition() {\n\t\t\treturn new CreateFromClassBeanDefinition(this);\n\t\t}\n\t}\n\n\n\t/**\n\t * Special DependencyDescriptor variant for Spring's good old autowire=\"byType\" mode.\n\t * Always optional; never considering the parameter name for choosing a primary candidate.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class AutowireByTypeDependencyDescriptor extends DependencyDescriptor {\n\n\t\tpublic AutowireByTypeDependencyDescriptor(MethodParameter methodParameter, boolean eager) {\n\t\t\tsuper(methodParameter, false, eager);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic String getDependencyName() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link MethodCallback} used to find {@link FactoryBean} type information.\n\t */\n\tprivate static class FactoryBeanMethodTypeFinder implements MethodCallback {\n\n\t\tprivate final String factoryMethodName;\n\n\t\tprivate ResolvableType result = ResolvableType.NONE;\n\n\t\tFactoryBeanMethodTypeFinder(String factoryMethodName) {\n\t\t\tthis.factoryMethodName = factoryMethodName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void doWith(Method method) throws IllegalArgumentException {\n\t\t\tif (isFactoryBeanMethod(method)) {\n\t\t\t\tResolvableType returnType = ResolvableType.forMethodReturnType(method);\n\t\t\t\tResolvableType candidate = returnType.as(FactoryBean.class).getGeneric();\n\t\t\t\tif (this.result == ResolvableType.NONE) {\n\t\t\t\t\tthis.result = candidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tClass<?> resolvedResult = this.result.resolve();\n\t\t\t\t\tClass<?> commonAncestor = ClassUtils.determineCommonAncestor(candidate.resolve(), resolvedResult);\n\t\t\t\t\tif (!ObjectUtils.nullSafeEquals(resolvedResult, commonAncestor)) {\n\t\t\t\t\t\tthis.result = ResolvableType.forClass(commonAncestor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isFactoryBeanMethod(Method method) {\n\t\t\treturn (method.getName().equals(this.factoryMethodName) &&\n\t\t\t\t\tFactoryBean.class.isAssignableFrom(method.getReturnType()));\n\t\t}\n\n\t\tResolvableType getResult() {\n\t\t\tClass<?> resolved = this.result.resolve();\n\t\t\tboolean foundResult = resolved != null && resolved != Object.class;\n\t\t\treturn (foundResult ? this.result : ResolvableType.NONE);\n\t\t}\n\t}\n\n}\n"
    },
    {
        "index": 6,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "4f260a451102e613764e99f50b69736ecb315fbc",
        "before": "/*\n * Copyright 2002-2023 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type.classreading;\n\nimport java.io.IOException;\n\nimport org.springframework.core.io.Resource;\n\n/**\n * Factory interface for {@link MetadataReader} instances.\n * Allows for caching a MetadataReader per original resource.\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see SimpleMetadataReaderFactory\n * @see CachingMetadataReaderFactory\n */\npublic interface MetadataReaderFactory {\n\n\t/**\n\t * Obtain a MetadataReader for the given class name.\n\t * @param className the class name (to be resolved to a \".class\" file)\n\t * @return a holder for the ClassReader instance (never {@code null})\n\t * @throws ClassFormatException in case of an incompatible class format\n\t * @throws IOException in case of I/O failure\n\t */\n\tMetadataReader getMetadataReader(String className) throws IOException;\n\n\t/**\n\t * Obtain a MetadataReader for the given resource.\n\t * @param resource the resource (pointing to a \".class\" file)\n\t * @return a holder for the ClassReader instance (never {@code null})\n\t * @throws ClassFormatException in case of an incompatible class format\n\t * @throws IOException in case of I/O failure\n\t */\n\tMetadataReader getMetadataReader(Resource resource) throws IOException;\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type.classreading;\n\nimport java.io.IOException;\n\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.lang.Nullable;\n\n/**\n * Factory interface for {@link MetadataReader} instances.\n * Allows for caching a MetadataReader per original resource.\n *\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @since 2.5\n * @see SimpleMetadataReaderFactory\n * @see CachingMetadataReaderFactory\n */\npublic interface MetadataReaderFactory {\n\n\t/**\n\t * Obtain a MetadataReader for the given class name.\n\t * @param className the class name (to be resolved to a \".class\" file)\n\t * @return a holder for the ClassReader instance (never {@code null})\n\t * @throws ClassFormatException in case of an incompatible class format\n\t * @throws IOException in case of I/O failure\n\t */\n\tMetadataReader getMetadataReader(String className) throws IOException;\n\n\t/**\n\t * Obtain a MetadataReader for the given resource.\n\t * @param resource the resource (pointing to a \".class\" file)\n\t * @return a holder for the ClassReader instance (never {@code null})\n\t * @throws ClassFormatException in case of an incompatible class format\n\t * @throws IOException in case of I/O failure\n\t */\n\tMetadataReader getMetadataReader(Resource resource) throws IOException;\n\n\t/**\n\t * Create a default {@link MetadataReaderFactory} implementation that's suitable\n\t * for the current JVM.\n\t * @return a new factory instance\n\t * @since 7.0\n\t */\n\tstatic MetadataReaderFactory create(@Nullable ResourceLoader resourceLoader) {\n\t\treturn MetadataReaderFactoryDelegate.create(resourceLoader);\n\t}\n\n\t/**\n\t * Create a default {@link MetadataReaderFactory} implementation that's suitable\n\t * for the current JVM.\n\t * @return a new factory instance\n\t * @since 7.0\n\t */\n\tstatic MetadataReaderFactory create(@Nullable ClassLoader classLoader) {\n\t\treturn MetadataReaderFactoryDelegate.create(classLoader);\n\t}\n}\n"
    },
    {
        "index": 7,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "b9cf03f8f021ea4ad31d09ad463d48c4dbfa66e2",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@link BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// 1) JVM runtime\n\t\t// 2) AOT processing\n\t\t// 3) AOT runtime\n\n\t\tString beanName = handler.getBeanName();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\tif (beanName != null) {\n\t\t\t\t// We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We will later generate a name for the nonexistent bean, but since NullAway\n\t\t\t\t// will reject leaving the beanName set to null, we set it to a placeholder.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to override bean: there is no bean to replace \\\n\t\t\t\t\t\twith name [%s] and type [%s].\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType()));\n\t\t\t}\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that doesn't implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * and {@link BeanOverrideHandler#getBeanType() type} is registered.\n\t * <p>If so, put the {@link BeanOverrideHandler} in the early tracking map.\n\t * <p>The map will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the {@link WrapEarlyBeanPostProcessor#getEarlyBeanReference}\n\t * phase.\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tif (beanName == null) {\n\t\t\t// We are wrapping an existing bean by-type.\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount == 1) {\n\t\t\t\tbeanName = candidateNames.iterator().next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\t\t\tif (primaryCandidate != null) {\n\t\t\t\t\tbeanName = primaryCandidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tField field = handler.getField();\n\t\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\t\tUnable to select a bean to override by wrapping: found %d bean instances of type %s \\\n\t\t\t\t\t\t\t(as required by annotated field '%s.%s')%s\"\"\"\n\t\t\t\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\t\tfield.getName(), (candidateCount > 0 ? \": \" + candidateNames : \"\")));\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t}\n\t\telse {\n\t\t\t// We are wrapping an existing bean by-name.\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to override bean by wrapping: there is no existing bean \\\n\t\t\t\t\t\twith name [%s] and type [%s].\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, beanType));\n\t\t\t}\n\t\t}\n\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: no beans of type %s (as required by annotated field '%s.%s')\"\n\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tUnable to select a bean to override: found %s beans of type %s \\\n\t\t\t\t(as required by annotated field '%s.%s'): %s\"\"\"\n\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tClass<?> producedType = beanFactory.getType(beanName, false);\n\t\t\tif (type.equals(producedType)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of bean names.\n\t * <p>Honors both <em>primary</em> and <em>fallback</em> semantics.\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#determinePrimaryCandidate(Map, Class)\n\t */\n\t@Nullable\n\tprivate static String determinePrimaryCandidate(\n\t\t\tConfigurableListableBeanFactory beanFactory, Set<String> candidateBeanNames, Class<?> beanType) {\n\n\t\tif (candidateBeanNames.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(beanType, candidateBeanNames.size(),\n\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeanNames);\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\t\tif (!beanDefinition.isFallback()) {\n\t\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\t\t// More than one non-fallback bean found among candidates.\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@link BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that doesn't implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@link BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// 1) JVM runtime\n\t\t// 2) AOT processing\n\t\t// 3) AOT runtime\n\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\tif (beanName != null) {\n\t\t\t\t// We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We will later generate a name for the nonexistent bean, but since NullAway\n\t\t\t\t// will reject leaving the beanName set to null, we set it to a placeholder.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to replace bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType(),\n\t\t\t\t\t\t\t\tfield.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that does not implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * and {@link BeanOverrideHandler#getBeanType() type} is registered.\n\t * <p>If so, put the {@link BeanOverrideHandler} in the early tracking map.\n\t * <p>The map will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the {@link WrapEarlyBeanPostProcessor#getEarlyBeanReference}\n\t * phase.\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tif (beanName == null) {\n\t\t\t// We are wrapping an existing bean by-type.\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount == 1) {\n\t\t\t\tbeanName = candidateNames.iterator().next();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\t\t\tif (primaryCandidate != null) {\n\t\t\t\t\tbeanName = primaryCandidate;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString message = \"Unable to select a bean to wrap: \";\n\t\t\t\t\tif (candidateCount == 0) {\n\t\t\t\t\t\tmessage += \"there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmessage += \"found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\t\t\tfield.getName(), candidateNames);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new IllegalStateException(message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t}\n\t\telse {\n\t\t\t// We are wrapping an existing bean by-name.\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to wrap bean: there is no bean with name '%s' and type %s \\\n\t\t\t\t\t\t(as required by field '%s.%s').\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\t\t\tfield.getName()));\n\t\t\t}\n\t\t}\n\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tField field = handler.getField();\n\t\tResolvableType beanType = handler.getBeanType();\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: there are no beans of type %s (as required by field '%s.%s').\"\n\t\t\t\t\t\t\t.formatted(beanType, field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryCandidate = determinePrimaryCandidate(beanFactory, candidateNames, beanType.toClass());\n\t\tif (primaryCandidate != null) {\n\t\t\treturn primaryCandidate;\n\t\t}\n\n\t\tthrow new IllegalStateException(\n\t\t\t\t\"Unable to select a bean to override: found %d beans of type %s (as required by field '%s.%s'): %s\"\n\t\t\t\t\t.formatted(candidateCount, beanType, field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tClass<?> producedType = beanFactory.getType(beanName, false);\n\t\t\tif (type.equals(producedType)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Determine the primary candidate in the given set of bean names.\n\t * <p>Honors both <em>primary</em> and <em>fallback</em> semantics.\n\t * @return the name of the primary candidate, or {@code null} if none found\n\t * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#determinePrimaryCandidate(Map, Class)\n\t */\n\t@Nullable\n\tprivate static String determinePrimaryCandidate(\n\t\t\tConfigurableListableBeanFactory beanFactory, Set<String> candidateBeanNames, Class<?> beanType) {\n\n\t\tif (candidateBeanNames.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString primaryBeanName = null;\n\t\t// First pass: identify unique primary candidate\n\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\tthrow new NoUniqueBeanDefinitionException(beanType, candidateBeanNames.size(),\n\t\t\t\t\t\t\t\"more than one 'primary' bean found among candidates: \" + candidateBeanNames);\n\t\t\t\t\t}\n\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Second pass: identify unique non-fallback candidate\n\t\tif (primaryBeanName == null) {\n\t\t\tfor (String candidateBeanName : candidateBeanNames) {\n\t\t\t\tif (beanFactory.containsBeanDefinition(candidateBeanName)) {\n\t\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(candidateBeanName);\n\t\t\t\t\tif (!beanDefinition.isFallback()) {\n\t\t\t\t\t\tif (primaryBeanName != null) {\n\t\t\t\t\t\t\t// More than one non-fallback bean found among candidates.\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprimaryBeanName = candidateBeanName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn primaryBeanName;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@link BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that does not implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n"
    },
    {
        "index": 8,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "7a6e401d176c53226f72642532abcd1316bdb7ed",
        "before": "[[spring-testing-annotation-beanoverriding-testbean]]\n= `@TestBean`\n\n`@TestBean` is used on a non-static field in a test class to override a specific bean in\nthe test's `ApplicationContext` with an instance provided by a factory method.\n\nThe associated factory method name is derived from the annotated field's name, or the\nbean name if specified. The factory method must be `static`, accept no arguments, and\nhave a return type compatible with the type of the bean to override. To make things more\nexplicit, or if you'd rather use a different name, the annotation allows for a specific\nmethod name to be provided.\n\nBy default, the annotated field's type is used to search for candidate beans to override.\nIf multiple candidates match, `@Qualifier` can be provided to narrow the candidate to\noverride. Alternatively, a candidate whose bean name matches the name of the field will\nmatch.\n\nA bean will be created if a corresponding bean does not exist. However, if you would like\nfor the test to fail when a corresponding bean does not exist, you can set the\n`enforceOverride` attribute to `true`  for example, `@TestBean(enforceOverride = true)`.\n\nTo use a by-name override rather than a by-type override, specify the `name` attribute\nof the annotation.\n\n[WARNING]\n====\nQualifiers, including the name of the field, are used to determine if a separate\n`ApplicationContext` needs to be created. If you are using this feature to override the\nsame bean in several tests, make sure to name the field consistently to avoid creating\nunnecessary contexts.\n====\n\nThe following example shows how to use the default behavior of the `@TestBean` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass OverrideBeanTests {\n\t\t@TestBean // <1>\n\t\tprivate CustomService customService;\n\n\t\t// test case body...\n\n\t\tprivate static CustomService customService() { // <2>\n\t\t\treturn new MyFakeCustomService();\n\t\t}\n\t}\n----\n<1> Mark a field for overriding the bean with type `CustomService`.\n<2> The result of this static method will be used as the instance and injected into the field.\n======\n\nIn the example above, we are overriding the bean with type `CustomService`. If more than\none bean of that type exists, the bean named `customService` is considered. Otherwise,\nthe test will fail, and you will need to provide a qualifier of some sort to identify\nwhich of the `CustomService` beans you want to override.\n\nThe following example uses a by-name lookup, rather than a by-type lookup:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass OverrideBeanTests {\n\t\t@TestBean(name = \"service\", methodName = \"createCustomService\") // <1>\n\t\tprivate CustomService customService;\n\n\t\t// test case body...\n\n\t\tprivate static CustomService createCustomService() { // <2>\n\t\t\treturn new MyFakeCustomService();\n\t\t}\n\t}\n----\n<1> Mark a field for overriding the bean with name `service`, and specify that the\n    factory method is named `createCustomService`.\n<2> The result of this static method will be used as the instance and injected into the field.\n======\n\n[TIP]\n====\nSpring searches for the factory method to invoke in the test class, in the test class\nhierarchy, and in the enclosing class hierarchy for a `@Nested` test class.\n\nAlternatively, a factory method in an external class can be referenced via its\nfully-qualified method name following the syntax `<fully-qualified class name>#<method name>`\n for example, `methodName = \"org.example.TestUtils#createCustomService\"`.\n====\n\n[TIP]\n====\nOnly _singleton_ beans can be overridden. Any attempt to override a non-singleton bean\nwill result in an exception.\n\nWhen overriding a bean created by a `FactoryBean`, the `FactoryBean` will be replaced\nwith a singleton bean corresponding to the value returned from the `@TestBean` factory\nmethod.\n====\n",
        "after": "[[spring-testing-annotation-beanoverriding-testbean]]\n= `@TestBean`\n\n`@TestBean` is used on a non-static field in a test class to override a specific bean in\nthe test's `ApplicationContext` with an instance provided by a factory method.\n\nThe associated factory method name is derived from the annotated field's name, or the\nbean name if specified. The factory method must be `static`, accept no arguments, and\nhave a return type compatible with the type of the bean to override. To make things more\nexplicit, or if you'd rather use a different name, the annotation allows for a specific\nmethod name to be provided.\n\nBy default, the annotated field's type is used to search for candidate beans to override.\nIf multiple candidates match, `@Qualifier` can be provided to narrow the candidate to\noverride. Alternatively, a candidate whose bean name matches the name of the field will\nmatch.\n\nA bean will be created if a corresponding bean does not exist. However, if you would like\nfor the test to fail when a corresponding bean does not exist, you can set the\n`enforceOverride` attribute to `true`  for example, `@TestBean(enforceOverride = true)`.\n\nTo use a by-name override rather than a by-type override, specify the `name` attribute\nof the annotation.\n\n[WARNING]\n====\nQualifiers, including the name of the field, are used to determine if a separate\n`ApplicationContext` needs to be created. If you are using this feature to override the\nsame bean in several tests, make sure to name the field consistently to avoid creating\nunnecessary contexts.\n====\n\n[NOTE]\n====\nThere are no restrictions on the visibility of `@TestBean` fields or factory methods.\n\nSuch fields and methods can therefore be `public`, `protected`, package-private (default\nvisibility), or `private` depending on the needs or coding practices of the project.\n====\n\nThe following example shows how to use the default behavior of the `@TestBean` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass OverrideBeanTests {\n\t\t@TestBean // <1>\n\t\tCustomService customService;\n\n\t\t// test case body...\n\n\t\tstatic CustomService customService() { // <2>\n\t\t\treturn new MyFakeCustomService();\n\t\t}\n\t}\n----\n<1> Mark a field for overriding the bean with type `CustomService`.\n<2> The result of this static method will be used as the instance and injected into the field.\n======\n\nIn the example above, we are overriding the bean with type `CustomService`. If more than\none bean of that type exists, the bean named `customService` is considered. Otherwise,\nthe test will fail, and you will need to provide a qualifier of some sort to identify\nwhich of the `CustomService` beans you want to override.\n\nThe following example uses a by-name lookup, rather than a by-type lookup:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass OverrideBeanTests {\n\t\t@TestBean(name = \"service\", methodName = \"createCustomService\") // <1>\n\t\tCustomService customService;\n\n\t\t// test case body...\n\n\t\tstatic CustomService createCustomService() { // <2>\n\t\t\treturn new MyFakeCustomService();\n\t\t}\n\t}\n----\n<1> Mark a field for overriding the bean with name `service`, and specify that the\n    factory method is named `createCustomService`.\n<2> The result of this static method will be used as the instance and injected into the field.\n======\n\n[TIP]\n====\nSpring searches for the factory method to invoke in the test class, in the test class\nhierarchy, and in the enclosing class hierarchy for a `@Nested` test class.\n\nAlternatively, a factory method in an external class can be referenced via its\nfully-qualified method name following the syntax `<fully-qualified class name>#<method name>`\n for example, `methodName = \"org.example.TestUtils#createCustomService\"`.\n====\n\n[TIP]\n====\nOnly _singleton_ beans can be overridden. Any attempt to override a non-singleton bean\nwill result in an exception.\n\nWhen overriding a bean created by a `FactoryBean`, the `FactoryBean` will be replaced\nwith a singleton bean corresponding to the value returned from the `@TestBean` factory\nmethod.\n====\n"
    },
    {
        "index": 9,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "c2c6bb25c68c231e8eb250809442987512755d62",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@link BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// 1) JVM runtime\n\t\t// 2) AOT processing\n\t\t// 3) AOT runtime\n\n\t\tString beanName = handler.getBeanName();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\tif (beanName != null) {\n\t\t\t\t// We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We will later generate a name for the nonexistent bean, but since NullAway\n\t\t\t\t// will reject leaving the beanName set to null, we set it to a placeholder.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to override bean: there is no bean to replace \\\n\t\t\t\t\t\twith name [%s] and type [%s].\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType()));\n\t\t\t}\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that doesn't implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * and {@link BeanOverrideHandler#getBeanType() type} is registered.\n\t * <p>If so, put the {@link BeanOverrideHandler} in the early tracking map.\n\t * <p>The map will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the {@link WrapEarlyBeanPostProcessor#getEarlyBeanReference}\n\t * phase.\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tif (beanName == null) {\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount != 1) {\n\t\t\t\tField field = handler.getField();\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to select a bean to override by wrapping: found %d bean instances of type %s \\\n\t\t\t\t\t\t(as required by annotated field '%s.%s')%s\"\"\"\n\t\t\t\t\t\t.formatted(candidateCount, handler.getBeanType(),\n\t\t\t\t\t\t\tfield.getDeclaringClass().getSimpleName(), field.getName(),\n\t\t\t\t\t\t\t(candidateCount > 0 ? \": \" + candidateNames : \"\")));\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(candidateNames.iterator().next());\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to override bean by wrapping: there is no existing bean \\\n\t\t\t\t\t\twith name [%s] and type [%s].\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType()));\n\t\t\t}\n\t\t}\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tField field = handler.getField();\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: no beans of type %s (as required by annotated field '%s.%s')\"\n\t\t\t\t\t\t\t.formatted(handler.getBeanType(), field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tField field = handler.getField();\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tUnable to select a bean to override: found %s beans of type %s \\\n\t\t\t\t(as required by annotated field '%s.%s'): %s\"\"\"\n\t\t\t\t\t.formatted(candidateCount, handler.getBeanType(), field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tObject attribute = beanDefinition.getAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE);\n\t\t\tif (resolvableType.equals(attribute) || type.equals(attribute)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@link BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that doesn't implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.test.context.bean.override;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.aop.scope.ScopedProxyUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.DependencyDescriptor;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultBeanNameGenerator;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.aot.AbstractAotProcessor;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * A {@link BeanFactoryPostProcessor} implementation that processes identified\n * use of {@link BeanOverride @BeanOverride} and adapts the {@link BeanFactory}\n * accordingly.\n *\n * <p>For each override, the bean factory is prepared according to the chosen\n * {@linkplain BeanOverrideStrategy override strategy}. The bean override instance\n * is created, if necessary, and the related infrastructure is updated to allow\n * the bean override instance to be injected into the corresponding\n * {@linkplain BeanOverrideHandler#getField() field} of the test class.\n *\n * <p>This processor does not work against a particular test class but rather\n * only prepares the bean factory for the identified, unique set of bean overrides.\n *\n * @author Simon Basl\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.2\n */\nclass BeanOverrideBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n\tprivate static final String PSEUDO_BEAN_NAME_PLACEHOLDER = \"<<< PSEUDO BEAN NAME PLACEHOLDER >>>\";\n\n\tprivate static final BeanNameGenerator beanNameGenerator = DefaultBeanNameGenerator.INSTANCE;\n\n\tprivate final Set<BeanOverrideHandler> beanOverrideHandlers;\n\n\tprivate final BeanOverrideRegistry beanOverrideRegistry;\n\n\n\t/**\n\t * Create a new {@code BeanOverrideBeanFactoryPostProcessor} with the supplied\n\t * set of {@link BeanOverrideHandler BeanOverrideHandlers} to process, using\n\t * the given {@link BeanOverrideRegistry}.\n\t * @param beanOverrideHandlers the bean override handlers to process\n\t * @param beanOverrideRegistry the registry used to track bean override handlers\n\t */\n\tBeanOverrideBeanFactoryPostProcessor(Set<BeanOverrideHandler> beanOverrideHandlers,\n\t\t\tBeanOverrideRegistry beanOverrideRegistry) {\n\n\t\tthis.beanOverrideHandlers = beanOverrideHandlers;\n\t\tthis.beanOverrideRegistry = beanOverrideRegistry;\n\t}\n\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn Ordered.LOWEST_PRECEDENCE - 10;\n\t}\n\n\t@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n\t\tfor (BeanOverrideHandler handler : this.beanOverrideHandlers) {\n\t\t\tregisterBeanOverride(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void registerBeanOverride(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tField field = handler.getField();\n\t\tAssert.state(!BeanFactoryUtils.isFactoryDereference(beanName),() -> \"\"\"\n\t\t\t\tUnable to override bean '%s' for field '%s.%s': a FactoryBean cannot be overridden. \\\n\t\t\t\tTo override the bean created by the FactoryBean, remove the '&' prefix.\"\"\".formatted(\n\t\t\t\t\tbeanName, field.getDeclaringClass().getSimpleName(), field.getName()));\n\n\t\tswitch (handler.getStrategy()) {\n\t\t\tcase REPLACE -> replaceOrCreateBean(beanFactory, handler, true);\n\t\t\tcase REPLACE_OR_CREATE -> replaceOrCreateBean(beanFactory, handler, false);\n\t\t\tcase WRAP -> wrapBean(beanFactory, handler);\n\t\t}\n\t}\n\n\tprivate void replaceOrCreateBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\t// NOTE: This method supports 3 distinct scenarios which must be accounted for.\n\t\t//\n\t\t// 1) JVM runtime\n\t\t// 2) AOT processing\n\t\t// 3) AOT runtime\n\n\t\tString beanName = handler.getBeanName();\n\t\tBeanDefinition existingBeanDefinition = null;\n\t\tif (beanName == null) {\n\t\t\tbeanName = getBeanNameForType(beanFactory, handler, requireExistingBean);\n\t\t\tif (beanName != null) {\n\t\t\t\t// We are overriding an existing bean by-type.\n\t\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\t\t// If we are overriding a manually registered singleton, we won't find\n\t\t\t\t// an existing bean definition.\n\t\t\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We will later generate a name for the nonexistent bean, but since NullAway\n\t\t\t\t// will reject leaving the beanName set to null, we set it to a placeholder.\n\t\t\t\tbeanName = PSEUDO_BEAN_NAME_PLACEHOLDER;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (candidates.contains(beanName)) {\n\t\t\t\t// We are overriding an existing bean by-name.\n\t\t\t\texistingBeanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t}\n\t\t\telse if (requireExistingBean) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to override bean: there is no bean to replace \\\n\t\t\t\t\t\twith name [%s] and type [%s].\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType()));\n\t\t\t}\n\t\t}\n\n\t\tif (existingBeanDefinition != null) {\n\t\t\t// Validate the existing bean definition.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\", \"AOT processing\", and \"AOT runtime\".\n\t\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\t}\n\t\telse if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING)) {\n\t\t\t// There was no existing bean definition, but during \"AOT processing\" we\n\t\t\t// do not register the \"pseudo\" bean definition since our AOT support\n\t\t\t// cannot automatically convert that to a functional bean definition for\n\t\t\t// use at \"AOT runtime\". Furthermore, by not registering a bean definition\n\t\t\t// for a nonexistent bean, we allow the \"JVM runtime\" and \"AOT runtime\"\n\t\t\t// to operate the same in the following else-block.\n\t\t}\n\t\telse {\n\t\t\t// There was no existing bean definition, so we register a \"pseudo\" bean\n\t\t\t// definition to ensure that a suitable bean definition exists for the given\n\t\t\t// bean name for proper autowiring candidate resolution.\n\t\t\t//\n\t\t\t// Applies during \"JVM runtime\" and \"AOT runtime\".\n\n\t\t\tif (!(beanFactory instanceof BeanDefinitionRegistry registry)) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\t\"that doesn't implement BeanDefinitionRegistry: \" + beanFactory.getClass().getName());\n\t\t\t}\n\n\t\t\tRootBeanDefinition pseudoBeanDefinition = createPseudoBeanDefinition(handler);\n\n\t\t\t// Generate a name for the nonexistent bean.\n\t\t\tif (PSEUDO_BEAN_NAME_PLACEHOLDER.equals(beanName)) {\n\t\t\t\tbeanName = beanNameGenerator.generateBeanName(pseudoBeanDefinition, registry);\n\t\t\t}\n\n\t\t\tregistry.registerBeanDefinition(beanName, pseudoBeanDefinition);\n\t\t}\n\n\t\tObject override = handler.createOverrideInstance(beanName, existingBeanDefinition, null, beanFactory);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\n\t\t// Now we have an instance (the override) that we can manually register as a singleton.\n\t\t//\n\t\t// However, we need to remove any existing singleton instance -- for example, a\n\t\t// manually registered singleton.\n\t\t//\n\t\t// As a bonus, by manually registering a singleton during \"AOT processing\", we allow\n\t\t// GenericApplicationContext's preDetermineBeanType() method to transparently register\n\t\t// runtime hints for a proxy generated by the above createOverrideInstance() invocation --\n\t\t// for example, when @MockitoBean creates a mock based on a JDK dynamic proxy.\n\t\tif (beanFactory.containsSingleton(beanName)) {\n\t\t\tdestroySingleton(beanFactory, beanName);\n\t\t}\n\t\tbeanFactory.registerSingleton(beanName, override);\n\t}\n\n\t/**\n\t * Check that a bean with the specified {@link BeanOverrideHandler#getBeanName() name}\n\t * and {@link BeanOverrideHandler#getBeanType() type} is registered.\n\t * <p>If so, put the {@link BeanOverrideHandler} in the early tracking map.\n\t * <p>The map will later be checked to see if a given bean should be wrapped\n\t * upon creation, during the {@link WrapEarlyBeanPostProcessor#getEarlyBeanReference}\n\t * phase.\n\t */\n\tprivate void wrapBean(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler) {\n\t\tString beanName = handler.getBeanName();\n\t\tif (beanName == null) {\n\t\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\t\tint candidateCount = candidateNames.size();\n\t\t\tif (candidateCount != 1) {\n\t\t\t\tField field = handler.getField();\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to select a bean to override by wrapping: found %d bean instances of type %s \\\n\t\t\t\t\t\t(as required by annotated field '%s.%s')%s\"\"\"\n\t\t\t\t\t\t.formatted(candidateCount, handler.getBeanType(),\n\t\t\t\t\t\t\tfield.getDeclaringClass().getSimpleName(), field.getName(),\n\t\t\t\t\t\t\t(candidateCount > 0 ? \": \" + candidateNames : \"\")));\n\t\t\t}\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(candidateNames.iterator().next());\n\t\t}\n\t\telse {\n\t\t\tSet<String> candidates = getExistingBeanNamesByType(beanFactory, handler, false);\n\t\t\tif (!candidates.contains(beanName)) {\n\t\t\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\t\t\tUnable to override bean by wrapping: there is no existing bean \\\n\t\t\t\t\t\twith name [%s] and type [%s].\"\"\"\n\t\t\t\t\t\t\t.formatted(beanName, handler.getBeanType()));\n\t\t\t}\n\t\t}\n\t\tvalidateBeanDefinition(beanFactory, beanName);\n\t\tthis.beanOverrideRegistry.registerBeanOverrideHandler(handler, beanName);\n\t}\n\n\t@Nullable\n\tprivate String getBeanNameForType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean requireExistingBean) {\n\n\t\tSet<String> candidateNames = getExistingBeanNamesByType(beanFactory, handler, true);\n\t\tint candidateCount = candidateNames.size();\n\t\tif (candidateCount == 1) {\n\t\t\treturn candidateNames.iterator().next();\n\t\t}\n\t\telse if (candidateCount == 0) {\n\t\t\tif (requireExistingBean) {\n\t\t\t\tField field = handler.getField();\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Unable to override bean: no beans of type %s (as required by annotated field '%s.%s')\"\n\t\t\t\t\t\t\t.formatted(handler.getBeanType(), field.getDeclaringClass().getSimpleName(), field.getName()));\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tField field = handler.getField();\n\t\tthrow new IllegalStateException(\"\"\"\n\t\t\t\tUnable to select a bean to override: found %s beans of type %s \\\n\t\t\t\t(as required by annotated field '%s.%s'): %s\"\"\"\n\t\t\t\t\t.formatted(candidateCount, handler.getBeanType(), field.getDeclaringClass().getSimpleName(),\n\t\t\t\t\t\tfield.getName(), candidateNames));\n\t}\n\n\tprivate Set<String> getExistingBeanNamesByType(ConfigurableListableBeanFactory beanFactory, BeanOverrideHandler handler,\n\t\t\tboolean checkAutowiredCandidate) {\n\n\t\tResolvableType resolvableType = handler.getBeanType();\n\t\tClass<?> type = resolvableType.toClass();\n\n\t\t// Start with matching bean names for type, excluding FactoryBeans.\n\t\tSet<String> beanNames = new LinkedHashSet<>(\n\t\t\t\tArrays.asList(beanFactory.getBeanNamesForType(resolvableType, true, false)));\n\n\t\t// Add matching FactoryBeans as well.\n\t\tfor (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class, true, false)) {\n\t\t\tbeanName = BeanFactoryUtils.transformedBeanName(beanName);\n\t\t\tClass<?> producedType = beanFactory.getType(beanName, false);\n\t\t\tif (type.equals(producedType)) {\n\t\t\t\tbeanNames.add(beanName);\n\t\t\t}\n\t\t}\n\n\t\t// Filter out non-matching autowire candidates.\n\t\tif (checkAutowiredCandidate) {\n\t\t\tDependencyDescriptor descriptor = new DependencyDescriptor(handler.getField(), true);\n\t\t\tbeanNames.removeIf(beanName -> !beanFactory.isAutowireCandidate(beanName, descriptor));\n\t\t}\n\t\t// Filter out scoped proxy targets.\n\t\tbeanNames.removeIf(ScopedProxyUtils::isScopedTarget);\n\n\t\t// In case of multiple matches, fall back on the field's name as a last resort.\n\t\tif (beanNames.size() > 1) {\n\t\t\tString fieldName = handler.getField().getName();\n\t\t\tif (beanNames.contains(fieldName)) {\n\t\t\t\treturn Set.of(fieldName);\n\t\t\t}\n\t\t}\n\t\treturn beanNames;\n\t}\n\n\t/**\n\t * Create a pseudo-{@link BeanDefinition} for the supplied {@link BeanOverrideHandler},\n\t * whose {@linkplain RootBeanDefinition#getTargetType() target type} and\n\t * {@linkplain RootBeanDefinition#getQualifiedElement() qualified element} are\n\t * the {@linkplain BeanOverrideHandler#getBeanType() bean type} and\n\t * the {@linkplain BeanOverrideHandler#getField() field} of the {@code BeanOverrideHandler},\n\t * respectively.\n\t * <p>The returned bean definition should <strong>not</strong> be used to create\n\t * a bean instance but rather only for the purpose of having suitable bean\n\t * definition metadata available in the {@link BeanFactory} &mdash; for example,\n\t * for autowiring candidate resolution.\n\t */\n\tprivate static RootBeanDefinition createPseudoBeanDefinition(BeanOverrideHandler handler) {\n\t\tRootBeanDefinition definition = new RootBeanDefinition(handler.getBeanType().resolve());\n\t\tdefinition.setTargetType(handler.getBeanType());\n\t\tdefinition.setQualifiedElement(handler.getField());\n\t\treturn definition;\n\t}\n\n\t/**\n\t * Validate that the {@link BeanDefinition} for the supplied bean name is suitable\n\t * for being replaced by a bean override.\n\t * <p>If there is no registered {@code BeanDefinition} for the supplied bean name,\n\t * no validation is performed.\n\t */\n\tprivate static void validateBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\t// Due to https://github.com/spring-projects/spring-framework/issues/33800, we do NOT invoke\n\t\t// beanFactory.isSingleton(beanName), since doing so can result in a BeanCreationException for\n\t\t// certain beans -- for example, a Spring Data FactoryBean for a JpaRepository.\n\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\tAssert.state(beanDefinition.isSingleton(),\n\t\t\t\t\t() -> \"Unable to override bean '\" + beanName + \"': only singleton beans can be overridden.\");\n\t\t}\n\t}\n\n\tprivate static void destroySingleton(ConfigurableListableBeanFactory beanFactory, String beanName) {\n\t\tif (!(beanFactory instanceof DefaultListableBeanFactory dlbf)) {\n\t\t\tthrow new IllegalStateException(\"Cannot process bean override with a BeanFactory \" +\n\t\t\t\t\t\"that doesn't implement DefaultListableBeanFactory: \" + beanFactory.getClass().getName());\n\t\t}\n\t\tdlbf.destroySingleton(beanName);\n\t}\n\n}\n"
    },
    {
        "index": 10,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "4749d810db0261ce16ae5f32da6d375bb8087430",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.http.client;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.time.Duration;\nimport java.util.function.Function;\n\nimport io.netty.channel.ChannelOption;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport reactor.netty.http.client.HttpClient;\nimport reactor.netty.resources.ConnectionProvider;\nimport reactor.netty.resources.LoopResources;\n\nimport org.springframework.context.SmartLifecycle;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * Reactor-Netty implementation of {@link ClientHttpRequestFactory}.\n *\n * <p>This class implements {@link SmartLifecycle} and can be optionally declared\n * as a Spring-managed bean in order to support JVM Checkpoint Restore.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 6.2\n */\npublic class ReactorClientHttpRequestFactory implements ClientHttpRequestFactory, SmartLifecycle {\n\n\tprivate static final Log logger = LogFactory.getLog(ReactorClientHttpRequestFactory.class);\n\n\tprivate static final Function<HttpClient, HttpClient> defaultInitializer = client -> client.compress(true);\n\n\n\t@Nullable\n\tprivate final ReactorResourceFactory resourceFactory;\n\n\t@Nullable\n\tprivate final Function<HttpClient, HttpClient> mapper;\n\n\t@Nullable\n\tprivate Integer connectTimeout;\n\n\tprivate Duration readTimeout = Duration.ofSeconds(10);\n\n\tprivate Duration exchangeTimeout = Duration.ofSeconds(5);\n\n\t@Nullable\n\tprivate volatile HttpClient httpClient;\n\n\tprivate final Object lifecycleMonitor = new Object();\n\n\n\t/**\n\t * Constructor with default client, created via {@link HttpClient#create()},\n\t * and with {@link HttpClient#compress compression} enabled.\n\t */\n\tpublic ReactorClientHttpRequestFactory() {\n\t\tthis(defaultInitializer.apply(HttpClient.create()));\n\t}\n\n\t/**\n\t * Constructor with a given {@link HttpClient} instance.\n\t * @param client the client to use\n\t */\n\tpublic ReactorClientHttpRequestFactory(HttpClient client) {\n\t\tAssert.notNull(client, \"HttpClient must not be null\");\n\t\tthis.resourceFactory = null;\n\t\tthis.mapper = null;\n\t\tthis.httpClient = client;\n\t}\n\n\t/**\n\t * Constructor with externally managed Reactor Netty resources, including\n\t * {@link LoopResources} for event loop threads, and {@link ConnectionProvider}\n\t * for connection pooling.\n\t * <p>Generally, it is recommended to share resources for event loop\n\t * concurrency. This can be achieved either by participating in the JVM-wide,\n\t * global resources held in {@link reactor.netty.http.HttpResources}, or by\n\t * using a specific, shared set of resources through a\n\t * {@link ReactorResourceFactory} bean. The latter can ensure that resources\n\t * are shut down when the Spring ApplicationContext is stopped/closed and\n\t * restarted again (e.g. JVM checkpoint restore).\n\t * @param resourceFactory the resource factory to get resources from\n\t * @param mapper for further initialization of the client\n\t */\n\tpublic ReactorClientHttpRequestFactory(\n\t\t\tReactorResourceFactory resourceFactory, Function<HttpClient, HttpClient> mapper) {\n\n\t\tthis.resourceFactory = resourceFactory;\n\t\tthis.mapper = mapper;\n\t\tif (resourceFactory.isRunning()) {\n\t\t\tthis.httpClient = createHttpClient(resourceFactory, mapper);\n\t\t}\n\t}\n\n\tprivate HttpClient createHttpClient(ReactorResourceFactory factory, Function<HttpClient, HttpClient> mapper) {\n\t\tHttpClient client = HttpClient.create(factory.getConnectionProvider());\n\t\tclient = defaultInitializer.andThen(mapper).apply(client);\n\t\tclient = client.runOn(factory.getLoopResources());\n\t\tif (this.connectTimeout != null) {\n\t\t\tclient = client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t\treturn client;\n\t}\n\n\n\t/**\n\t * Set the underlying connect timeout value on the underlying client.\n\t * Effectively, a shortcut for\n\t * {@code httpClient.option(CONNECT_TIMEOUT_MILLIS, timeout)}.\n\t * <p>By default, set to 30 seconds.\n\t * @param connectTimeout the timeout value in millis; use 0 to never time out.\n\t * @see HttpClient#option(ChannelOption, Object)\n\t * @see ChannelOption#CONNECT_TIMEOUT_MILLIS\n\t * @see <a href=\"https://projectreactor.io/docs/netty/release/reference/index.html#connection-timeout\">Connection Timeout</a>\n\t */\n\tpublic void setConnectTimeout(int connectTimeout) {\n\t\tAssert.isTrue(connectTimeout >= 0, \"Timeout must be a non-negative value\");\n\t\tthis.connectTimeout = connectTimeout;\n\t\tHttpClient httpClient = this.httpClient;\n\t\tif (httpClient != null) {\n\t\t\tthis.httpClient = httpClient.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t}\n\n\t/**\n\t * Variant of {@link #setConnectTimeout(int)} with a {@link Duration} value.\n\t */\n\tpublic void setConnectTimeout(Duration connectTimeout) {\n\t\tAssert.notNull(connectTimeout, \"ConnectTimeout must not be null\");\n\t\tsetConnectTimeout((int) connectTimeout.toMillis());\n\t}\n\n\t/**\n\t * Set the underlying read timeout in milliseconds.\n\t * <p>Default is 10 seconds.\n\t */\n\tpublic void setReadTimeout(long readTimeout) {\n\t\tAssert.isTrue(readTimeout > 0, \"Timeout must be a positive value\");\n\t\tthis.readTimeout = Duration.ofMillis(readTimeout);\n\t}\n\n\t/**\n\t * Variant of {@link #setConnectTimeout(int)} with a {@link Duration} value.\n\t */\n\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tAssert.notNull(readTimeout, \"ReadTimeout must not be null\");\n\t\tsetReadTimeout((int) readTimeout.toMillis());\n\t}\n\n\t/**\n\t * Set the timeout for the HTTP exchange in milliseconds.\n\t * <p>Default is 5 seconds.\n\t */\n\tpublic void setExchangeTimeout(long exchangeTimeout) {\n\t\tAssert.isTrue(exchangeTimeout > 0, \"Timeout must be a positive value\");\n\t\tthis.exchangeTimeout = Duration.ofMillis(exchangeTimeout);\n\t}\n\n\t/**\n\t * Set the timeout for the HTTP exchange.\n\t * <p>Default is 5 seconds.\n\t */\n\tpublic void setExchangeTimeout(Duration exchangeTimeout) {\n\t\tAssert.notNull(exchangeTimeout, \"ExchangeTimeout must not be null\");\n\t\tsetExchangeTimeout((int) exchangeTimeout.toMillis());\n\t}\n\n\n\t@Override\n\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpClient client = this.httpClient;\n\t\tif (client == null) {\n\t\t\tAssert.state(this.resourceFactory != null && this.mapper != null,\n\t\t\t\t\t\"Expected HttpClient or ResourceFactory and mapper\");\n\t\t\tclient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t}\n\t\treturn new ReactorClientHttpRequest(\n\t\t\t\tclient, uri, httpMethod, this.exchangeTimeout, this.readTimeout);\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tif (this.httpClient == null) {\n\t\t\t\t\tthis.httpClient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"Restarting a ReactorClientHttpRequestFactory bean is only supported \" +\n\t\t\t\t\t\"with externally managed Reactor Netty resources\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tthis.httpClient = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn (this.httpClient != null);\n\t}\n\n\t@Override\n\tpublic int getPhase() {\n\t\treturn 1; // start after ReactorResourceFactory (0)\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.http.client;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.time.Duration;\nimport java.util.function.Function;\n\nimport io.netty.channel.ChannelOption;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport reactor.netty.http.client.HttpClient;\nimport reactor.netty.resources.ConnectionProvider;\nimport reactor.netty.resources.LoopResources;\n\nimport org.springframework.context.SmartLifecycle;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * Reactor-Netty implementation of {@link ClientHttpRequestFactory}.\n *\n * <p>This class implements {@link SmartLifecycle} and can be optionally declared\n * as a Spring-managed bean in order to support JVM Checkpoint Restore.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 6.2\n */\npublic class ReactorClientHttpRequestFactory implements ClientHttpRequestFactory, SmartLifecycle {\n\n\tprivate static final Log logger = LogFactory.getLog(ReactorClientHttpRequestFactory.class);\n\n\tprivate static final Function<HttpClient, HttpClient> defaultInitializer =\n\t\t\tclient -> client.compress(true).responseTimeout(Duration.ofSeconds(10));\n\n\n\t@Nullable\n\tprivate final ReactorResourceFactory resourceFactory;\n\n\t@Nullable\n\tprivate final Function<HttpClient, HttpClient> mapper;\n\n\t@Nullable\n\tprivate Integer connectTimeout;\n\n\t@Nullable\n\tprivate Duration readTimeout;\n\n\t@Nullable\n\tprivate Duration exchangeTimeout;\n\n\t@Nullable\n\tprivate volatile HttpClient httpClient;\n\n\tprivate final Object lifecycleMonitor = new Object();\n\n\n\t/**\n\t * Constructor with default client, created via {@link HttpClient#create()},\n\t * and with {@link HttpClient#compress compression} enabled.\n\t */\n\tpublic ReactorClientHttpRequestFactory() {\n\t\tthis(defaultInitializer.apply(HttpClient.create()));\n\t}\n\n\t/**\n\t * Constructor with a given {@link HttpClient} instance.\n\t * @param client the client to use\n\t */\n\tpublic ReactorClientHttpRequestFactory(HttpClient client) {\n\t\tAssert.notNull(client, \"HttpClient must not be null\");\n\t\tthis.resourceFactory = null;\n\t\tthis.mapper = null;\n\t\tthis.httpClient = client;\n\t}\n\n\t/**\n\t * Constructor with externally managed Reactor Netty resources, including\n\t * {@link LoopResources} for event loop threads, and {@link ConnectionProvider}\n\t * for connection pooling.\n\t * <p>Generally, it is recommended to share resources for event loop\n\t * concurrency. This can be achieved either by participating in the JVM-wide,\n\t * global resources held in {@link reactor.netty.http.HttpResources}, or by\n\t * using a specific, shared set of resources through a\n\t * {@link ReactorResourceFactory} bean. The latter can ensure that resources\n\t * are shut down when the Spring ApplicationContext is stopped/closed and\n\t * restarted again (e.g. JVM checkpoint restore).\n\t * @param resourceFactory the resource factory to get resources from\n\t * @param mapper for further initialization of the client\n\t */\n\tpublic ReactorClientHttpRequestFactory(\n\t\t\tReactorResourceFactory resourceFactory, Function<HttpClient, HttpClient> mapper) {\n\n\t\tthis.resourceFactory = resourceFactory;\n\t\tthis.mapper = mapper;\n\t\tif (resourceFactory.isRunning()) {\n\t\t\tthis.httpClient = createHttpClient(resourceFactory, mapper);\n\t\t}\n\t}\n\n\tprivate HttpClient createHttpClient(ReactorResourceFactory factory, Function<HttpClient, HttpClient> mapper) {\n\t\tHttpClient client = HttpClient.create(factory.getConnectionProvider());\n\t\tclient = defaultInitializer.andThen(mapper).apply(client);\n\t\tclient = client.runOn(factory.getLoopResources());\n\t\tif (this.connectTimeout != null) {\n\t\t\tclient = client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t\tif (this.readTimeout != null) {\n\t\t\tclient = client.responseTimeout(this.readTimeout);\n\t\t}\n\t\treturn client;\n\t}\n\n\n\t/**\n\t * Set the connect timeout value on the underlying client.\n\t * Effectively, a shortcut for\n\t * {@code httpClient.option(CONNECT_TIMEOUT_MILLIS, timeout)}.\n\t * <p>By default, set to 30 seconds.\n\t * @param connectTimeout the timeout value in millis; use 0 to never time out.\n\t * @see HttpClient#option(ChannelOption, Object)\n\t * @see ChannelOption#CONNECT_TIMEOUT_MILLIS\n\t * @see <a href=\"https://projectreactor.io/docs/netty/release/reference/index.html#connection-timeout\">Connection Timeout</a>\n\t */\n\tpublic void setConnectTimeout(int connectTimeout) {\n\t\tAssert.isTrue(connectTimeout >= 0, \"Timeout must be a non-negative value\");\n\t\tthis.connectTimeout = connectTimeout;\n\t\tHttpClient httpClient = this.httpClient;\n\t\tif (httpClient != null) {\n\t\t\tthis.httpClient = httpClient.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t}\n\n\t/**\n\t * Variant of {@link #setConnectTimeout(int)} with a {@link Duration} value.\n\t */\n\tpublic void setConnectTimeout(Duration connectTimeout) {\n\t\tAssert.notNull(connectTimeout, \"ConnectTimeout must not be null\");\n\t\tsetConnectTimeout((int) connectTimeout.toMillis());\n\t}\n\n\t/**\n\t * Set the read timeout value on the underlying client.\n\t * Effectively, a shortcut for {@link HttpClient#responseTimeout(Duration)}.\n\t * <p>By default, set to 10 seconds.\n\t * @param timeout the read timeout value in millis; must be > 0.\n\t */\n\tpublic void setReadTimeout(Duration timeout) {\n\t\tAssert.notNull(timeout, \"ReadTimeout must not be null\");\n\t\tAssert.isTrue(timeout.toMillis() > 0, \"Timeout must be a positive value\");\n\t\tthis.readTimeout = timeout;\n\t\tHttpClient httpClient = this.httpClient;\n\t\tif (httpClient != null) {\n\t\t\tthis.httpClient = httpClient.responseTimeout(timeout);\n\t\t}\n\t}\n\n\t/**\n\t * Variant of {@link #setReadTimeout(Duration)} with a long value.\n\t */\n\tpublic void setReadTimeout(long readTimeout) {\n\t\tsetReadTimeout(Duration.ofMillis(readTimeout));\n\t}\n\n\t/**\n\t * Set the timeout for the HTTP exchange in milliseconds.\n\t * <p>By default, as of 6.2 this is no longer set.\n\t * @see #setConnectTimeout(int)\n\t * @see #setReadTimeout(Duration)\n\t * @see <a href=\"https://projectreactor.io/docs/netty/release/reference/index.html#timeout-configuration\">Timeout Configuration</a>\n\t * @deprecated as of 6.2 and no longer set by default (previously 5 seconds)\n\t * in favor of using Reactor Netty HttpClient timeout configuration.\n\t */\n\t@Deprecated(since = \"6.2\", forRemoval = true)\n\tpublic void setExchangeTimeout(long exchangeTimeout) {\n\t\tAssert.isTrue(exchangeTimeout > 0, \"Timeout must be a positive value\");\n\t\tthis.exchangeTimeout = Duration.ofMillis(exchangeTimeout);\n\t}\n\n\t/**\n\t * Variant of {@link #setExchangeTimeout(long)} with a Duration value.\n\t * <p>By default, as of 6.2 this is no longer set.\n\t * @see #setConnectTimeout(int)\n\t * @see #setReadTimeout(Duration)\n\t * @see <a href=\"https://projectreactor.io/docs/netty/release/reference/index.html#timeout-configuration\">Timeout Configuration</a>\n\t * @deprecated as of 6.2 and no longer set by default (previously 5 seconds)\n\t * in favor of using Reactor Netty HttpClient timeout configuration.\n\t */\n\t@Deprecated(since = \"6.2\", forRemoval = true)\n\tpublic void setExchangeTimeout(Duration exchangeTimeout) {\n\t\tAssert.notNull(exchangeTimeout, \"ExchangeTimeout must not be null\");\n\t\tsetExchangeTimeout((int) exchangeTimeout.toMillis());\n\t}\n\n\n\t@Override\n\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpClient client = this.httpClient;\n\t\tif (client == null) {\n\t\t\tAssert.state(this.resourceFactory != null && this.mapper != null,\n\t\t\t\t\t\"Expected HttpClient or ResourceFactory and mapper\");\n\t\t\tclient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t}\n\t\treturn new ReactorClientHttpRequest(client, httpMethod, uri, this.exchangeTimeout);\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tif (this.httpClient == null) {\n\t\t\t\t\tthis.httpClient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"Restarting a ReactorClientHttpRequestFactory bean is only supported \" +\n\t\t\t\t\t\"with externally managed Reactor Netty resources\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tthis.httpClient = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn (this.httpClient != null);\n\t}\n\n\t@Override\n\tpublic int getPhase() {\n\t\treturn 1; // start after ReactorResourceFactory (0)\n\t}\n\n}\n"
    },
    {
        "index": 11,
        "repo": "spring-projects/spring-framework",
        "commit_sha": "044da794f471b62e65a1dc903a3f1dc71547f070",
        "before": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.http.client;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.time.Duration;\nimport java.util.function.Function;\n\nimport io.netty.channel.ChannelOption;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport reactor.netty.http.client.HttpClient;\nimport reactor.netty.resources.ConnectionProvider;\nimport reactor.netty.resources.LoopResources;\n\nimport org.springframework.context.SmartLifecycle;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * Reactor-Netty implementation of {@link ClientHttpRequestFactory}.\n *\n * <p>This class implements {@link SmartLifecycle} and can be optionally declared\n * as a Spring-managed bean in order to support JVM Checkpoint Restore.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 6.2\n */\npublic class ReactorClientHttpRequestFactory implements ClientHttpRequestFactory, SmartLifecycle {\n\n\tprivate static final Log logger = LogFactory.getLog(ReactorClientHttpRequestFactory.class);\n\n\tprivate static final Function<HttpClient, HttpClient> defaultInitializer = client -> client.compress(true);\n\n\n\t@Nullable\n\tprivate final ReactorResourceFactory resourceFactory;\n\n\t@Nullable\n\tprivate final Function<HttpClient, HttpClient> mapper;\n\n\t@Nullable\n\tprivate Integer connectTimeout;\n\n\tprivate Duration readTimeout = Duration.ofSeconds(10);\n\n\tprivate Duration exchangeTimeout = Duration.ofSeconds(5);\n\n\t@Nullable\n\tprivate volatile HttpClient httpClient;\n\n\tprivate final Object lifecycleMonitor = new Object();\n\n\n\t/**\n\t * Create a new instance of the {@code ReactorClientHttpRequestFactory}\n\t * with a default {@link HttpClient} that has compression enabled.\n\t */\n\tpublic ReactorClientHttpRequestFactory() {\n\t\tthis.httpClient = defaultInitializer.apply(HttpClient.create());\n\t\tthis.resourceFactory = null;\n\t\tthis.mapper = null;\n\t}\n\n\t/**\n\t * Create a new instance of the {@code ReactorClientHttpRequestFactory}\n\t * based on the given {@link HttpClient}.\n\t * @param httpClient the client to base on\n\t */\n\tpublic ReactorClientHttpRequestFactory(HttpClient httpClient) {\n\t\tAssert.notNull(httpClient, \"HttpClient must not be null\");\n\t\tthis.httpClient = httpClient;\n\t\tthis.resourceFactory = null;\n\t\tthis.mapper = null;\n\t}\n\n\t/**\n\t * Constructor with externally managed Reactor Netty resources, including\n\t * {@link LoopResources} for event loop threads, and {@link ConnectionProvider}\n\t * for the connection pool.\n\t * <p>This constructor should be used only when you don't want the client\n\t * to participate in the Reactor Netty global resources. By default the\n\t * client participates in the Reactor Netty global resources held in\n\t * {@link reactor.netty.http.HttpResources}, which is recommended since\n\t * fixed, shared resources are favored for event loop concurrency. However,\n\t * consider declaring a {@link ReactorResourceFactory} bean with\n\t * {@code globalResources=true} in order to ensure the Reactor Netty global\n\t * resources are shut down when the Spring ApplicationContext is stopped or closed\n\t * and restarted properly when the Spring ApplicationContext is\n\t * (with JVM Checkpoint Restore for example).\n\t * @param resourceFactory the resource factory to obtain the resources from\n\t * @param mapper a mapper for further initialization of the created client\n\t */\n\tpublic ReactorClientHttpRequestFactory(ReactorResourceFactory resourceFactory, Function<HttpClient, HttpClient> mapper) {\n\t\tthis.resourceFactory = resourceFactory;\n\t\tthis.mapper = mapper;\n\t\tif (resourceFactory.isRunning()) {\n\t\t\tthis.httpClient = createHttpClient(resourceFactory, mapper);\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the underlying connect timeout in milliseconds.\n\t * A value of 0 specifies an infinite timeout.\n\t * <p>Default is 30 seconds.\n\t * @see HttpClient#option(ChannelOption, Object)\n\t * @see ChannelOption#CONNECT_TIMEOUT_MILLIS\n\t */\n\tpublic void setConnectTimeout(int connectTimeout) {\n\t\tAssert.isTrue(connectTimeout >= 0, \"Timeout must be a non-negative value\");\n\t\tthis.connectTimeout = connectTimeout;\n\t\tHttpClient httpClient = this.httpClient;\n\t\tif (httpClient != null) {\n\t\t\tthis.httpClient = httpClient.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t}\n\n\t/**\n\t * Set the underlying connect timeout in milliseconds.\n\t * A value of 0 specifies an infinite timeout.\n\t * <p>Default is 30 seconds.\n\t * @see HttpClient#option(ChannelOption, Object)\n\t * @see ChannelOption#CONNECT_TIMEOUT_MILLIS\n\t */\n\tpublic void setConnectTimeout(Duration connectTimeout) {\n\t\tAssert.notNull(connectTimeout, \"ConnectTimeout must not be null\");\n\t\tsetConnectTimeout((int) connectTimeout.toMillis());\n\t}\n\n\t/**\n\t * Set the underlying read timeout in milliseconds.\n\t * <p>Default is 10 seconds.\n\t */\n\tpublic void setReadTimeout(long readTimeout) {\n\t\tAssert.isTrue(readTimeout > 0, \"Timeout must be a positive value\");\n\t\tthis.readTimeout = Duration.ofMillis(readTimeout);\n\t}\n\n\t/**\n\t * Set the underlying read timeout as {@code Duration}.\n\t * <p>Default is 10 seconds.\n\t */\n\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tAssert.notNull(readTimeout, \"ReadTimeout must not be null\");\n\t\tAssert.isTrue(!readTimeout.isNegative(), \"Timeout must be a non-negative value\");\n\t\tthis.readTimeout = readTimeout;\n\t}\n\n\t/**\n\t * Set the timeout for the HTTP exchange in milliseconds.\n\t * <p>Default is 5 seconds.\n\t */\n\tpublic void setExchangeTimeout(long exchangeTimeout) {\n\t\tAssert.isTrue(exchangeTimeout > 0, \"Timeout must be a positive value\");\n\t\tthis.exchangeTimeout = Duration.ofMillis(exchangeTimeout);\n\t}\n\n\t/**\n\t * Set the timeout for the HTTP exchange.\n\t * <p>Default is 5 seconds.\n\t */\n\tpublic void setExchangeTimeout(Duration exchangeTimeout) {\n\t\tAssert.notNull(exchangeTimeout, \"ExchangeTimeout must not be null\");\n\t\tAssert.isTrue(!exchangeTimeout.isNegative(), \"Timeout must be a non-negative value\");\n\t\tthis.exchangeTimeout = exchangeTimeout;\n\t}\n\n\tprivate HttpClient createHttpClient(ReactorResourceFactory factory, Function<HttpClient, HttpClient> mapper) {\n\t\tHttpClient httpClient = defaultInitializer.andThen(mapper)\n\t\t\t\t.apply(HttpClient.create(factory.getConnectionProvider()));\n\t\thttpClient = httpClient.runOn(factory.getLoopResources());\n\t\tif (this.connectTimeout != null) {\n\t\t\thttpClient = httpClient.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t\treturn httpClient;\n\t}\n\n\n\t@Override\n\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpClient httpClient = this.httpClient;\n\t\tif (httpClient == null) {\n\t\t\tAssert.state(this.resourceFactory != null && this.mapper != null, \"Illegal configuration\");\n\t\t\thttpClient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t}\n\t\treturn new ReactorClientHttpRequest(httpClient, uri, httpMethod, this.exchangeTimeout, this.readTimeout);\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tif (this.httpClient == null) {\n\t\t\t\t\tthis.httpClient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"Restarting a ReactorClientHttpRequestFactory bean is only supported \" +\n\t\t\t\t\t\"with externally managed Reactor Netty resources\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tthis.httpClient = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn (this.httpClient != null);\n\t}\n\n\t@Override\n\tpublic int getPhase() {\n\t\t// Start after ReactorResourceFactory\n\t\treturn 1;\n\t}\n\n}\n",
        "after": "/*\n * Copyright 2002-2024 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.http.client;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.time.Duration;\nimport java.util.function.Function;\n\nimport io.netty.channel.ChannelOption;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport reactor.netty.http.client.HttpClient;\nimport reactor.netty.resources.ConnectionProvider;\nimport reactor.netty.resources.LoopResources;\n\nimport org.springframework.context.SmartLifecycle;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * Reactor-Netty implementation of {@link ClientHttpRequestFactory}.\n *\n * <p>This class implements {@link SmartLifecycle} and can be optionally declared\n * as a Spring-managed bean in order to support JVM Checkpoint Restore.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 6.2\n */\npublic class ReactorClientHttpRequestFactory implements ClientHttpRequestFactory, SmartLifecycle {\n\n\tprivate static final Log logger = LogFactory.getLog(ReactorClientHttpRequestFactory.class);\n\n\tprivate static final Function<HttpClient, HttpClient> defaultInitializer = client -> client.compress(true);\n\n\n\t@Nullable\n\tprivate final ReactorResourceFactory resourceFactory;\n\n\t@Nullable\n\tprivate final Function<HttpClient, HttpClient> mapper;\n\n\t@Nullable\n\tprivate Integer connectTimeout;\n\n\tprivate Duration readTimeout = Duration.ofSeconds(10);\n\n\tprivate Duration exchangeTimeout = Duration.ofSeconds(5);\n\n\t@Nullable\n\tprivate volatile HttpClient httpClient;\n\n\tprivate final Object lifecycleMonitor = new Object();\n\n\n\t/**\n\t * Constructor with default client, created via {@link HttpClient#create()},\n\t * and with {@link HttpClient#compress compression} enabled.\n\t */\n\tpublic ReactorClientHttpRequestFactory() {\n\t\tthis(defaultInitializer.apply(HttpClient.create()));\n\t}\n\n\t/**\n\t * Constructor with a given {@link HttpClient} instance.\n\t * @param client the client to use\n\t */\n\tpublic ReactorClientHttpRequestFactory(HttpClient client) {\n\t\tAssert.notNull(client, \"HttpClient must not be null\");\n\t\tthis.resourceFactory = null;\n\t\tthis.mapper = null;\n\t\tthis.httpClient = client;\n\t}\n\n\t/**\n\t * Constructor with externally managed Reactor Netty resources, including\n\t * {@link LoopResources} for event loop threads, and {@link ConnectionProvider}\n\t * for connection pooling.\n\t * <p>Generally, it is recommended to share resources for event loop\n\t * concurrency. This can be achieved either by participating in the JVM-wide,\n\t * global resources held in {@link reactor.netty.http.HttpResources}, or by\n\t * using a specific, shared set of resources through a\n\t * {@link ReactorResourceFactory} bean. The latter can ensure that resources\n\t * are shut down when the Spring ApplicationContext is stopped/closed and\n\t * restarted again (e.g. JVM checkpoint restore).\n\t * @param resourceFactory the resource factory to get resources from\n\t * @param mapper for further initialization of the client\n\t */\n\tpublic ReactorClientHttpRequestFactory(\n\t\t\tReactorResourceFactory resourceFactory, Function<HttpClient, HttpClient> mapper) {\n\n\t\tthis.resourceFactory = resourceFactory;\n\t\tthis.mapper = mapper;\n\t\tif (resourceFactory.isRunning()) {\n\t\t\tthis.httpClient = createHttpClient(resourceFactory, mapper);\n\t\t}\n\t}\n\n\tprivate HttpClient createHttpClient(ReactorResourceFactory factory, Function<HttpClient, HttpClient> mapper) {\n\t\tHttpClient client = HttpClient.create(factory.getConnectionProvider());\n\t\tclient = defaultInitializer.andThen(mapper).apply(client);\n\t\tclient = client.runOn(factory.getLoopResources());\n\t\tif (this.connectTimeout != null) {\n\t\t\tclient = client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t\treturn client;\n\t}\n\n\n\t/**\n\t * Set the underlying connect timeout value on the underlying client.\n\t * Effectively, a shortcut for\n\t * {@code httpClient.option(CONNECT_TIMEOUT_MILLIS, timeout)}.\n\t * <p>By default, set to 30 seconds.\n\t * @param connectTimeout the timeout value in millis; use 0 to never time out.\n\t * @see HttpClient#option(ChannelOption, Object)\n\t * @see ChannelOption#CONNECT_TIMEOUT_MILLIS\n\t * @see <a href=\"https://projectreactor.io/docs/netty/release/reference/index.html#connection-timeout\">Connection Timeout</a>\n\t */\n\tpublic void setConnectTimeout(int connectTimeout) {\n\t\tAssert.isTrue(connectTimeout >= 0, \"Timeout must be a non-negative value\");\n\t\tthis.connectTimeout = connectTimeout;\n\t\tHttpClient httpClient = this.httpClient;\n\t\tif (httpClient != null) {\n\t\t\tthis.httpClient = httpClient.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, this.connectTimeout);\n\t\t}\n\t}\n\n\t/**\n\t * Variant of {@link #setConnectTimeout(int)} with a {@link Duration} value.\n\t */\n\tpublic void setConnectTimeout(Duration connectTimeout) {\n\t\tAssert.notNull(connectTimeout, \"ConnectTimeout must not be null\");\n\t\tsetConnectTimeout((int) connectTimeout.toMillis());\n\t}\n\n\t/**\n\t * Set the underlying read timeout in milliseconds.\n\t * <p>Default is 10 seconds.\n\t */\n\tpublic void setReadTimeout(long readTimeout) {\n\t\tAssert.isTrue(readTimeout > 0, \"Timeout must be a positive value\");\n\t\tthis.readTimeout = Duration.ofMillis(readTimeout);\n\t}\n\n\t/**\n\t * Variant of {@link #setConnectTimeout(int)} with a {@link Duration} value.\n\t */\n\tpublic void setReadTimeout(Duration readTimeout) {\n\t\tAssert.notNull(readTimeout, \"ReadTimeout must not be null\");\n\t\tsetReadTimeout((int) readTimeout.toMillis());\n\t}\n\n\t/**\n\t * Set the timeout for the HTTP exchange in milliseconds.\n\t * <p>Default is 5 seconds.\n\t */\n\tpublic void setExchangeTimeout(long exchangeTimeout) {\n\t\tAssert.isTrue(exchangeTimeout > 0, \"Timeout must be a positive value\");\n\t\tthis.exchangeTimeout = Duration.ofMillis(exchangeTimeout);\n\t}\n\n\t/**\n\t * Set the timeout for the HTTP exchange.\n\t * <p>Default is 5 seconds.\n\t */\n\tpublic void setExchangeTimeout(Duration exchangeTimeout) {\n\t\tAssert.notNull(exchangeTimeout, \"ExchangeTimeout must not be null\");\n\t\tsetExchangeTimeout((int) exchangeTimeout.toMillis());\n\t}\n\n\n\t@Override\n\tpublic ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {\n\t\tHttpClient client = this.httpClient;\n\t\tif (client == null) {\n\t\t\tAssert.state(this.resourceFactory != null && this.mapper != null,\n\t\t\t\t\t\"Expected HttpClient or ResourceFactory and mapper\");\n\t\t\tclient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t}\n\t\treturn new ReactorClientHttpRequest(\n\t\t\t\tclient, uri, httpMethod, this.exchangeTimeout, this.readTimeout);\n\t}\n\n\n\t@Override\n\tpublic void start() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tif (this.httpClient == null) {\n\t\t\t\t\tthis.httpClient = createHttpClient(this.resourceFactory, this.mapper);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.warn(\"Restarting a ReactorClientHttpRequestFactory bean is only supported \" +\n\t\t\t\t\t\"with externally managed Reactor Netty resources\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tif (this.resourceFactory != null && this.mapper != null) {\n\t\t\tsynchronized (this.lifecycleMonitor) {\n\t\t\t\tthis.httpClient = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isRunning() {\n\t\treturn (this.httpClient != null);\n\t}\n\n\t@Override\n\tpublic int getPhase() {\n\t\treturn 1; // start after ReactorResourceFactory (0)\n\t}\n\n}\n"
    }
]